# 389,636 - LDAP

## What is LDAP?

LDAP stands for **Lightweight Directory Access Protocol** and it is used for accessing various directory services, such as the Active Directory (AD) service in Windows. It uses ports `389` (unencrypted) and `636` (encrypted). **LDAP is the language that systems use to query AD**, similar to how web applications use HTTP to speak to web servers.

<figure><img src="../.gitbook/assets/ldap_http_comparison.png" alt=""><figcaption></figcaption></figure>

A Domain Controller (DC) can also be granted the **Global Catalog** role which is an LDAP-compliant directory consisting of **a partial representation of every object from every domain within the forest**. This is available by default on ports `3268` (unencrypted) and `3269` (encrypted).

## Authentication

{% hint style="success" %}
All domain users can authenticate with the LDAP server.
{% endhint %}

LDAP authenticates credentials against AD using a **BIND** operation. This operation establishes the authentication state for an LDAP session. There are two main types of LDAP authentication:

1. **Simple** → anonymous, unauthenticated, and username/password authentication. In this method, the client directly provides credentials to the LDAP server.
2. **Simple Authentication and Security Layer (SASL)** → allows LDAP to use external authentication services, such as Kerberos, rather than sending credentials directly. The client first authenticates with another system and then uses that trusted identity to bind to LDAP.
3. **SASL/GSSAPI** → a common SASL mechanism that integrates LDAP with Kerberos. If an attacker compromises a valid Kerberos ticket, they may be able to bind to LDAP without knowing the user’s password!

{% code overflow="wrap" %}
```
## Simple
Here is my username and password. LDAP, please verify them.

## SASL
I will authenticate using another supported mechanism. LDAP, use that method to verify who I am.

## SASL/GSSAPI
I have already authenticated using another trusted system. LDAP, please trust that authentication.
```
{% endcode %}

## Search Filters

The `Filter` and `LDAPFilter` params used by AD PowerShell module cmdlets are what tools like [PowerView](../tl-dr/active-directory/ad-tools/powerview.md) use under the hood.

### LDAP Queries

{% hint style="info" %}
[ldapwiki](https://ldapwiki.com/wiki/Wiki.jsp?page=Microsoft%20Active%20Directory) can be used to find example queries for [computers](https://ldapwiki.com/wiki/Wiki.jsp?page=Active%20Directory%20Computer%20Related%20LDAP%20Query), [users](https://ldapwiki.com/wiki/Wiki.jsp?page=Active%20Directory%20User%20Related%20Searches), and [groups](https://ldapwiki.com/wiki/Wiki.jsp?page=Active%20Directory%20Group%20Related%20Searches).
{% endhint %}

The `Get-ADObject` cmdlet along with its [`LDAPFilter`](https://learn.microsoft.com/en-us/powershell/module/activedirectory/get-adobject?view=windowsserver2025-ps#ldapfilter) parameter can be used to query AD:

{% code overflow="wrap" %}
```bash
# List all AD groups
Get-ADObject -LDAPFilter '(objectClass=group)' | select name

# Count domain users
(Get-ADObject -LDAPFilter '(&(objectCategory=person)(objectClass=user))').Count

# Disabled users
Get-ADObject -LDAPFilter '(&(objectCategory=person)(objectClass=user)(userAccountControl:1.2.840.113556.1.4.803:=2))' -Properties * | select samaccountname,useraccountcontrol
```
{% endcode %}

### AD Search Filters

{% code overflow="wrap" %}
```bash
# Filter out all Microsoft software
get-ciminstance win32_product -Filter "NOT Vendor like '%Microsoft%'" | fl

# User information
Get-ADUser -Filter "name -eq 'sally jones'"
Get-ADUser -Filter {name -eq 'sally jones'}

# Hostnames that contain the SQL string
Get-ADComputer  -Filter "DNSHostName -like 'SQL*'"

#Privileged groups
Get-ADGroup -Filter "adminCount -eq 1" | select Name

# Privileged ASREPRoastable users
Get-ADUser -Filter {adminCount -eq '1' -and DoesNotRequirePreAuth -eq 'True'}

# Kerberoastable users
Get-ADUser -Filter "adminCount -eq '1'" -Properties * | where servicePrincipalName -ne $null | select SamAccountName,MemberOf,ServicePrincipalName | fl

# Privileged account with SPN
Get-ADUser -LDAPFilter '(&(servicePrincipalName=*)(memberOf=CN=Protected Users,CN=Users,DC=Inlanefreight,DC=Local))' | select SamAccountName
```
{% endcode %}

### LDAP Search Filters

#### Polish Notation

LDAP filters must have one or more criteria and they are written with [Polish notation](https://en.wikipedia.org/wiki/Polish_notation), i.e., the operators are placed in front of the criteria (operands).

```powershell
# Two criteria
(&(..C1..)(..C2..))
(|(..C1..)(..C2..))

# Nested operations -> c1+c2 OR c3+c4
(|(&(..C1..)(..C2..))(&(..C3..)(..C4..)))
```

<table><thead><tr><th width="172">Criteria</th><th width="153">Rule</th><th>Example</th></tr></thead><tbody><tr><td>Equal to</td><td>(attribute=123)</td><td><code>(&#x26;(objectclass=user)(displayName=Smith))</code></td></tr><tr><td>Not equal to</td><td>(!(attribute=123))</td><td><code>(!objectClass=group)</code></td></tr><tr><td>Present</td><td>(attribute=\*)</td><td><code>(department=\*)</code></td></tr><tr><td>Not present</td><td>(!(attribute=\*))</td><td><code>(!homeDirectory=\*)</code></td></tr><tr><td>Greater than</td><td>(attribute>123)</td><td><code>(maxStorage>100000)</code></td></tr><tr><td>Less than</td><td>(attribute&#x3C;123)</td><td><code>(maxStorage&#x3C;100000)</code></td></tr><tr><td>Approximate match</td><td>(attribute~=123)</td><td><code>(sAMAccountName~=Jason)</code></td></tr><tr><td>Wildcards</td><td>(attribute=\*A)</td><td><code>(givenName=\*Sam)</code></td></tr></tbody></table>

#### Object Identifiers (OIDs)

In LDAP, an OID is a globally unique, hierarchical dotted-decimal number used to identify schema elements such as:

* **Object classes** (users → `1.2.840.113556.1.5.9`)
* **Attributes** (`sAMAccountName` → `1.2.840.113556.1.4.221`)

LDAP servers rely on OIDs internally, while humans typically use friendly names. This is because names can change, collide, or differ between vendors, whereas OIDs are stable and never change. This is especially important in environments like AD, where consistent schema identification is critical.

#### Matching Rule OIDs

A matching rule OID tells LDAP how to compare an attribute’s value with a search filter. The general format is:

```
(attribute : matchingRuleOID := value)
```

This is required when a simple equality comparison (`=`) is not sufficient, such as bitwise flag checks, recursive group membership, and special string or binary comparisons.&#x20;

Let's go over an example of a **bitwise matching rule**. Some attributes store multiple flags inside a single integer value. A normal equality comparison cannot isolate a specific flag, so LDAP uses a bitwise matching rule.

```
# Example filter
(userAccountControl:1.2.840.113556.1.4.803:=2)
```

* `userAccountControl` → an integer attribute containing multiple account flags
* `1.2.840.113556.1.4.803` → instructs LDAP to perform a bitwise `AND` comparison
* `2` → the value representing the `ACCOUNTDISABLE` flag

LDAP evaluates this as:

```
userAccountControl AND 2 == 2
```

which translates to _“Return all objects where the disabled account flag is set.”_

Bitwise checks are needed because some attributes do not represent a single value. Instead, they combine many on/off settings into one number. For example:

```
userAccountControl = 514
```

This value represents multiple account properties at the same time. Its binary representation is `1000000010`, each bit has a specific meaning, and several bits can be set simultaneously. The decimal number `514` is simply the sum of these bits.

<table><thead><tr><th width="122">Bit position</th><th width="115">Value (2ⁿ)</th><th width="131">Binary state</th><th width="373">Flag name</th></tr></thead><tbody><tr><td>Bit 9</td><td>512</td><td>1</td><td><code>NORMAL_ACCOUNT</code></td></tr><tr><td>Bit 8</td><td>256</td><td>0</td><td><code>TEMP_DUPLICATE_ACCOUNT</code></td></tr><tr><td>Bit 7</td><td>128</td><td>0</td><td><code>ENCRYPTED_TEXT_PASSWORD_ALLOWED</code></td></tr><tr><td>Bit 6</td><td>64</td><td>0</td><td><code>PASSWD_CANT_CHANGE</code></td></tr><tr><td>Bit 5</td><td>32</td><td>0</td><td><code>PASSWD_NOTREQD</code></td></tr><tr><td>Bit 4</td><td>16</td><td>0</td><td><code>LOCKOUT</code></td></tr><tr><td>Bit 3</td><td>8</td><td>0</td><td><code>HOMEDIR_REQUIRED</code></td></tr><tr><td>Bit 2</td><td>4</td><td>0</td><td><code>PASSWD_NOTREQD</code> (legacy)</td></tr><tr><td>Bit 1</td><td>2</td><td>1</td><td><code>ACCOUNTDISABLE</code></td></tr><tr><td>Bit 0</td><td>1</td><td>0</td><td><code>SCRIPT</code></td></tr></tbody></table>

A bitwise check asks _“Is this specific bit set?”_ rather than checking if the full number equals a value. So `514` essentially means that this is a disabled standard user account (`512` + `2`). A normal equality check fails in this case:

```
userAccountControl = 2   → FALSE (because 514 ≠ 2)
```

But the bitwise check succeeds:

```
userAccountControl AND 2 == 2   → TRUE
```

LDAP cannot express this logic using standard equality, which is why matching rule OIDs are required. The key takeaway is that matching rule OIDs exist because **some comparisons require special logic** that cannot be expressed with simple equality (`=`).

### Filter Types

| Operator | Meaning                  |
| -------- | ------------------------ |
| =        | Equal to                 |
| \~=      | Approximately equal to   |
| >=       | Greater than or equal to |
| <=       | Less than or equal to    |

### Item Types

| Type         | Meaning                  |
| ------------ | ------------------------ |
| =            | Simple                   |
| =\*          | Present                  |
| =something\* | Substring                |
| Extensible   | varies depending on type |

### Escaped Characters

| **Character** | **Represented as Hex** |
| ------------- | ---------------------- |
| \*            | \2a                    |
| (             | \28                    |
| )             | \29                    |
| \\            | \5c                    |
| NUL           | \00                    |

Some examples can be found below.

{% code overflow="wrap" %}
```powershell
# User accounts with non-empty description field
Get-ADUser -Properties * -LDAPFilter '(&(objectCategory=user)(description=*))' | select samaccountname,description

# Users marked as trusted for delegation
Get-ADUser -Properties * -LDAPFilter '(userAccountControl:1.2.840.113556.1.4.803:=524288)' | select Name,memberof, servicePrincipalName,TrustedForDelegation | fl

# Computers marked as trusted for delegation
Get-ADComputer -Properties * -LDAPFilter '(userAccountControl:1.2.840.113556.1.4.803:=524288)' | select DistinguishedName,servicePrincipalName,TrustedForDelegation | fl

# Administrative users who required no password
Get-AdUser -LDAPFilter '(&(objectCategory=person)(objectClass=user)(userAccountControl:1.2.840.113556.1.4.803:=32))(adminCount=1)' -Properties * | select name,memberof | fl
```
{% endcode %}

### Recursive Match

In the example below:

* `harry.jones` is a member of `Security Operations`
* `Security Operations` is a member of `Domain Admins`

Using the below command does not reveal nested memberships:

```powershell
Get-ADUser -Identity harry.jones -Properties * | select memberof | ft -Wrap
```

We can reveal those using the `RecursiveMatch` parameter or a matching OID rule:

```powershell
Get-ADGroup -Filter 'member -RecursiveMatch "CN=Harry Jones,OU=Network Ops,OU=IT,OU=Employees,DC=INLANEFREIGHT,DC=LOCAL"' | select name

Get-ADGroup -LDAPFilter '(member:1.2.840.113556.1.4.1941:=CN=Harry Jones,OU=Network Ops,OU=IT,OU=Employees,DC=INLANEFREIGHT,DC=LOCAL)' | select Name
```

### SearchBase & SearchScope

* `SearchBase` → specifies an AD path to search under (takes an OUs distinguished name)
* `SearchScope` → defines how deep into the OU to search
  * `Base (0)` → searches only the specified object itself (the exact DN), and does not search for any child objects
  * `OneLevel (1)` → searches for objects in the container but not in any sub-containers
  * `SubTree (2)` → searches for objects in the container and all child containers

#### Example

![searchbase\_examples.png](attachment:11ef3a0e-f797-47b4-9bc4-b0f1b0475247:searchbase_examples.png)

If we define our `SearchBase` to the `Employees` OU, the `Get-ADUser` will fetch:

* `Base` → nothing
* `OneLevel` → `Amelia Matthews`
* `SubTree` → all users in all sub-containers

```powershell
# Domain Users
> (Get-ADUser -SearchBase "OU=Employees,DC=INLANEFREIGHT,DC=LOCAL" -Filter *).count
970

# Base
> Get-ADUser -SearchBase "OU=Employees,DC=INLANEFREIGHT,DC=LOCAL" -SearchScope Base -Filter *

# OneLevel
> Get-ADUser -SearchBase "OU=Employees,DC=INLANEFREIGHT,DC=LOCAL" -SearchScope OneLevel -Filter *
DistinguishedName : CN=Amelia Matthews,OU=Employees,DC=INLANEFREIGHT,DC=LOCAL
...

# SubTree
> (Get-ADUser -SearchBase "OU=Employees,DC=INLANEFREIGHT,DC=LOCAL" -SearchScope Subtree -Filter *).count
970
```

### Exercises

```powershell
xfreerdp /v:10.129.2.174 /u:htb-student /p:Academy_student_AD! /cert-ignore

# Group membership
> Get-ADUser -Filter {samAccountName -eq 'harry.jones'}
DistinguishedName : CN=Harry Jones,OU=Network Ops,OU=IT,OU=Employees,DC=INLANEFREIGHT,DC=LOCAL
...

>  Get-ADGroup -Filter 'member -RecursiveMatch "CN=Harry Jones,OU=Network Ops,OU=IT,OU=Employees,DC=INLANEFREIGHT,DC=LOCAL"' | select name
name
----
...
Network Operations

# Trusted for delegation user
> Get-ADUser -Properties * -LDAPFilter '(userAccountControl:1.2.840.113556.1.4.803:=524288)' | select Name | fl
...
Name : sql-test

# Number of users in the IT OU (order counts: Specific -> General )
> (Get-ADUser -SearchBase "OU=IT,OU=EMPLOYEES,DC=INLANEFREIGHT,DC=LOCAL" -SearchScope Subtree -Filter *).count
118
```

## Tools

{% code overflow="wrap" %}
```bash
# validate credentials
ldapwhoami -x -v -D <domain> -w <pass> -H ldap://<ip>
# query LDAP
ldapsearch -x -v -D <domain> -w <pass> -H ldap://<ip> -b "DC=SUPPORT,DC=HTB"
# domain dump
ldapdomaindump.py -u <user> -p <pass> -at SIMPLE -n <dns-server>
```
{% endcode %}

Detailed queries can be found on the [`ldapsearch`](../tl-dr/active-directory/ad-tools/ldapsearch.md) page.

## Resources

{% tabs %}
{% tab title="Documentation" %}
{% embed url="https://ldap.com/" %}
{% endtab %}

{% tab title="LDAP Guide" %}
{% embed url="https://myhomeisquintoc.com/guide/ldap-enumeration" %}
{% endtab %}

{% tab title="ldapwhoami" %}
{% embed url="https://linux.die.net/man/1/ldapwhoami" %}
{% endtab %}

{% tab title="LDAPDomainDump" %}
{% embed url="https://github.com/dirkjanm/ldapdomaindump" %}
{% endtab %}
{% endtabs %}
