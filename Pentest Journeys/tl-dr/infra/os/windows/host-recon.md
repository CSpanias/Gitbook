# Host Recon

{% hint style="success" %}
For automated enumeration of potential PE vectors see [here](../../infra-tools/pe-scripts.md).
{% endhint %}

## Get Help

{% tabs %}
{% tab title="CMD" %}
```sh
# List available commands
help

# Help for a specified command
help <command>
<command> /?
```
{% endtab %}

{% tab title="PS" %}
```powershell
# List available commands
Get-Command

# Help for a specified command
Get-Help <command>
<command> -?
```
{% endtab %}
{% endtabs %}

## Networking

> _All the below commands work with both CMD and Powershell._

{% tabs %}
{% tab title="Network Info" %}
General networking information, such as interfaces, IP addresses, and DNS:

```sh
ipconfig /all
```
{% endtab %}

{% tab title="ARP Table" %}
Check recent communications via the ARP table:

```sh
arp -a
```
{% endtab %}

{% tab title="Active Connections" %}
List active TCP and UDP connections:

```sh
netstat -ano
```
{% endtab %}

{% tab title="Routes" %}
List recent and persistent routes:

```sh
route print
```
{% endtab %}
{% endtabs %}

{% tabs %}
{% tab title="Ports" %}
```powershell
Test-NetConnection -ComputerName 192.168.210.12 -Port 5985
```
{% endtab %}

{% tab title="Hosts" %}
```powershell
Test-Connection -Count 1 -Comp 10.10.10.10 -Quiet
```
{% endtab %}
{% endtabs %}

## System

{% tabs %}
{% tab title="General" %}
{% code overflow="wrap" %}
```sh
# General system information
systeminfo

# Name of the host
hostname

# Operating system version
[environment]::OSVersion.Version
ver
echo %OS%

# Environment variables
dir env:
set

# Diplay the value of a specific variable
set %PATH%
echo %PATH%

# Named pipes
gci \\.\pipe\

# Clipboard
Get-Clipboard
```
{% endcode %}
{% endtab %}

{% tab title="Applications" %}
{% code overflow="wrap" %}
```shell
# Installed applications
Get-WmiObject -Class Win32_Product |  select Name, Version
wmic product get name

# Installed applications (registry key queries)
# 32-bit apps
Get-ItemProperty "HKLM:\SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*" | select displayname
> GCI 'c:\program files (x86)'

# 64-bit apps
Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*" | select displayname
GCI 'c:\program files'
```
{% endcode %}
{% endtab %}

{% tab title="Processes" %}
```shell
# List running processes
tasklist
Get-Process

# Information about a specific process
Get-Process -Id <PID>
tasklist /FI "PID eq <PID>"
Get-Process -Name <process-name> | Format-list *
```
{% endtab %}

{% tab title="Services" %}
{% code overflow="wrap" %}
```shell
# Running services
Get-CimInstance -ClassName win32_service | Select Name, State, PathName | Where-Object { $_.State -eq "Running" }
tasklist /svc
net start
wmic service list brief # deprecated

# Auto-run services
wmic service get name,displayname,pathname,startmode |findstr /i "auto"

# Manage a service
net <start | stop | pause | continue> <service>

# Query running services
sc query type= service

# Check as which account each service is running as 
Get-CimInstance Win32_Process | Select-Object ProcessId, Name, @{Name="User";Expression={($_.GetOwner()).User}}
sc qc <service>

# Create a new service
sc create MyTestService binPath= "C:\Path\To\yourbinary.exe"

# Start / stop a service
sc <start | stop> <service>

# Modify start type (service won't be able to start with 'sc start <service>'
sc config <service> start= disabled

# Revert the change
sc config <service> start= auto
```
{% endcode %}
{% endtab %}

{% tab title="Other" %}
```shell
# Login server for the current user followed by the machine's hostname
echo %LOGONSERVER%

# The location of the current user's home directory
echo %USERPROFILE%
```
{% endtab %}
{% endtabs %}

## Users & Groups

{% tabs %}
{% tab title="Users" %}
{% code overflow="wrap" %}
```sh
# Domain/username (domain-joined) or NetBIOS/username (non domain-joined)
whoami # can be used to infer the purpose and type of the machine

# List current user's privileges
whoami /priv

# List current user's information
whoami /all

# List local users (net.exe only lists user objects, not group objects, so it can miss nested group memberships)
net user /domain
Get-LocalUser

# Query about the specified user
net user robert /domain

# List active (logged-on) users (works only on Windows Servers)
query user
```
{% endcode %}
{% endtab %}

{% tab title="Groups" %}
```sh
# List current user's groups
whoami /groups

# List local groups
net localgroup

# List domain groups (works only on a DC)
net group /domain
Get-LocalGroup

# Query about the specified group
net group 'Domain Admins' /domain

# List group members
net localgroup <group>
Get-LocalGroup <group>
```
{% endtab %}
{% endtabs %}

## Shared Resources

> _All the below commands work with both CMD and Powershell._

```powershell
# List resources
net share
```

## Protections

{% tabs %}
{% tab title="Windows Defender" %}
Check WD's status with PS:

```powershell
Get-MpComputerStatus
```

Check WD's status with CMD:

```sh
sc query windefend
```
{% endtab %}

{% tab title="AppLocker" %}
Check AppLocker's rules and policies with PS:

{% code overflow="wrap" %}
```powershell
# AppLocker rules
Get-AppLockerPolicy -Effective | select -ExpandProperty RuleCollections

# AppLocker policy
Get-AppLockerPolicy -Local | Test-AppLockerPolicy -path C:\Windows\System32\cmd.exe -User Everyone
```
{% endcode %}
{% endtab %}

{% tab title="HotFixes" %}
List hotfixes with both CMD and PS:

```powershell
wmic qfe
```
{% endtab %}
{% endtabs %}

## Files

{% hint style="warning" %}
PowerShell (PS) uses different **host types** depending on how it's being accessed, so the `(Get-PSReadlineOption).HistorySavePath` command will point to different files.

1. If the PS process is spawed as local (e.g. via SSH or RDP) → `ConsoleHost_history.txt`&#x20;
2. If the PS process is spawned as remote (e.g. WinRM) → `ServerRemoteHost_history.txt`
{% endhint %}

{% tabs %}
{% tab title="PowerShell" %}
{% code overflow="wrap" %}
```powershell
# List all (including) hidden files
Get-ChildItem -Force
# All dirs and files
GCI C:\Users\User -Force 
# Only hidden files
GCI C:\Users\User\ -Hidden

# Search for a specific file
Get-ChildItem -Path C:\ -Filter local.txt -Recurse -ErrorAction SilentlyContinue -Force

# Config files, temp saves
GCI C:\Users\User\AppData

# Check PS's host type
$Host.Name
# PS history of the current user
(Get-PSReadlineOption).HistorySavePath

# PS history file of another user
Get-Content C:\Users\<user>\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt

# History files of all host's users (assuming default path)
foreach($user in ((ls C:\users).fullname)){cat "$user\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history.txt" -ErrorAction SilentlyContinue}

# Documents in the user's home directory
Get-ChildItem -Path C:\Users\dave\ -Include *.txt,*.pdf,*.xls,*.xlsx,*.doc,*.docx -File -Recurse -ErrorAction SilentlyContinue
```
{% endcode %}
{% endtab %}

{% tab title="CMD" %}
{% code overflow="wrap" %}
```sh
# List all (including) hidden files
dir /a

# Search for a specific file
dir C:\local.txt /s /a
dir C:\ /s /a /b | findstr /i "local.txt"
```
{% endcode %}
{% endtab %}

{% tab title="Interesting Files" %}
{% code overflow="wrap" %}
```powershell
# Specific string (/SIM: simple and case insensitive, /C isn't related to the search start; it specifies the search string. The search starts from the beginning of each file specified in the command.)
findstr /SIM /C:"pass" *.txt *.ini *.cfg *.config *.xml

# KeePass database files
Get-ChildItem -Path C:\ -Include *.kdbx -File -Recurse -ErrorAction SilentlyContinue

# XAMPP configuration files
Get-ChildItem -Path C:\xampp -Include *.txt,*.ini -File -Recurse -ErrorAction SilentlyContinue

# Chrome dictionary files
gc 'C:\Users\bob\AppData\Local\Google\Chrome\User Data\Default\Custom Dictionary.txt' | Select-String password
```
{% endcode %}
{% endtab %}

{% tab title="Permissions" %}
```powershell
# Check permissions
icacls c:\windows\myfolder

# Grant full permissions
icacls c:\windows\myfolder /grant <USER>:f

# Remove permissions
icacls c:\users /remove <USER>
```
{% endtab %}

{% tab title="DPAPI" %}
PowerShell provides a convenient mechanism for storing encrypted credentials, commonly used in scripting and automation. These credentials are protected using the Data Protection API ([DPAPI](https://en.wikipedia.org/wiki/Data_Protection_API)), which enforces that **decryption is only possible by the same user account on the same system where the credentials were originally created**.

Consider a scenario where a script, such as `Connect-VC.ps1`, has been configured to connect to a vCenter server:

```powershell
# Create the credential file (Get-Credential opens a prompt)
Get-Credential | Export-Clixml -Path 'C:\scripts\pass.xml'
```

{% code title="Connect-VC.ps1" %}
```powershell
$encryptedPassword = Import-Clixml -Path 'C:\scripts\pass.xml'
$decryptedPassword = $encryptedPassword.GetNetworkCredential().Password

Connect-VIServer -Server 'VC-01' -User 'x7331_adm' -Password $decryptedPassword
```
{% endcode %}

While secure in normal operation, this protection is only as strong as the isolation of the user context. If command execution is obtained under the same user, or if DPAPI protections can be bypassed, the cleartext password can be retrieved directly from the stored credential file:

```powershell
> $credential = Import-Clixml -Path 'C:\scripts\pass.xml'
> $credential.GetNetworkCredential().username
x7331
> $credential.GetNetworkCredential().password
Passw0rd123!
```
{% endtab %}
{% endtabs %}

## Writable Directories

```powershell
C:\Windows\System32\spool\drivers\color
C:\Windows\Tasks
C:\Users\Public # similar to \Temp but more stealthy
C:\Windows\Temp # all users have rwx
C:\Users\<user>\AppData\Local\Temp # similar to above, but user-only
C:\windows\tracing
C:\Windows\Registration\CRMLog
C:\Windows\System32\FxsTmp
C:\Windows\System32\com\dmp
C:\Windows\System32\Microsoft\Crypto\RSA\MachineKeys
C:\Windows\System32\spool\PRINTERS
C:\Windows\System32\spool\SERVERS
C:\Windows\System32\Tasks\Microsoft\Windows\SyncCenter
C:\Windows\System32\Tasks_Migrated
C:\Windows\SysWOW64\FxsTmp
C:\Windows\SysWOW64\com\dmp
C:\Windows\SysWOW64\Tasks\Microsoft\Windows\SyncCenter
C:\Windows\SysWOW64\Tasks\Microsoft\Windows\PLA\System
```

Test access:

```powershell
# Move into the target directory
cd C:\Windows\Temp
# Create a file
echo "test" > test
# List the file's contents
type test
```

## Use another user's credentials

{% code overflow="wrap" %}
```powershell
# Create a PSCredential object
$pass = ConvertTo-SecureString '<password>' -AsPlainText -Force
$creds = New-Object System.Management.Automation.PSCredential('<domain\user', $pass)

# Add the target user to the group with PowerView
Add-DomainGroupMember -Identity '<group>' -Members '<user>' -Credential $creds

# Confirm
Get-DomainUser <user> -Credential $cred

# Execute remote commands on another host
Invoke-Command -Computer DC -Credential $cred -ScriptBlock { whoami; hostname }
```
{% endcode %}

## Binaries

We can transfer the binary in a Unix-based attacking host and run `strings` on it:

```bash
# strings with 16-bit encoding for Windows binaries
strings -eb <FILE> | grep pass
```
