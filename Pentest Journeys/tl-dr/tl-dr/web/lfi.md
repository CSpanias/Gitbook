---
layout:
  title:
    visible: true
  description:
    visible: false
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: true
---

# LFI

{% hint style="info" %}
Manipulating HTTP parameters to display the content of any local file on the hosting server.
{% endhint %}

Two types:

1. [**LFI**](#user-content-fn-1)[^1] -> the file chosen to be included is local on the target machine
2. [**RFI**](#user-content-fn-2)[^2] -> the file is included on other machines

The common place we usually find LFI within is **template engines**. These keep the static parts of the web application the same when navigating between different pages. For example, `/index.php?page=about'`:

* `/index.php` sets the static content
* `?page=about` pulls the dynamic content, e.g. `about.php`

## File Disclosure

### Basic LFI

Let's say we have a page with the following URL: `/index.php?language=es.php`

There are several ways the content could be changed to match the specified language:

1. Pulling the content from a different database table based on the specified parameter
2. Loading an entirely different web application version
3. **Loading part of the page using template engines (most common)**

In this case, let's assume that the third option is true. We could then do: `/index.php?language=/etc/passwd`.

### Path Traversal

Earlier we read the file using its **absolute path**: `/etc/passwd`. This would only work if the whole input was used within the `include()` function without any additions: `include($_GET['language']);`.

Often, web developers may append/prepend a string to the `language` parameter, for example, it may be used for the filename and may be added after a directory: `include("./languages/" . $_GET['language']);`. In this case, if we use the absolute path to read the file it will result at this: `./languages//etc/passwd`.

This can be easily bypassed by traversing directories using **relative paths**. If the full path of the ''languages'' directory is ''/var/www/html/languages'', then we could use:

`../../../../etc/passwd`

> We can default on using this technique, as it would work on both cases. In addition, if we are not sure of the directory the web application is in, we can add as many ''../'' as we want without breaking the path. If we were at ''/'' and use ''../'', we would still remain at ''/''.

### Filename Prefix

In some cases, our input may be appended after a different string, such as with a prefix to the full filename:

`include("lang_" . $_GET['language']);`

If we use the Path Traversal technique here, the final string would be ''lang\_../../../etc/passwd''. In this case, we can prefix a ''/'' before our input to be interpreter as a directory:

`/index.php?language=/../../../etc/passwd`

> This won't always work, for instance, a dir named ''lang\_/'' may not exist, so our relative path may not be correct. Furthermore, **any prefix appended to our input may break some file inclusion techniques**, like PHP wrappers and filters.

### Appended Extensions

Similary, an extension may be appended to our target parameter:

`include($_GET['language'] . ".php");`

This removes the need to write the extension every time the language must be changed as well as enforcing a restriction to only including PHP files. In this case, our payload would become: ''/etc/passwd.php''.

#### Path Truncation

This technique is based on the fact that, in earlier PHP versions, defined strings have a maximum length of ''4096'' characters and everything longer than that is being truncated. In addition, PHP used to remove trailing slashes and single dots in path names, so ''/etc/passwd/.'', would become ''/etc/passwd''.

Furthermore, PHP and Linux systems in general, disregard multiple ''/'' in the path, for example, ''////etc/passwd'' is the same as ''/etc/passwd''. Similarly, a current directory shortcut (''.'') in the middle of the path would also be disregarded.

Based on the those characteristics, we can create very long strings that evaluate to the target path.

> For this technique to work, we need to **start the path with a non-existing directory**.

`?language=non_existing_directory/../../../etc/passwd/./././.[./ REPEATED ~2048 times]`

We can automate the above with bash:

`$ echo -n "non_existing_directory/../../../etc/passwd/" && for i in {1..2048}; do echo -n "./"; done non_existing_directory/../../../etc/passwd/./././././././`

#### Null Byte

Appended extensions can be also bypassed with the use of a **null byte** (''%00'' or ''0x00'') in PHP versions < ''5.3.4'':

`/index.php?language=/../../../etc/passwd%00`

### &#x20;Path Traversal Filters

#### &#x20;Search and Replace

The **search and replace** filters is one of the most common defences against LFI; it simply deletes substrings of ''../'':

`$language = str_replace('../', '', $_GET['language']);`

So the payload ''../../../etc/passwd'' becomes ''.languages/etc/passwd''. If it is a **non-recursive** filter, that is, it runs just a single time on the input string, this can be bypassed by doubling up the ''../'' substring:

`/index.php?language=....//....//....//etc/passwd`

Doubling up the ''../'' substring is not the only option: ''..././'', ''..../'', ''....////'' and several other recursive LFI payloads may also work.

#### Character Filters

Some filters may prevent certain LFI-related characters, such as ''.'' and ''/''. This may be bypassed by URL encoding our payload once or twice, for example, ''../../../etc/passwd'' becomes:

`%2e%2e%2f%2e%2e%2f%2e%2e%2f%65%74%63%2f%70%61%73%73%77%64 %25%32%65%25%32%65%25%32%66%25%32%65%25%32%65%25%32%66%25%32%65%25%32%65%25%32%66%25%36%35%25%37%34%25%36%33%25%32%66%25%37%30%25%36%31%25%37%33%25%37%33%25%37%37%25%36%34`

### Approved Paths

Some web applications may included regex to ensure that the file being included is under a defined directory:

`if(preg_match('/^\.\/languages\/.+$/', $_GET['language'])) { include($_GET['language']); } else { echo 'Illegal path specified!'; }`

This can be bypassed by including the required directory within the payload:

`/index.php?language=./languages/../../../etc/passwd`

### PHP Filters

> Goal: **Read the source code of PHP files.**

\[\[https://www.php.net/manual/en/filters.php|PHP Filters]] are a type of \[\[https://www.php.net/manual/en/wrappers.php.php|PHP Wrappers]], where we can pass different types of input and have it filtered by the specified filter. To use PHP wrappers, we can use the ''php://'' scheme, and we can access the PHP filter wrapper using ''php://filter/''.

The \[\[https://www.php.net/manual/en/wrappers.php.php#wrappers.php.filter|PHP filter wrapper]] has various parameters, but we will use just ''resource'' and ''read''. The former is required and is used to specify the steam we would like to apply the filter on, in this case, a local file, whereas the latter applies different filters on the input resource, such as ''convert.base64-encode''.

The web site can be fuzzed for PHP files as follows:

`$ ffuf -w /opt/useful/SecLists/Discovery/Web-Content/directory-list-2.3-small.txt:FUZZ -u http://:/FUZZ.php index [Status: 200, Size: 2652, Words: 690, Lines: 64] config [Status: 302, Size: 0, Words: 1, Lines: 1]`

When visiting the ''config.php'' file via the browser, assuming that the web application appends the ''.php'' extension automatically, it may return an empty page, as this file only set ups the web application's configuration and it does not render any HTML output.

A PHP filter can be constructed with the goal of obtaining the encoded source code, instead of having it executed and rendered:

`/index.php?language=php://filter/read=convert.base64-encode/resource=config`

This will return an encoded string, which we can subsequently decode and read:

`echo '' | base64 -d`

### Second-Order Attacks

This is considered a more advanced technique. A web server may allows us, for instance, to download our avatar using ''/profile/$username/avatar.png''. If we craft a malicious LFI username, such as ''../../../etc/passwd'', then it may be possible to change the file being downloaded.

In this case, we would be poisoning a database entry with a malicious LFI payload in our username. Then, another web application functionality would utilize this entry to perform our attack, i.e., download our avatar based on username value.

Developers often overlook these vulnerabilities, as they may protect against direct user input, but they may trust values pulled from their database. If we manage to poison our username during our registration, then the attack would be possible. To perform this type of attack, we need to spot a function that pulls a file based on a value we indirectly control and then try to control that value to exploit the vulnerability.

## Resources

{% tabs %}
{% tab title="HTB" %}
{% embed url="https://academy.hackthebox.com/module/details/23" %}
{% endtab %}

{% tab title="PostSwigger" %}
{% embed url="https://portswigger.net/web-security/file-path-traversal" %}
{% endtab %}

{% tab title="THM" %}
{% embed url="https://tryhackme.com/jr/fileinc" %}
{% endtab %}
{% endtabs %}

[^1]: Local File Inclusion

[^2]: Remote File Inclusion
