---
layout:
  title:
    visible: true
  description:
    visible: false
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: true
---

# 101

SSRF vulnerabilities occur when the applications process and generate a request based on user-supplied input. Essentially, an SSRF flaw allows attacker to use the application as a proxy server. Interacting with the **loopback interface** can result to accessing ports that are externally inaccessible.

## Testing for SSRF

<figure><img src="../../../.gitbook/assets/web_ssrf_verify_link.png" alt=""><figcaption><p>Figure 1: Testing for SSRF.</p></figcaption></figure>

{% code overflow="wrap" %}
```bash
$ cat /var/log/apache2/access.log | grep ssrf
192.168.239.101 - - [17/Aug/2024:08:04:01 +0100] "GET /ssrf HTTP/1.1" 404 493 "-" "python-requests/2.26.0"
192.168.239.101 - - [17/Aug/2024:08:04:51 +0100] "HEAD /ssrf HTTP/1.1" 404 140 "-" "curl/7.79.1"
192.168.239.101 - - [17/Aug/2024:08:05:38 +0100] "HEAD /ssrf HTTP/1.1" 404 196 "-" "Wget/1.21.1"
```
{% endcode %}

## Exploiting SSRF

### Instance Metadata in Cloud

Many cloud providers have internal services that provide configuration metadata to the hosted VMs, which may include SSH public keys. AWS uses the link-local address `169.254.169.254` for their metadata services. GCP uses `metadata.google.internal` which may include private credentials.

Metadata services allow modifications to metadata via `POST` or `PUT` requests. If we only have access to a `GET` request, we will only be able to read metadata values. However, if we are able to update metadata, we may be able to gain access to the environment by adding our own SSH key to the list of allowed public keys.

### Bypassing Authentication in Microservices

Applications running in containers or as microservices will often have fewer security controls. Instead, they rely upon other systems, such as an API gateway or a reverse proxy, to provide security controls before forwarding traffic to the application.

If we can exploit a SSRF flaw in an application or microservice behind the security controls and make it talk directly to another microservice, we can potentially bypass the security controls of the latter. In other words, any security controls enforced by an API gateway on traffic entering the internal network would not apply to the traffic between the two microservices since the traffic originates within the internal network.

### Alternative URL Schemes

Depending on the user-agent that generates the forged request, we might be able to use protocols other than `HTTP`, such as the `file` scheme which allows us to reference files on the target server.

{% hint style="info" %}
The Python Requests library does not support the `file` scheme, but `curl` does.
{% endhint %}

A valid file URI requires a host and a path. However, we can omit the host value by using `/` that indicates there is not hostname (`file:/tmp/foo.txt`) or `///` to indicate an empty hostname (`file:///tmp/foo.txt`).

Some user agents, such as `curl`, support the [`Gopher`](https://en.wikipedia.org/wiki/Gopher\_\(protocol\)) protocol, which can be used to bypass some of the restrictions of a traditional SSRF flaw. Gopher allows newline characters in URLs which can be used to inject headers on the request. We should keep in mind that the first character of a Gopher request gets truncated (Figure 2).

```html
GET /gopher HTTP/1.1
Host: 127.0.0.1:9000
User-Agent: curl/7.74.0
Accept: */*
```

<figure><img src="../../../.gitbook/assets/web_ssrf_gopher_1.png" alt=""><figcaption><p>Figure 2: The first character of a Gopher's payload get's truncated.</p></figcaption></figure>

We can leverage the Gopher protocol to mimic a normal HTTP request and play around with different HTTP methods.

{% hint style="info" %}
Gopher normally runs on port `70`, so we need to make sure that we include the appropriate port.
{% endhint %}

<figure><img src="../../../.gitbook/assets/web_ssrf_gopher_2.png" alt=""><figcaption><p>Figure 3: Mimicking a <code>GET</code> HTTP request via Gopher.</p></figcaption></figure>

<figure><img src="../../../.gitbook/assets/web_ssrf_gopher_3.png" alt=""><figcaption><p>Figure 4: Sending a HTTP <code>POST</code> request with Gopher via a SSRF vulnerability.</p></figcaption></figure>

If we want to mimic a `POST` request the relevant headers and parameters should be injected as well. For example, if we want to mimic the request below:

```html
_POST /login HTTP/1.1
Content-Type: application/x-www-form-urlencoded
Content-Length: 41

username=white.rabbit&password=dontbelate
```

we can use [urlencoder](https://www.urlencoder.org/) to properly URL-encode and pass it to the SSRF vulnerable application:

{% code overflow="wrap" %}
```html
gopher://backend:80/_POST%20%2Flogin%20HTTP%2F1.1%0AContent-Type%3A%20application%2Fx-www-form-urlencoded%0AContent-Length%3A%2041%0A%0Ausername%3Dwhite.rabbit%26password%3Ddontbelate
```
{% endcode %}
