---
layout:
  title:
    visible: true
  description:
    visible: false
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: true
---

# Text Processing

## grep

`grep`, short for **Global Regular Expression Print**, is a command-line utility used to search for patterns within text. It scans input line by line and prints lines that match a given regular expression, making it essential for text searching and filtering.

<table><thead><tr><th width="114" align="right">Option</th><th>Function</th></tr></thead><tbody><tr><td align="right"><code>-i</code></td><td>case-insensitve search (case-sensitive by default)</td></tr><tr><td align="right"><code>-v</code></td><td>exclude a certain pattern</td></tr><tr><td align="right"><code>-o</code></td><td>print only the matched pattern (line by default)</td></tr><tr><td align="right"><code>-q</code></td><td>quiet mode (no output, interested in the return status)</td></tr><tr><td align="right"><code>-E</code></td><td>extended regex (regex instead of basic patterns)</td></tr></tbody></table>

{% tabs %}
{% tab title="Multiple Patterns" %}
Multiple patterns:

```bash
grep "<pattern1>\|<pattern2>" <file>
grep -e "<pattern1>" -e "<pattern2>" <file>
```
{% endtab %}

{% tab title="Substrings" %}
```bash
echo "<string>" | grep -q -E "<substring>"
```
{% endtab %}

{% tab title="PCRE" %}
Extract whatever comes after `Host:` .

* `o` prints only the matched parts of the line and not the entire line.
* `P` activates **Perl-compatible regular expressions (PCRE)**, in this case,`\K`:. This **resets the starting point of the match**, that is, only the characters after `\K` will be included in the output.

```bash
grep -oP 'Host:\s*\K[^\s;]*' "${NMAP_FILE}"
```
{% endtab %}
{% endtabs %}

## awk

`awk` is named after its creators: **Aho, Weinberger, and Kernighan**. It's a powerful Unix tool for **pattern scanning and processing** — often used to extract and manipulate text from files or input streams.

{% hint style="warning" %}
By default, it treats spaces/tabs as delimiters. This can be changed using `-F'<del>'`.&#x20;
{% endhint %}

{% tabs %}
{% tab title="Col Filtering" %}
```bash
# Extract the first field
awk '{print $1}' <file>

# Extract multiple fields
awk '{print $1,$4}' <file>
```
{% endtab %}

{% tab title="Row Filtering" %}
`$NF` (number of fields) represents the last field, while `$NR` (number of records) represents the total number of records:

```bash
# Start from the 3rd line and print the last field
awk 'NR > 3 {print $NF}' <file>
```
{% endtab %}

{% tab title="Printf" %}
Whatever is within `{}` is the `awk` script that will be executed for each input line. [`printf`](broken-reference) is a built-in `awk` function, which formats and prints data. `"%s "` defines the string format, in this case, the output should be a string (`%s`) followed by a space. `$0` represents the entire current line of input in `awk`:

```bash
# For each input line, print the entire line and add a space after it
awk '{printf "%s ", $0}'
```

We can add a newline character at the end using an `END` block. `END {...}` actions within an `END` block are executed after all input lines have been processed:

```bash
# Add a new line character after each line
awk '{printf "%s ", $0} END {print ""}'
```
{% endtab %}
{% endtabs %}

## sed

`sed`, which stands for **Stream Editor**, is a powerful tool for parsing and transforming text in a data stream. It reads input line by line, applies editing commands, and outputs the result, often used for non-interactive text processing and automation.

<table><thead><tr><th width="141" align="right">Option</th><th>Description</th></tr></thead><tbody><tr><td align="right"><code>s</code></td><td>substitution (replace)</td></tr><tr><td align="right"><code>g</code></td><td>global (across the whole file)</td></tr><tr><td align="right"><code>d</code></td><td>delete line</td></tr><tr><td align="right"><code>p</code></td><td>print line</td></tr><tr><td align="right"><code>-i</code></td><td>inplace changes</td></tr></tbody></table>

{% tabs %}
{% tab title="Substitution" %}
```bash
# Substitution
sed 's/<to-be-replaced>/<to-replace-with>/g' <file>
 
# Remove white space with substitution
sed 's/ //g' <file>

# Remove everything after
sed 's/<pattern>.*//g'
```
{% endtab %}

{% tab title="Deletion" %}
```bash
# Delete the first line
sed '1d' <file>

# Delete the last line
sed '$d' <file>

# Delete multiple lines
sed '1,7d' <file>

# Delete every word that starts with '1' inplace
sed -i '/^1/d' <file>
```
{% endtab %}

{% tab title="Filtering" %}
```bash
# Print specific line ranges
sed -n '1,3p' <file>
```
{% endtab %}
{% endtabs %}

## tr

`tr` is a Unix command used to **translate, delete, or squeeze characters** from input text.

{% tabs %}
{% tab title="Substitution" %}
```bash
cat <file> | tr '\n' ','
```
{% endtab %}

{% tab title="Deletion" %}
```bash
cat <file> | tr -d '[]'
```
{% endtab %}
{% endtabs %}

## printf

`printf` is a command in Unix/Linux used to **format and print text** to the terminal.

<table><thead><tr><th width="168">Format Specifier</th><th>Description</th></tr></thead><tbody><tr><td><code>%c</code></td><td>Treat the arguments as a single character.</td></tr><tr><td><code>%d</code></td><td>Treat the input as a decimal (integer) number (base 10).</td></tr><tr><td><code>%e</code></td><td>Treats the input as an exponential floating-point number.</td></tr><tr><td><code>%f</code></td><td>Treat the input as a floating-point number.</td></tr><tr><td><code>%i</code></td><td>Treat the input as an integer number (base 10).</td></tr><tr><td><code>%o</code></td><td>Treats the input as an octal number (base 8).</td></tr><tr><td><code>%s</code></td><td>Treat the input as a string of characters.</td></tr><tr><td><code>%u</code></td><td>Treat the input as an unsigned decimal (integer) number.</td></tr><tr><td><code>%x</code></td><td>Treats the input as a hexadecimal number (base 16).</td></tr><tr><td><code>%%</code></td><td>Print a percent sign.</td></tr><tr><td><code>%Wd</code></td><td>Print the <strong><code>W</code></strong> integer <strong><code>X</code></strong> digits wide.</td></tr><tr><td><code>%(format)T</code></td><td>Outputs a date-time string resulting from using format as a format string for <strong><code>strftime</code></strong>. The corresponding argument can be the number of seconds since Epoch (January 1, 1970, 00:00), <strong><code>-1</code></strong> (the current time), or <strong><code>-2</code></strong> (shell startup time). Not specifying an argument uses the current time as the default value.</td></tr><tr><td><code>\%</code></td><td>Print a percent sign.</td></tr><tr><td><code>\n</code></td><td>Prints a <strong><code>newline</code></strong> character.</td></tr><tr><td><code>\t</code></td><td>Print a <strong><code>tab</code></strong> character.</td></tr></tbody></table>

{% tabs %}
{% tab title="Basic Syntax" %}
```bash
# Syntax
printf "<specifier(s)>" "string"
 
# New line
printf "%s\n" "str1" "str2" "str3"
str1
str2
str3
```
{% endtab %}

{% tab title="Multiple Specifiers" %}
When multiple specifiers are used, they are replaced by a corresponding argument:

```bash
printf "%s\n%s\t%s\n" "str1" "str2" "str3" "str4"
str1
str2    str3
str4
```
{% endtab %}

{% tab title="Variables" %}
Assign output to a variable:

```bash
printf -v var "%s\n" hello
echo $var
hello
```
{% endtab %}
{% endtabs %}

## tee

`tee`, which stands for the **T-splitter in plumbing**, **reads input** from `stdin`, **writes it to a file**, and **also outputs it to `stdout`** — effectively "splitting" the stream.

{% tabs %}
{% tab title="Second Tab" %}
Print the string to stdout and save it into a file:

```bash
echo "hello" | tee file.txt
```
{% endtab %}

{% tab title="Append" %}
```bash
# Print file contents
$ cat test.txt
test

# Display & append string to the file 
$ echo "test1" | tee -a test.txt
test1

$ cat test.txt
test
test1
```
{% endtab %}
{% endtabs %}
